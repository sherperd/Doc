前言
1、软件能做什么，以及是怎么做的。
2、Linux是一个很好的平台，因为它是一个透明的系统。大多数系统配置都存放在文本文件中，让人一目了然。难点：了解每个组件分别负责什么，以及它们如何系统工作。
3、对象：系统运维----了解全书中的几乎所有内容；Linux软件架构师和开发人员---了解，以便发挥操作系统的最大功效。个人---理解为什么系统是那个样子的。
4、要求：操作GUI(特别是能看懂各种Linux发行版的安装和配置界面)，需要知道什么是文件什么是目录。查看系统文档或网上搜索一些相关文章。最重要的是对电脑的热情。
5、方法：阅读的内容有些枯燥和难懂，可稍事休息。
6、操作：$，普通用户提示符；#，超级用户。
7、主要Linux版本：Debian(Ubuntu)和RHEL/Fedora/CentOS.本书主要针对的是桌面和服务器系统。嵌入式系统(如Android和OpenWRT)。
8、Linux和Unix历史，参考Peter H.Salus所著The Daemon，the Gnu，and the Penguin(Reed Media Services，2008)

第 1 章 概述
1、理解操作系统工作原理最好的方法是抽象思维。暂时忽略大部分细节。
2、软件开发人员运用抽象思维来开发操作系统和应用程序。术语如子系统、模块和包等。组件，哪些及怎么使用。
3、组件的层次代表它在用户和硬件系统之间所处的位置。
4、Linux操作系统主要分三层。硬件系统、内核(OS核心，内核空间，kernel space)、进程(用户空间，user space，用户进程)。
5、内核是运行在内存中的软件，它向中央处理器发送指令。管理硬件系统和应用程序之间进行通信的接口。
6、所有的Web服务器都是以用户进程的形式运行的。
7、在内核模式中运行的代码可以不受限制地访问中央处理器和内存，功能强大，但也非常危险。
8、主内存(main memory)，或许是所有硬件系统中最为重要的部分。状态(state)，一个状态就是一组特定排列的比特。使用抽象词汇描述状态。
9、通常使用抽象词汇而非比特值来描述状态，映象(image)用来表示比特值在内存中的特定物理排列。
10、内核将内存划分为很多区块，并且一直维护着这些区块的状态信息。内核必须确保每个进程只是用它自己的内存模块。
11、内核负责管理：进程、内存、设备驱动程序、系统调用和支持。推荐书籍《Operating System Concepts，9th Edition》、《Modern Operating System，4th Edition》
12、进程管理：启动、暂停、恢复和终止。
13、进程，依次轮流，时间单位为毫秒级。一个进程让出CPU是用权给另一个进程称为上下文切换(context switch)。多任务执行
14、进程通常在单个时间段内就能完成它的工作。
15、内核负责上下文切换。内核是在上下文切换时的时间段间隙中运行的。
16、为将所有CPU的使用率最大化，内核会使用一些其他方式来获取CPU控制权。
17、内核在上下文切换过程中管理内存。
18、通过使用磁盘交换，系统可使用比实际内存容量更多的内存空间。
19、新型的CPU提供MMU(Memory Management Unit,内存管理单元)。MMU使用了一种叫做虚拟内存的内存访问机制，即进程不直接访问内存的实际物理地址，而是通过内核使得进程看起来可以使用整个系统的内存。
20、进程访问内存，MMU截获访问请求，然后通过内存映射表将要访问的内存地址转换为实际的物理地址。内核需要初始化、维护和更新这个地址映射表。如，在上下文切换时，内核将内存映射表从被移出进程转给被移入进程使用。
21、内存映射表通过内存页面表(page table)来实现。
22、设备只能在内核模式中被访问，因为设备访问不当有可能会让系统崩溃。不同设备之间没有一个统一的编程接口，它尽可能为用户进程提供统一的接口，简化开发人员的工作。
23、除了init以外，Linux中的所有用户进程都通过fork()来启动的。exec(),替换当前进程。
24、内核为用户提供了很多其他功能，最常见的是虚拟设备。它对于用户而言是物理设备，但其实它们都是通过软件实现的。如内核的随机数生成器(/dev/random)
25、进程总是避免不了要和系统调用打交道。
26、一个进程简单的说就是内存中的一个状态。用户空间(userland)。
27、Linux的大多数操作都发生在用户空间。
28、基础服务层。
29、大部分程序使用标准的系统日志服务。
30、一个用户代表一个实体，它有权运行用户进程，对文件拥有所有权。每个用户都有一个用户名。内核是通过用户ID(一串数字)来管理用户的。
31、用户机制主要用于权限管理。
32、系统管理员通常都避免使用root权限。root用户虽然权限很高，但还是运行在用户模式而非内核模式中运行。
33、用户组指一组用户的集合。主要作用是允许一个用户同组内的其他用户共享文件权限。
34、了解更多细节，需要实际操作一番。

第 2 章 基础命令和目录结构
1、《The Linux Commond Line》、《UNIX for the Impatient》、《Learning the UNIX Operation System，5th edition》
2、Bourne shell：/bin/sh，贝尔实验室开发的标准shell。
3、shell意思为命令行界面，是Unix操作系统中最为重要的部分之一。Unix程序员可以将通用的任务分解为一些小的组件，然后使用shell来管理和组织它们。
4、shell脚本，它们是包含一系列shell命令的文本文件。（MS-DOS，.bat批处理文件）。
5、Linux使用了一个增强版本的Bourne shell，称之为bash或者“Bourne-again” shell。大部分Linux系统的默认shell是bash，其通常有一个符号链接/bin/sh。
6、chsh命令更改默认shell。
7、shell窗口，也叫终端窗口。cat
8、Unix进程使用I/O流来读写数据。CTRL-D终止当前终端的标准输入并终止命令(通常会终止一个程序)；CTRL-C，终止当前进程的运行，无论是否有标准输入和输出。数据流机制。cat从Linux内核提供的默认标准输入流中获得输入数据。
9、标准流的一个优点是可以随心所欲地指定数据的输入和输出来源。
10、ls、cp、mv、touch、rm、echo。
11、通过路径或路径名来访问文件。cd、mkdir、rmdir、。使用-rf时尽量不要在参数里使用通配符(如*)，且执行命令前最好检查参数是否正确。
12、shell通配符，匹配文件名和目录。(*代表任意字符和数字)，?，帮助shell确切匹配任意一个字符。不想让shell展开通配符，可使用单引号。必须掌握(*和?)
13、注意：shell是先展开通配符，后执行命令的。
14、grep，显示文件和输入流中和参数匹配的行。-i、-v；egrep(grep -E).识别正则表达式(比通配符功能更强大)。
15、《Matering Regular Exception，3rd edition》《Programming Perl，4th edition》《Introduction to Automata Theory, Laguage,and Computation》
16、less，查看文件过大或内容过多需要滚屏。空格---下一屏，B---上一屏，Q---退出。实际是more的增强版本。一些Unix系统和嵌入式系统中没有这个命令。搜索，/---向前搜索，？---向后搜索，N---跳到下一个匹配。
17、pwd,符号链接，pwd -P，查看信息。
18、diff，查看两个文件的不同。-u，这个格式能被许多自动化工具很好的识别。
19、file,文件格式。find和locate，find可使用模式匹配，但必须加引号，以免shell自动将它们展开。locate在系统创建的文件索引中查找文件。这个索引由操作系统周期性的更新，查找速度比find快。
20、head(显示文件的前10行)和tail(显示文件的最后10行)
21、sort,将文件内的所有行按照字母顺序快速排序。-n，按照数字顺序排序那些数字的开头的行。-r，反向排序。
22、password，更改密码。设置密码的一个好方法，选择一个你能记住的短句，将其中的某些字符替换为数字和标点，然后将这个密码记牢。chsh更改shell。
23、dot文件，常见的dot文件有.bashrc和.login，shell通配符不匹配dot文件，除非明确指定.*。可使用正则表达式.[^.]*或.??*来排除这两个目录。
24、shell中可保存一些临时变量，称为shell变量，它们是一些字符值。可保存脚本执行过程中的数据。环境变量能够被shell中运行的所有进程访问。可通过export命令来设置。许多程序使用环境变量作为配置和选项信息。许多命令的帮助手册都有ENVIRONMENT，教你如何使用环境变量来设置该命令的参数和选项。
25、PATH是一个特殊的环境变量，它定义了命令路径(是一个系统目录列表，shell执行一个命令的时候，会去这些目录中查找这个命令)。
26、PATH=dir:$PATH，将路径/dir加入到PATH的最前面。PATH=$PATH:dir，最后面。
27、Linux，术语，《Jargon File》(http://www.catb.org/jargon/html)或它的印刷版本《The New Hacker's Dictionary》，
28、Perl编程语言，用到了几乎所有这些特殊字符。
29、使用ctrl键来替代箭头会更加方便。
30、Unix使用纯文本文件来保存配置信息。需要强大的编辑器。vi(高效快速)或Emacs(万能、强大、在线帮助)，Unix标准编辑器。
31、《Learning the vi and Vim Editors：Unix Text Processing，7th edition》
32、Linux系统的帮助文档非常丰富。帮助手册提供命令的使用说明。man -k keyword,借助关键字查找帮助手册。
33、帮助手册章节：用户命令、系统调用、Unix高级编程库文档、设备接口和设备驱动信息、文件描述符、游戏、文件格式、系统命令和服务器。
34、GUN，引入info文档，更加丰富。
35、>   >>
36、查看出错信息。
37、段错误、总线错误，通常是程序的输入数据有问题。
38、信号是内核发给进程的一条消息。当kill命令运行时，它请求内核发送一个信号给进程。
39、shell支持任务控制，是通过不同的按键和命令向进程发送TSTP信号的一种方式。
40、后台进程，&。在你退出系统后仍会一直运行，比较适合用于哪些耗时很长的进程。
41、权限位。s--(setuid)，将已文件拥有者的身份运行文件。chmod,更改文件权限。注意：不要将全局权限设置为可写，所有人都能修改文件。绝对权限设置(644)，umask，为文件设置预定的默认权限。
42、符号链接指向文件或者目录的文件。相当于文件的别名(类似于Windows中的快捷方式)。它为复杂的目录提供了便捷快速的访问方式。链式符号链接。
43、ln -s，创建符号链接。方便管理、组织、共享文件。
44、gzip(.gz).gunzip，只压缩单文件。
45、tar，压缩和归档多文件。cvf, xvf(解压)。内容预览模式，-t。。-p，保留被归档文件的权限信息。超级用户默认开启。zcat，等同于gunzip -dc，
46、注意：.tgz(主要针对MS-DOS的FAT文件系统)和.tar.gz文件没有区别。
47、Unix系统中另一个压缩命令bzip2(.bz2)，执行效率比gzip稍慢，主要用来压缩文本文件，常用在压缩源代码文件。bunzip2。xz，unxz
48、Linux系统的zip和unzip与Windows上的.zip文件格式大部分是兼容的，包括.zip和.exe自解压文件。
49、文件系统标准结构(FHS，http://www.pathanme.com/fhs/)。
50、/etc(读作EHT-see),存放系统配置文件。
51、代码库有两种：静态库和共享库。
52、/sbin，可执行的系统文件(用户一般不需要使用，许多只有root运行)。
53、/usr，读作user，存放许多Linux系统文件。
54、/var,程序存放运行信息的地方。如系统日志、用户信息、缓存和其他信息。
55、内核位置，/vmlinuz或者/boot/vmlinuz中。可加载内核模块，/lib/modules目录。
56、su，缺点：对更改系的统命令没有记录信息；对运行上述命令的用户身份没有记录信息；无法访问普通Shell环境；必须输入root密码。
57、sudo，它会使用local2中的系统日志服务将操作写入日志。
58、/etc/sudoers文件中加入指定的用户。可以使用visudo编辑/etc/suduoers文件。

第 3 章 设备管理
1、纵观Linux发展史，内核向用户呈现设备的方式发生了很大变化。sysfs，提供设备配置信息。
2、理解内核怎样在用户空间呈现新设备很关键。udev系统让用户空间进程能够自动配置和使用新设备。内核通过udev向用户空间进程发送消息，以及进程如何处理这些消息。
3、很多I/O接口都是以文件的形式由内核呈现给用户。这些设备文件有时也叫设备节点。对文件接口所能执行的操作是有限的，所以并不是所有设备或设备功能都能通过标准文件I/O方式来访问。
4、/dev/null，它是一个设备(内核直接忽略输入数据)，内核决定如何处理设备的数据写入
5、字符b(block),c(character)、p(pipe)、s(socket)。
6、块设备，程序从块中按固定的大小读取数据。字符设备，处理流数据；例子：打印机；注意：内核在流数据送达设备和进程后不会备份和造次验证。
7、管道设备，和字符设备类似，输入输出端不是内核驱动程序，而是另一个进程。套接字设备，跨进程通信经常用到的特殊接口。
8、主要和次要设备号，它们是内核用来识别设备的数字。相同类型的设备一般都有相同的主设备号。
9、Linux内核通过一个文件和目录系统提供sysfs界面，旨在基于硬件属性统一显示设备的相关信息。
10、/dev目录中的文件是供用户进程使用设备的。/sys/devices中的文件是用来查看设备信息和管理设备用的。
11、udevadm info，查看路径和其他属性。
12、dd，对于块设备和字符设备非常有用，主要功能是从输入文件和输入流读取数据然后写入文件和输出流，过程中可能涉及到编码转换。通常用来将输出数据写入到新文件。
13、sd,代表SCSI disk。小型计算机系统接口(Small Computer System Interface)，最初作为设备之间的通信的硬件协议标注而开发的，。USB存储设备使用SCSI协议进行通信。SATA硬盘，Linux内核仍然在某些场合使用SCSI命令和它们通信。
14、lsscsi，
15、Linux按照设备驱动程序检测到设备的顺序来分配设备文件。现代的Linux系统使用唯一标识符(Universally Unique Identifier，UUID)来访问设备。
16、Linux系统能将大多数光学设备识别为SCSI设备。光驱来接口，可能会被识别为PATA设备。
17、PATA硬盘，基于主从设备接口0和1的固定设置方式。SATA设备有时也会被这样识别，在兼容模式中运行，会造成性能损失。BIOS设置。
18、终端设备/dev/tty/*,/dev/pts/*,/dev/tty;负责在用户进程和输入输出设备之间传送字符，通常是在终端显示屏上显示文字。
19、伪终端设备模拟终端设备的功能，由内核为程序提供I/O接口，而不是真实的I/O设备。shell窗口就是伪终端。
20、/dev/tty1(第一虚拟控制台)，/dev/pts/0(第一虚拟终端)。
21、Linux系统有两种显示模式：文本模式和X Windows系统服务器，
22、ALT-F1切换到/dev/tty1，它经常别getty进程占用显示登陆提示符。
23、X Server在图形模式下使用的控制台稍微有些不同，它不是从init配置中获得询比控制台，而是由X Server来控制一个空闲的虚拟控制台。CTRL-ALT-Function切换虚拟控制台。
24、chvt，强制系统切换工作台。
25、串行端口在命令行上运用不太广，需要处理诸如波特率和流控制等参数的设置。
26、单向并行端口设备，目前被USB广泛取代的一种借口类型。
27、Linux两组音频设备，高级Linux声音架构(Advanced Linux Sound Architecture，ALSA)和开放声音系统(Open Sound System,OSS)
28、注意：Linux的音频处理非常复杂，涉及很多层细节。
29、现代Linux系统中，不需要创建自己的设备文件，由devtmpfs和udev来完成。mknod，创建设备。创建临时的命名管道很方便。
30、devtmpfs，内核根据需要创建设备文件，且在新设备可用时通知udevd。udevd在收到通知后并不创建设备文件，而是进行设备初始化以及发送消息通知。此外，还在/dev目录中为设备创建符号链接文件。udevd使用接口类型名称、厂商、型号、序列号以及分区(如果有的话)的组合来命名符号链接。
31、udevadm是udevd的管理工具，可使用它来重新加载udevd规则，触发消息。搜索和浏览系统设备以及监控udevd从内核接收消息。
32、主机适配器和设备都有一个SCSI ID，每个总线有8到16个ID(不同版本数量不同)。
33、SCSI目标值的是设备及其SCSI ID。
34、计算机并不和设备链直接连接，必须通过主机适配器和设备通信。主机适配器通过SCSI命令集与设备进行一对一通信，设备向其发送响应消息。
35、更新版本的SCSI如Serial Attached SCSI(SAS)的性能更出色，不过大部分计算机中并没有真正意义的SCSI设备。更多的是使用SCSI命令的USB存储设备。
36、SATA硬盘在系统中通常由一个处于libata层的转换机制呈现为SCSI设备。一些SATA控制器(特别是高性能RAID控制器)使用硬件来实现这些转换。
37、LUN(逻辑元件编号，设备的字备号)，内核为每个逻辑单元指定一个不同的设备文件。
38、ATA桥，USB桥。
39、注意：对每一个设备文件，内核都使用一个顶层中的驱动程序和一个底层中的驱动程序。
40、光驱的作用类似于把一本书敲入计算机。硬盘类似把一本德文书翻译成英文并敲入计算机。
41、libata能够将SCSI子系统连接到ATA/SATA接口和设备。
42、大多数用户进程不需要了解的一个不足时要注意路边的SCSI设备和命令。
43、访问设备的多种方法，sr和sg。

第 4 章 硬盘和文件系统
1、磁盘中又包含很多不同的组件和层。
2、分区是对整块硬盘的进一步划分，在Linux系统中由磁盘名称加数字来表示。内核将分区用块设备呈现，如同每个分区是一整块的磁盘。分区数据存放在磁盘上的分区表中。
3、大部分的系统有一个单独的交换区。
4、文件系统是用户空间中与你日常交互的文件和目录数据库。
5、注意：可通过文件系统或者磁盘设备来访问磁盘。
6、块设备接口和分区映射。
7、分区表有很多种，典型的一种是主导记录(Master Boot Record,MBR)，逐渐普及的是全局唯一标识符分区表(Globally Unique Identifier Partiation Table，GPT)
8、Linux系统各种分区工具，parted、gparted、fdisk(不支持GPT)、gdisk(不支持MBR)。
9、分区操作和文件系统操作有本质的不同，分区表划分磁盘的区域，而文件系统则侧重数据管理。
10、MBR(parted中称为msdos)，
11、主分区是磁盘的常规分区。MBR最多只能有4个主分区。扩展分区，逻辑分区。
12、内核在初始化读取Linux内核在初始化读取MBR表。
13、更改分区表有一定的风险。
14、大多数Linux系统会自动挂载被删除的文件系统。
15、fdisk和parted区别。fdisk让你首先设计好分区表，然后在退出fdisk之前才做实际的更改。parted则是在你运行命令的同时直接执行创建、更改和删除操作，没有机会在做更改之前确认检查。
16、parted没有使用磁盘系统调用，而是在分区表被更改的时候向内核发送信号，内核也不显示调试信息。
17、CHS，柱面(cylinder)----读写头(head)----扇区(sector)
18、传统使用的CHS的寻址方式无法适应现在的大容量硬盘，也无法处理外道柱面比内道柱面存储更多数据这种情况。
19、磁盘意见支持逻辑块寻址(Logical Block Addressing,LBA)，通过块编号来寻址，其余部分还是使用CHS。
20、引导装载程序大部分使用LBA。
21、柱面是一个很重要的概念，用来设置分区边界。
22、现在的硬盘提供的CHS信息不准，LBA能够确保你的分区位置。
23、固态硬盘(Solid State Disk,SSD),没有可移动的部件。分区布局是影响SSD性能的一个方面。SSD通常每次读取4096字节的数据。
24、文件系统通常是内核和用户空间之间联系的最后一环，也就是通过ls和cd等命令进行交互的对象。
25、文件系统是一个数据库，它将简单的块设备映射为用户易于理解的树状文件目录结构。
26、以往都由内核实现文件系统，Plan9的9P的出现促进了文件系统在用户空间中的实现。用户空间文件系统(Dile System in User Space)
27、抽象层虚拟文件系统(Virtual File System，VFS)负责文件系统的具体实现。
28、SCSI子系统将设备之间和设备与内核之间的通信标准化，VFS为用户空间进程访问不同文件系统提供了标准的接口。VFS使得Linux支持很多不同的文件系统。
29、第四扩展文件系统(ext4)，ext2作为Linux默认系统，源于Unix文件系统(Unix File System--UFS和Fast File System--FFS)。ext3增加了日志特性，提高了数据的完整性和启动速度。
30、FAT文件系统(msdos、vfat、umsdos)，微软的文件系统。
31、ISO 9660，CD-ROM标准。HFS+(hfsplus),苹果Macintosh计算机的文件系统标准。
32、正在开发的Btrfs文件系统可能取代扩展文件系统。
33、mkfs工具创建很多种文件系统。超级块是文件系统数据库上层的一个重要组件，以至于mkfs对其有多个备份以防其损坏。
34、只需要在增加磁盘和修复现有磁盘的时候创建文件系统。如果在已有文件系统上创建新的文件系统，所有的数据将会丢失。
35、mkfs是一系列文件系统创建的程序的前端界面。
36、挂载文件系统为mounting。系统启动时，内核根据配置信息挂载root目录。文件系统所在设备；文件系统类型；挂载点，是一个目录，可以是任何位置，只要不在/下即可。
37、将x设备挂载到x挂载点。mount查看当前文件系统状态
38、文件系统UUID，是一系列数字，并保证每个唯一。Linux原生分区都有标准UUID，但FAT分区没有。FAT分区可通过FAT卷序列号来引用。
39、系统启动时倾向于使用UUID来挂载文件系统。很多Linux系统使用UUID作为可移动媒体的挂载点。
40、缓冲机制带来了性能上的提高，对用户来说是透明的。sync命令强制内核将缓冲区的数据写入磁盘。内核有一系列的机制使用RAM自动缓存从磁盘读取的数据块。
41、mount -n，确保mount命令不会更新系统运行时的挂载数据库/etc/mtab。mount在root为只读的情况下无法写系统挂载数据库。
42、conv=rule，可能对文件造成损坏，可考虑在只读模式中使用。
43、/etc/fstab，文件系统表，永久保存了文件系统和选项列表。它是一个纯文本文件，格式很简单。如果操作的文件系统在这个文件中，可使用快捷方式。
44、两种新方式：/etc/fstab.d目录，文件系统配置systemd单元。
45、文件系统容量，文件系统中有容量的5%没被计算在内，它们是隐藏的预留块。特性使磁盘空间被沾满后系统不会马上崩溃。-m,-h(自动判断和使用对用户来说容易理解的单位)
46、du 
47、Unix文件系统通过一个复杂的数据库机制来提供性能优化。内核必须信任加载的文件系统不会出错。
48、文件系统错误通常是由于用户强行关闭系统导致(如直接拔掉电源)。文件系统检查也是保证数据完整的必要措施。
49、fsck，注意：不可以在一个已经挂载的文件系统上使用fsck。实际上，很多Linux发行版在启动时会在运行各自的fsck -p版本。
50、内核无法使用非空日志来挂载ext3和ext4.
51、磁盘严重损坏且没有备份，只能向专业的数据修复服务商寻求帮助。
52、Linux特殊用途的文件系统：proc，sysfs，tmpfs(可将物理内存和交换空间作为临时存储)。注意：不要经常随意地将数据存放到tmpfs，容易沾满系统内存，会导致程序崩溃。
53、内存空间不足的情况，Linux虚拟内存会自动将内存中的进程移出至磁盘以及从磁盘移出内存。称其为交换。用来保存内存页面的磁盘空间称为交换空间(swap space，简称swap)。free
54、使用磁盘、文件用作交换空间。两倍内存容量，对单用户系统来说适用。
55、高性能网络服务器需要尽可能避免磁盘存取和交换空间。它们有着复杂的监控和负载平衡系统来保证内存不会被完全耗尽。
56、传统的Unix文件系统有两个组件：一个用来存储数据的数据块池和一个用来管理数据池的数据库系统。数据库是inode数据结构的核心。inode是一组描述文件的数据。
57、注意：目录inode中包含了.和..两个条目，让你能够轻松地在目录结构中浏览。
58、删除文件称为取消连接。
59、root目录的inode 2的连接计数为4.超级块。使用块位图(block bitmap)来管理信息。
60、stat,inode数目和链接计数。
61、记住：内核只是系统调用的通道，而不会包含对某个特定的文件系统的支持。
62、性能、数据完整性、安全性。文件系统使用不同的数据结构来表示文件和目录。针对SSD优化的文件系统也在不断演进。

第 5 章 Linux内核的启动
1、理解启动过程对将来修复启动相关的问题会大有帮助。
2、启动消息，两种放式查看，内核系统日志文件(/var/log/kern.log)；使用dmesg命令(使用内核缓冲区，它的容量有限)。
3、有一些版本的init，如Upstart和systemd，可获得那些显示到屏幕的启动和运行时消息。
4、Linux内核初始化过程：检查CPU、检查内存、设备总线、设备、设置附加内核子系统(如网络等)、挂载root目录、启动用户空间。
5、设备相关的步骤设计一些依赖性问题。
6、内核在启动第一个用户进程时不会显示任何消息。
7、引导装载程序会向内核传递一系列文本形式的内核参数来设定内核启动方式。root参数很重要，它是root文件系统存放的位置。-s，传给init，让其单用户模式启动。
8、引导程序启动内核，然后内核和init启动。
9、内核机器参数在root文件系统里。
10、在个人电脑上，引导程序使用基本输入输出系统(BIOS)或统一可扩展固件接口(Unified Extensible Firmware Interface，UEFI)来访问磁盘。
11、几乎所有的磁盘设备都有固件系统供BIOS通过线性块寻址(Linear Block Addressing)来访问硬件。引导程序往往是唯一使用BIOS访问磁盘的程序，内核使用的是它自己的高性能驱动程序。
12、引导程序功能：能够灵活选择内核映象和参数。USB设备上执行紧急启动和恢复。
13、常见引导程序：GRUB(近乎于Linux标准)，LILO、SYSLINUX、LOADLIN(MS-DOS)、efilinux、coreboot、Linux Kernel EFISTUB。
14、设置内核名称和参数，首先需要了解如何进入启动提示符。
15、GRUB，大一统引导程序(Grand Unified Boot Loader).GRUB Legacy，已经淘汰。最重要的功能是对内核映象和配置的选择更为简便。
16、Linux发行版本尽可能将引导程序隐藏起来。BIOS或固件启动屏幕出现时按住SHIFT来打开GRUB菜单。e键查看引导装载程序命令的默认启动选项。
17、GRUB仅仅是启动内核，而不是使用它。GRUB有自己的“内核”和insmo命令来动态加载GRUB模块。
18、只有root内核参数是指root文件系统。
19、在启动菜单或配置编译器中按C键进入GRUB命令行。
20、前缀msdos包含MBR分区表。
21、GRUB寻找内核，echo $root。set查看所有已设置的GRUB变量。
22、Linux安装问题之一是安全启动。这个特性在UEFI中打开，需要引导装载程序被一个信任机构进行电子签名。如果对Windows不感兴趣，可在EFI设置中关闭安全启动。
23、UEFI使得加载其他操作系统相对容易，可在EFI分区上安装多个引导程序。
24、可以使用链式加载来让GRUB加载和运行指定分区上的不同引导操作系统。
25、传统计算机启动机制纷繁复杂，有两个主要机制：MBR和UEFI。
26、MBR有一个441字节大小的区域，BIOS在开机自检(Power-On Self-Test，POST)之后加载其中的内容。空间太小，引入多场景引导程序(multi-stage boot loader)
27、GPT的一种临时解决方案是创建一个小分区，称为BIOS启动分区，即使用一个特别的UUID作为存放完整启动加载代码的地方。
28、可扩展固件接口，EFI，统一可扩展固件接口，UEFI，包括了诸如内置命令行界面、读取分区表和浏览文件系统等特性。GPT分区方式也是UEFI标准的一部分。
29、EFI系统分区，ESP。
30、注意：ESP和BIOS启动分区不同。不能将老的引导装载程序代码放到ESP中，这些代码是为BIOS接口写的。必须提供位UEFI编写的引导程序代码。
31、一般BIOS会从MBR加载512字节，这也是GRUB起始的地方。

第 6 章 用户空间的启动
1、内核启动第一个用户空间进程是由init开始的。在此之前，内核执行的是受到严格控制的程序序列，由一小撮程序员开发和定义。用户空间更加模块化。可观察到其中进程的启动和运行过程。
2、用户空间大致启动顺序：init；基础的底层服务(udevd和syslogd)；网络配置；中高层服务(cron和打印机服务)；登录提示符，GUI及其他应用程序。
3、Linux系统中，init有以下三种主要的实现版本：System V init(Red Hat Enterprise)，systemd(新出现)；Upstart(Ubuntu)
4、嵌入系统，如Android。BSD。
5、System V init，顺序启动，依赖关系简单，但性能不好，启动无法任务并行。
6、systemd是面向目标的。借鉴Apple公司的启动程序。特性：可以延迟一些服务和操作系统功能的开启，直到需要时再开启。
7、新的init系统不是基于脚本文件，所以配置起来也相对简单。支持运行级别(runlevel)的概念。
8、系统运行级别，使用数字0~6来表示。who -r,查看系统的运行级别。运行级别的作用：区分系统的启动、关闭、单用户模式和控制台模式等不同的状态。已经过时。
9、systemd，单元，Mac,launchd。不要更改系统单元目录，它由系统来维护。选择/etc保存自定义设置。
10、单元文件，由XDG桌面条目规范(类似Windows中的ini文件)。区块[]名称
11、开启(enable)单元和激活(active)单元不同。
12、注意：如果单元文件中包含[install]区块，需要在激活前开启它。
13、systemd引进了控制组，他是Linux内核的一个可选特性，为的是提供更好的进程跟踪。延迟启动单元。使用辅助单元优化启动。目的之一就是减少系统中脚本文件的数量。
14、记住：服务启动后，启动服务的systemd任务即终止。
15、服务单元文件名和套接字单元文件名的前缀一样，systemd会在套接字单元有请求时激活服务单元。
16、Upstart，涉及任务和事件。问题：没有办法清晰地查看事件的来龙去脉。任务两大类：Task任务、Service任务。抽象任务。initctl list
17、无法查看通过Upstart的System V兼容特性启动任务。单从状态上无法分辨任务是已执行完毕还是从未启动。
18、容器配置文件，因为Upstart不仅仅在硬件系统的内核上运行，还能再虚拟环境和容器中运行。
19、/ect/init.d文件中的伪脚本比较让人头疼。
20、ctrlaltdel,它执行shutdown，
21、System V init连接池(Link Farm),大量符号链接
22、run-parts，
23、关闭系统，shutdown
24、initramfs，初始RAM文件系统。用户空间的楔子。过程很复杂，工具：dracut、mkinitramfs。cpio归档文件的维护更简单。
25、紧急启动和单用户模式。系统恢复时通常优先考虑安装镜像。

第 7 章 系统配置：日志、系统时间、批处理任务和用户
1、系统组件，使得用户级工具能够反复顾问系统的基础设施。
2、Linux大部分系统配置文件都存放在/etc目录中。
3、將定制的配置文件放到子目录里的其他文件中，避免配置文件被覆蓋。
4、系統日志，
5、大多数Linux系统使用的是syslogd的新版本，叫rsyslogd。/var/log目录中很多文件都不是由系统日志来维护的。
6、任何以字符$开头的都是扩展。传统的规则包含一个选择器(selector)和一个操作(action)。
7、测试系统日志最简单的方法，使用logger命令手动发送日志消息。
8、大多数系统会使用logrotate或类似的工具来自动清除/var/log中的文件。
9、用户管理文件，用户对于内核而言只是一些数字(用户ID)，用户名只存在于用户空间，使用到用户名的应用程序在和内核通信时，通常要将用户名映射为用户ID。
10、/etc/passwd，将密码存放在shadow文件中(root)，加密的密码，Unix从不明文存储密码。有严格的语法规则，不允许注释和空行。
11、x---密码加密且存在shadow文件；*---用户不能登录；空---登录不需要密码(绝对不要将普通用户的该列设置为空)。
12、注意：用户在/etc/passwd中的对应行及其root目录统称为用户账号。
13、超级用户的UID和GID固定为0.nobody用户的权限最小。无法登录的用户称为伪用户(系统可使用它们运行一些进程，为了安全)。
14、/etc/shadowd，Linux中的影子文件，包含用户验证信息以及经过加密的密码和密码过期日期。后来被PAM替代。
15、普通用户使用passwd更改密码。-f，更该用户名；-s，更该shell。chfn和chsh更改。passwd,是一个suid-root程序，只有超级用户能够编辑/etc/passwd。
16、常使用vipw编辑/etc/passwd文件，它更安全，会在编辑时备份和锁定文件。 -s，编辑/etc/shadow文件。使用超级用户运行passwd user设置用户密码，adduser和userdel添加和删除用户。
17、用户组可将文件访问权设定给某些用户，而其他用户无权访问。多名用户共享一台主机时，用户组很有用。现在很少在主机上共享文件了。
18、Linux通常会为新加入的用户创建一个新的用户组，用户组名和用户名相同。
19、getty和login，getty，仅在虚拟终端上显示登陆提示符，它可用在管道命令中。login，密码正确，会调用shell(exec)。现在用户大都通过图形界面(gdm)或远程登陆(SSH)，这些用不着getty和login。登陆程序的实际验证工作大多是由PAM来完成的。
20、设置时间，Unix系统的运行依赖精准的计时，内核则负责维护系统时钟。date。计算机硬件有一个使用电池的实时时钟(Real-time Clock，RTC)。RTC并不是最精准的，但是聊胜于无。内核启动时使用RTC时间，hwclock将系统时间重设为硬件系统时间。最好将硬件时钟设置为通用协调时(Universal Coordinate Time,UTC),可避免不同时区和夏令时带来的问题。
21、内核在计时方面不如RTC，实际时间(通常由原子时钟等精确时钟来定义)。不要试图使用hwclock来修复时间误差。会影响基于时间的系统事件。运行adjtimex来更新系统时钟。最好的办法是使用守护进程来使系统时间和网络上的时间保持同步。
22、内核时间和时区，以秒为单位的一串数字(自UTC时间1970年1月1日12:00)，用户空间程序将这组数字转换为本地时间，且将夏令时和其他因素都考虑在内。/etc/localtime(二进制)控制本地时区。
23、网络时间，主机连接到互联网，运行网络时间协议(Network Time Protocol,NTP)守护进程，借助远程服务器来更新时间。
24、可使用chronyd守护进程在离线状态下维护系统时间。
25、系统重启，可根据网络时间设置系统的硬件时钟，ntpdate从网络设置时间，然后hwclock --sysohc --utc。
26、cron(定时)服务按日程安排来重复运行程序。可完成很多自动化系统维护工作。通过cron运行的程序称为定时任务。crontab文件中加入一行。
27、格式：分 时 天 月 星期 Command，任意位置出现星号表示匹配所有值。注意：cron任务产生标准输出、错误或者非正常退出，会受到一封邮件通知。可将输出结果重定向到/dev/null或日志文件中。
28、每个用户都可有自己的crontab文件。
29、at进行一次性任务调度。不太常用。
30、更改用户ID，两种方式，均由内核完成。运行setuid程序，通过setuid系统调用。
31、内核负责为进程制定规则，规定哪些能做，哪些不能做。
32、注意：用户切换并不涉及用户名和用户密码。
33、有效UID(effective user id,euid),设定某一进程的访问权限。实际UID(real user ID，ruid)，实际启动进程的UID。
34、运行setuid程序时，Linux将有效UID设置为程序文件的拥有者，同时将实际UID设置为你的UID。
35、有效UID看成是执行者，实际UID看作是所有者。ps默认显示有效UID。Linux系统中大多数进程的有效UID和实际UID是相同的。
36、sleep命令创建一个setuid副本，运行一段时间，然后在期结束前使用ps命令在另一个终端窗口查看它的信息。
37、已保存UID(saved user ID)，文件系统UID(很少用到)
38、sudo和很多其他setuid程序会使用setuid()这样的系统调用来显式地更改有效UID和实际UID。避免一些由于各UID不匹配导致的副作用和权限问题。
39、注意：使用root运行程序可能带来的副作用。
40、setuid为root的程序中的bug也可能会为系统带来风险，攻击Linux系统的常见方式之一就是利用那些以root名义运行的程序的漏洞。
41、防止系统受到攻击最有效的方式之一强制使用用户名和密码进行验证。
42、用户标识(identification)和认证(authentication)，以保证基本的用户安全。用户授权(authorization)用来限定用户的权限。
43、内核对于运行在用户空间中的有关用户认证的相关事宜却一无所知，如用户名和用户密码等。
44、为用户信息使用库，不用使用/etc/passwd，而是使用LDAP网络服务来获得用户名。
45、影子机制，它是建立系统层面的密码配置标准所迈出的第一步。
46、PAM，Sun Microsystems公司，1995年新标准，可插入验证模块(Pluggable Authorization Module)，它是一个共享的验证库。比较溶剂加入新的验证方式和技术，如两段式验证和物理秘钥。提供一些有限的验证控制服务。
47、PAM是基于Unix现有的验证API。配置文件，每一行三个字段：功能类型、控制参数、模块。
48、请求PAM执行以下四类功能：auth、account、session、password。
49、PAM的一个重要特性是它的配置行中使用堆栈定义的规则。控制参数有两类：简单语法(sufficient、requisite、required)和高级语法(使用[]表示，能根据模块的返回值手动定义相应的操作)。
50、注意：required控制参数并不导致PAM立即失败，它还会继续后续的操作，但是最终还是返回验证失败。
51、注意：在讨论PAM时，不要将功能和操作混合起来。用户应用程序首先执行功能，然后PAM负责执行相关操作。
52、PAM模块能够在模块后面带参数。nullok，表示用户不需要密码(如果用户没有密码默认为验证失败)
53、由于其拥有控制流能力和模块参数，PAM配置语法具备了编程语言的某些特征和功能。
54、有时/etc/login.defs中的加密算法必须和PAM配置中的相匹配，以防万一有的应用程序不支持PAM。

第 8 章 进程与资源利用详解
1、计算机硬件资源主要有三种：CPU、内存、I/O。进程为获得这些资源相互竞争，内核则负责公平地分配资源。
2、工具：性能监控。
3、对已运行良好的系统进行优化往往是浪费时间。
4、进程跟踪，top(每秒更新一次信息).atop和htop(lsof)
5、lsof查看打开的文件，列出打开文件以及使用它们的进程。由于Unix大量使用文件，所以lsof在系统排错方面是最有用的命令之一。它可显示常规文件、网络资源、动态库及管道。它输出结果通常信息量很大。
6、运行lsof两种基本方式：输出完整结果，将输出结果通过管道命令less显示，然后在其中搜索想要的内容(耗时)；使用命令行选项来过滤lsof输出结果。-p 
7、注意：lsof和内核信息密切相关。如果升级内核时没有按常规升级系统的其他部分，可能需要升级lsof，如果同时升级了内核和lsof，新的lsof可能需要重新启动新内核以后才能够正常工作。
8、跟踪程序执行和系统调用，strace(系统调用跟踪)和ltace(系统库调用)。
9、strace命令在fork()系统调用之后开始监控新创建的进程(即源程序的副本)。输出一开始几行应该显示execve()的执行情况，随后是内存初始化系统调用brk()。它甚至可用于那些已经和源进程分离的守护进程。
10、ltrace，它不跟踪内核级的内容。记住：共享库调用比系统调用数量多得多。它对静态连接二进制库无效。
11、线程，TID，进程间不共享内存和I/O这样的系统资源。而同一个进程中的所有线程则共享该进程占用的系统资源和一些内存。
12、多线程优势：加快进程的运行速度；线程相对进程启动要快，且线程间通过共享的进程内存来互相通信，比进程间通过网络和管道相互通信更加便捷高效。解决在管理多个I/O资源时遇到的问题。
13、ps和top添加一个m选项。ps查看TID，需要使用自定义的输出格式。
14、注意：通常不会和线程进行交互。top，按H键来显示线程。就资源监控而言，线程可能会带来麻烦，多线程可能同时占用资源。
15、资源监控：CPU时间、内存、磁盘I/O。
16、大部分Linux系统在默认配置下性能都不错。与其使用各种工具来尝试性能优化，不如来看看内核如何在进程之间分配资源。
17、top -p，监控进程,time，查看命令整个执行过程中占CPU时间(user---用户时间、system---系统时间，elapsed---消耗时间)。进程等待系统资源所消耗的时间。
18、更改内核对进程的调度方式，增加或减少安排给进程的CPU时间。优先级(-20(最高)，20)。
19、PR(进程优先级)，内核使用NI值(默认0)来决定进程下一次在什么时间运行。renice设置NI值
20、平衡负载(load average)，准备就绪执行的进程的平均数。也就是某一时刻可以使用CPU的进程数的一个估计值。只有真正在运行的进程才会计入平均负载。
21、uptime，显示三个平均负载值和内核已运行的时长。1分钟，5分钟，15分钟。
22、一般来说美大部分桌面系统的平均负载为0，除非你在编译程序或者玩游戏。平均负载为0通常是一个好迹象，说明CPU不是很忙，系统很省电。
23、注意：目前桌面系统的用户组件比以往占用更多的CPU。如Linux上，Web浏览器的Flash插件可能消耗很多资源。一些蹩脚的Flash应用动辄占用大量的CPU和内存。
24、平均负载为1，完全占用CPU，多核，n
25、高负载，对于Web服务器来说，高平均负载值是正常现象。因为进程启动和结束得很快，以至于平均负载检测机制无法获得有效的数据。
26、如果平均负载值高且系统响应速度很慢，可能意味着内存性能有问题。内核开始执行一个机械性的反复动作，或者说在磁盘和内存间交换进程数据。此时很多进程会处于执行准备就绪状态，但是可能没有足够内存。此时，它们保持准备就绪状态的时间要比平常久一些。
27、查看系统内存状态最简单的方式，free,或查看/proc/meminfo文件来了解系统内存被作为缓存和缓冲区的实际使用情况。
28、内存不足可能会导致性能问题。
29、CPU通过MMU(内存管理单元)将进程使用虚拟地址转换为实际的内存地址。内核帮助MMU把进程使用的内存划分为更小的区域，称为页面。内核负责为维护一个数据结构，称为页面表，其中包含从虚拟页面地址到实际内存地址的映射关系。进程访问内存时，MMU根据此表将进程使用的虚拟地址转换为实际内存地址。
30、进程执行时并不需要立即加载它所有对的内存界面。内核通常在进程需要的时候加载和分配内存页面，称为按需内存分页(on-demand paging或者demand paging)。
31、进程启动过程：内核将程序指令代码的开始部分加载到内存页面中；内核可能还会为新进程分配一些内存页面供其运行使用；进程执行过程中，可能代码中的下一个指令在已加载的内存页面中不存存在，这时内核接管控制，加载需要的内存界面，然后让程序恢复运行；同样地，如果进程需要使用更多的内存，内存接管控制，且获得空闲的内存空间(或腾出一些内存空间)分配给进程。
32、内存页面错误(page default),如果内存页面在进程想使用时没有准备就绪。两种：轻微错误、严重错误。
33、一些严重内存页面错误是不可避免的，如第一次运行某个程序并从磁盘加载代码时。陷入内存不足的状况，且内核开始在内存和磁盘间交换页面，以为新页面腾出空间，这就是比较棘手的情况。
34、查看内存页面错误能够帮助定位出现问题的组件。vmstat(较陈旧，但运行开销最小)监控CPU和内存性能。通常从第二行看起，因为第一行是系统整个运行时期的平均值。
35、建议：《Operating System Concepts，9th edition》，学习内核内存管理方方面知识
36、I/O监控，iostat,默认情况下，它输出结果不包含分区信息。iotop,它是为数不多的显示线程而非进程的工具。ionice查看和更改进程I/O优先级。
37、内核使用调度器等级为I/O调度施加更多的控制。iotop三种等级：be(best-effort)、rt(real-time)、idle(空闲)。
38、pidstat，监控进程。功能强大，针对线程、上下文切换等，
39、高性能的网络服务器对系统资源监控的要求比较高。
40、深入主题：sar(即系统活动报告，System Activity Reporter)；acct(即进程统计)；Quotas(即配额)，将某写系统资源限制给某个进程或用户使用，也可限制用户可以使用的磁盘空间。
41、系统调优尤其是系统性能感兴趣，《Systems Performance：Enterprise and the Cloud》Brendan Gregg(2013)
