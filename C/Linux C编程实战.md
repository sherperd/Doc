前言
1、Linux作为企业服务器，嵌入式应用平台等多方面将占据越来越重的市场份额。
2、Linux内核就是C语言开发。为用户提供了一个强大的编程环境。
3、Linux系统编程、网络编程、图形界面开发。编程规范，及大规模项目开发中必需的autoconf和automake工具。

第 1 篇 Linux和C编程基础
第 1 章 Linux系统概述
1、Red Hat Linux 9 (2008)（个人版）、Red Hat Enterprise Linux 4（企业版）
2、Linux是可以自由传播和，免费使用的类UNIX的操作系统。
3、UNIX，最初由贝尔实验室的Ken Thompson和Dennis Ritchie于1969年研发成功，主要用在大型机和小型计算机上。它价格昂贵，对一般用户而言，可望而不可及。
4、Linux，最早由芬兰赫尔辛基大学的Linus Torvalds的大学生设计。Intel 386，Minix修改。
5、1991年10月，FTP开发源码，11月发布了Linux0.10版本，12月0.11版本，不断改进和完善。
6、Linux具备UNIX的全部特性：多任务、多用户、安全、稳定和高效。
7、Linux经过剪裁后可作为嵌入式操作系统。
8、Linux特性：多用户；多任务；多平台；良好的用户界面；强大的网络功能；安全、稳定、高效；良好的移植性；开放和免费。
9、Linux版本分两类：内核版本和发行版本。内核版本是指Linux的创始人Linus领导的开发小组所开发的操作系统内核的版本号，（主版本号，次版本号，次次版本号）。将Linux内核和常用的应用软件包装起来，并提供安装界面和管理工具，就形成了Linux的发行版本。
10、Red Flag Linux（红旗Linux）是国产的Linux，它是全中文的Linux发行版。
11、C语言最初由贝尔实验室的Dennis Ritchie设计并实现。不仅可以用来开发应用软件，也可用来开发系统软件。它也是Windows操作系统的主要开发语言。
12、C语言特点：两重性；结构化；与Linux紧密结合；可移植性好。
13、Linux把显示器和键盘合成终端，。可对系统进行控制且可用软件的方式来实现，所以又称为虚拟控制台。
14、在终端上，可通过Shell命令来控制和使用计算机。
15、Linux Shell，Shell是一个命令解释器，它通过接受用户输入的命令来启动、暂停、停止程序的运行或对计算机进行控制。halt--关闭计算机。Shell还允许用户编写由Shell命令组成的功能强大的程序。
16、Shell有两种提示符：#和$。选项一般以”-“开头（告诉命令具体做什么）。命令区分大小写。可以用分号连接多个命令，Shell会一次执行。
17、Linux的常用命令，
18、文件是一组被命名的存储在某种介质（如硬盘、光盘、U盘）上的信息的集合。Linux把所有设备当作文件来处理。文件名是文件的标识，它是一个可以包含字母、数字、下划线和句点的字符串。扩展名可用来对文件进行分类。
19、Linux以目录的形式来组织和管理系统中所有的文件。目录是一种特殊的文件，用来管理和组织系统内大量的文件。采用树形目录结构来组织和管理系统的所有文件。登录到Linux或打开一个终端时，会进入一个特殊的目录（主目录”~“）。
20、可使用通配符”*“、”？“来同时引用多个文件。任意多（*），任意一个（？）
21、pwd、cd、ls(-a|l|t|R)、cat(-n|-b|-s|-v)、cp(-r|-f)、rm(-d|-i|-r|-f)、mv(-I|-f)、mkdir(-p)、rmdir(-p)、touch
22、Linux下的开发环境主要有两类：字符界面的开发(vi、vim、Emacs，gcc，gdb，编写Makefile文件来自动编译程序，并使用CVS对项目进行管理)和图形化的集成开发环境(KDevelop，安装KDE桌面系统，很多功能是为开发C++程序、图形界面程序特别是为开发工程项目设计的)。
23、内存中，地址是什么，指针又是什么？
24、CPU、内存、硬盘、总线、输入输出设备是如何协同工作来完成一个程序的执行的？

第 2 章 C编程基础、Vi和Emacs编辑器
1、C语言中并未规定各个数据类型所占内存的字节数，具体如何实现由各计算机系统决定。sizeof。
2、单精度，有效数字是7位，双精度（16位），有效位包含整数、小数两部分。一般在使用中，单精度浮点型即float型已足够，但为了增加有效位数则可以使用double型。%f规定小数点后最多保留6位。
3、转移字符主要用来表示那些用一般字符不变表示的控制代码。
4、字符是以ASCII码的形式存放在内存单元中，而ASCII码实际上是一个整数，因此字符变量可与整型变量进行运算。字符型变量的值实际上是一个8位的数值。其范围-128~127。
5、英文字母其大小写的ASCII码之差是32，可用于转换。
6、字符串常量在内存中存储时，每个字符占用一个字节的内存空间，系统自动在字符串尾部加上一个字符'\0'，以标识这个字符串的结束。
7、常量也可以一个名字，这就是符号常量。好处：使程序更清晰，更可读；程序的修改更方便。
8、运算符，优先级和结合性。
9、注意：在进行强制类型转换时，得到的是一个所需的中间类型，原来变量的类型并未发生变化。
10、C语言本身并不提供输入输出语句，数据的输入输出是由库函数来完成的。
11、字符输出/输入函数putchar()、getchar()。
12、格式化输出/输入函数printf()、scanf()。
13、注意：单精度浮点和双精度浮点都以%f的格式输出。
14、”-“输出左对齐，默认右对齐。dd，指定输出的参数所占的最小宽度。dd.dd
15、设计软件时必须考虑对错误输入的处理。
16、Vi（visual interface），Linux上主要的文本编辑软件。文本输入、删除、查找、替换、快操作等。熟练后，vi是一个简单易用且强大功能的源程序编辑器。
17、vi工作模式：命令模式（Command Mode）、插入模式（Insert Mode）、末行模式（Last Line Mode）
18、命令模式，shell中启动vi时，最初进入的模式。光标移动，字符、字、行的删除，复制，粘贴等操作。
19、末行模式，保存文件、退出、查找字符串、文本替换、显示行号等。一条命令执行完毕，就会返回命令模式。
20、行号并不是文件内容的一部分。
21、光标的移动，插入模式下，一般只有键盘上的4个方向键来移动光标。在命令行模式下则有很多移动光标的方法。0-移动到当前行的行首；$-移动到当前行行尾；
22、遇到“.”、“？”、“！”，Vi认为是一句的结束。Vi空白行来作为段的开始或结束。
23、文本删除，x-一个字符，dw-一个字，db-光标前一个字，d0-光标前到行首的所有字符，d$-，dd-当前行，d(-当前到句首，d{-当前到段首。
24、提示：如果要取消前一次的操作，在命令模式下输入字符u即可，u是undo的首字母。
25、文本查找和替换，?string<Enter>，n-向文件头，N-文件尾；:s/oldstr/newstr(s是subsitue)，:s/oldstr/newstr/g(当前行所有)，:1，10s/oldstr/newstr/g(1~10行)，:1，$s/oldstr/newstr/g(整个文件)。
26、文件的复制和粘贴，yw-字(y是yank的首字母)，nyw，yb，y0-光标前一个字到行首，yy-当前行，nyy，p-后面，P-前面，np，nP。
27、Emacs编辑器使用，显著特点：可以使用鼠标进行大部分操作。标签，编辑比较大的文件时，设置一些标签可以很方便文件的操作。
28、命名规范，
29、标识符就是一个名字。C语言规定，标识符的第一个字符必须是字母或下划线，不能以数字开头。C语言不限制标识符的长度，但它受各种C语言编译器的限制，同时也受到具体机器的限制。
30、有些编译器中规定标识符前8位有效。建议变量名的长度最好不要超过8个字符。
31、关键字是由C语言规定的具有特定意义的字符串，通常也称为保留字。关键字分类：类型说明符、语句定义符、预处理命令字。
32、必须要养成良好的编程习惯。可增强程序代码的可读性。编程风格最能体现一个程序员的综合素质。
33、在Windows下开发软件，许多人采用匈牙利命名法，而在Linux环境，并不建议使用这种方法。
34、Linux建议的命名规则：变量名必须有一定的意义，并且意义准确；不建议大小写混用；在失去意义的情况下，尽量使用较短的变量名；不采用匈牙利命名法表示变量的类型；函数名应以动词开头；尽量避免使用全局变量。

第 3 章 C语言程序控制机构和gcc编译器
1、注意：在实际开发中，空语句应该加上注释，以便让阅读代码者知道该语句是有意使用的，而不是疏忽或是错误。
2、程序设计语言的发展过程中，Bohra和Jacopini已经证明使用顺序、选择、循环3种基本结构可以表达任何计算机能够解决的问题的处理流程。
3、关系运算符的优先级低于算术运算符，但高于赋值运算符。
4、逻辑与和逻辑或运算符优先级低于关系运算符。
5、惰性求值规则，条件表达式。
6、注意：switch表达式所计算的结果必须为整型，常量表达式也必须是整型数值，且不能为变量。
7、注意：在循环体中定义的变量在每次循环里都要经历重新定义和销毁变量的过程。
8、注意：do...while语句后面有一个分号，而while语句没有。
9、for语句是C语言中最灵活、功能最强也是使用得最多的循环语句。
10、注意：for语句中表达式1只执行1次。
11、gcc编译器（GNU Compiler Collection），它是GNU项目中符合ANSI C标准的编译器，能够编译用C、C++语言编写的程序。gcc不仅功能非常强大，结构也非常灵活。此外，还以编译Java、Fortran、Pascal和Ada等语言编写的程序。且支持和各种不同的硬件平台。同时可运行在不同的操作系统。
12、Linux下开发应用程序，大多数情况下使用的都是C语言，因此几乎每一位Linux程序员都必须掌握和灵活使用一种C编译器。
13、gcc支持的体系结构有几十种之多，Intel x86系列、Arm、PowerPc等。既支持基于宿主的开发（也就是要为某平台编写的程序），也支持交叉编译。
14、编译过程分4个阶段：预处理（Pre-Processing）、编译（Compiling）、汇编(Assembling)、链接（Linking）。
15、-E，生成中间文件(*.i);   -S,编译（*.s） -c，汇编（*.o）
16、gcc编译器的选项有100多个，其中很多参数一般是用不到的。-g(产生调试器gdb所必需的符号信息)。-O（优化）。-Wall(输出警告信息)； -w(关闭所有警告，建议不要使用此选项)；-Idirname（将目录加入到程序头文件目录列表中）。
17、系统预设包含文件目录（如/usr/incude）。在编写大型程序时，往往将头文件单独放在一个目录中。-Ldirname，将目录加入到程序的库文件搜索目录。
18、库是事先已经编写好的代码，经过编译后可直接调用的文件。默认情况，gcc在系统默认路径(/usr/lib)寻找所需要的库文件。-lname,在链接时，装载名为*的库，
19、gcc错误信息：C语法错误（syntex error）；头文件或库未按错误；未定义错误（链接过程中出现）；
20、不可将浮点变量用“==”或“!=”与数字比较，应该设法转换成“>=”或"<="之类的形式。
        （x >= -0.00001） && (x <= 0.00001)
21、对于一个实际问题，首先要对这个问题进行分析并把它转化为计算机可以理解的形式。考虑使用什么算法来描述解决问题的思路和程序的执行流程。
22、穷举算法逐一尝试每一个可能的解，直到问题的解惑尝试完所有可能的解为止。改进，如不去尝试那些明显不可能的候选解或者只尝试最有可能的那部分解。

第 4 章 C函数、数组、指针和调试器gdb
1、每个模块完成一个特定的功能。
2、C语言，函数名是一个标识符，它不能与其他函数同名，否则在调用时，系统不知道该调用哪一个。C++函数允许重名。
3、若定义一个函数时，没有明确指明返回类型，Linux上最常用的编译器gcc默认返回类型为int。
4、注意：一个函数的各个参数不可以重名，函数体内定义的变量也不可以与参数重名。
5、注意：函数体内定义的变量随着函数被调用而分配内存空间，函数调用结束存储函数体为定义变量的内存空间即被回收，函数可以返回一个指针但不可以返回一个数组。
6、C语言使用调用操作数（即一对圆括号）实现函数的调用。调用操作符需要操作数并产生一个结果。
7、main函数通过向操作系统返回一个数以报告它的执行情况，通常返回0表示程序正常结束，但操作系统一般忽略main函数的返回值。
8、定义是对函数功能的确立，包括指定函数名、返回类型、形参及其类型、函数体。声明仅仅告知编译器gcc，程序中有这么一个函数。
9、注意：函数可以嵌套调用但不可以前导定义。
10、递归调用：在调用一个函数过程中又出现直接或间接地调用该函数本身。是一种很有用的编程技巧。可使用递归调用来实现循环。要保证递归调用到一定条件将不会继续递归下去而是返回一个值。
11、对于某些问题，得到可行解或近似解就可以了而不一定得到最优解。
12、将一个规模较大的复杂问题通过某种方法转化为规模较小的简单问题。
13、变量的访问控制和存储类别。局部变量（函数内部定义，形式参数）和全局变量。静态存储（函数内定义的static变量、全局变量）和动态存储。
14、作用域可嵌套。
15、全局变量可在两个不相关的函数间建立联系，但这违反模块化编程准则，建议做好少用全局变量。
16、静态变量在函数调用结束后并不会销毁。编译时系统为全局变量在静态存储域分配内存空间。
17、在一个文件中如果要在全局变量的定义前使用该变量（原则上是不可以的），但使用extern关键字提前声明全局变量就可以了（声明仅仅是告诉编译器程序存在这个变量，这个变量不是未定义的，不需要分配内存，而定义则要分配内存空间以及存储变量的值）。
18、规模较大的程序往往由多个文件构成，如果一个文件中的程序代码要使用另一个文件内定义的全局变量，就要使用extern对该全局变量进行声明。
19、C语言提供3种复合数据类型：数组、结构体、共用体。复合数据类型是由基本类型按照一定的规则构造而成。
20、数组中元素的个数，它必须是常量表达式。
21、C语言规定，只能引用数组的一个元素不能一次引用整个数组。
22、注意：所有在函数体外定义的数组的所有元素将被自动赋予初值0，在函数内部定义的数组，系统不会为其进行初始化，在使用数组元素前必须先对元素进行初始化。
23、字符数组，是类型为char的一维数组。在实际项目开发中用的比较多。
24、在C语言中，字符串是用字符数组来存储的。为了测定一个字符串长度，C语言用字符‘\0’来代表一个字符串的结束。
25、系统自动为字符常量增加一个字符'\0'作为结束符。字符'\0'代表ASCII码为0的字符，该字符是一个不可打印的字符，它只是一个空操作符，起一个标志的作用。
26、注意：在实际编程中，在定义字符数组时应估计实际字符串的长度，保证数组长度始终大于字符串的长度。另外，编程中应时刻记着检查要存储的字符串的长度是否超过了字符数组的长度，否则很容易导致缓冲区溢出。现在网络上大部分的安全漏洞都与缓冲区溢出有关，许多病毒利用缓冲区漏洞进行攻击，造成极大的危害。
27、指针，难点：即使有丰富编程经验的程序员有时在调试有指针使用错误的程序时也感到困惑。
28、对于程序中的每一个变量，在编译程序时都要分配一块内存存储该变量的值。内存中每一个字节都有一个编号（内存的地址）。
29、C语言中的指针是专门用来存放内存地址的变量。每个指针都有一个与之关联的数据类型，该类型决定了指针所指向的变量的类型。C语言使用*把一个标识符声明为指针。
30、注意:使用未初始化的指针通常会导致错误，应该绝对避免使用未初始化的指针。在定义指针时最好将它初始化为null，即明确指示当前该指针不指向任何变量。
31、数组名实际上就是指向数组第一个元素的指针。在指向数组某个元素的指针加上一个整型数值，就可以指向另外一个数组元素（前提没有超出数组的范围）。
32、注意：在指针上进行加减运算后所得到的指针，必须指向同一个数组或指向数组存储空间的下一个单元（但不能对该变量执行*p1运算）。
33、注意：不能对数组名执行++、--操作，因为a是数组名，它是数组的首地址，它的值在程序的运行过程中是固定不变的，是常量。
34、数组元素也可以是指针类型，这种数组称为指针数组。
35、注意：区别int(*p)[5]和int*p[5]，前者是一个指针，它指向一个含有5个元素的数组，后者是一个数组，它的长度为5，数组中每一个元素指向一个整型变量。
36、指针参数，作用是将一个变量的地址传送到一个函数中。参数为指针，所以必须传递一个变量地址。对于指针型形参，实参也可以是NULL，因此函数中必须检查p是否为NULL。
37、注意：如果一个函数的参数中有指针，那么处于程序的健壮性的考虑，在该函数中须检查参数是否为NULL。
38、指向函数的指针是一个指针变量，这个指针比较特殊，它指向一个函数。一个函数的函数名是一个指针，它指向函数的代码。函数的调用可以通过函数名来调用也可通过指向函数的指针来调用。
39、指向函数的指针也称为函数指针。不能对指向函数的指针做任何运算。
40、注意：区别，前者是返回指针的函数，它是一个函数的声明。后者是指向函数的指针，它定义一个指针。
41、在函数内可通过该指针调用其他函数。信号处理时会使用这种技术。
42、返回函数指针的函数，实际项目中用的很少，一般只出现在知名公司的笔试面试中。
43、用字符数组存放一个字符串；用字符串指针来指向字符串。
44、C语言对于字符串常量通常是这样处理的：在内存中开辟一个字符数组来存储该字符串变量，并把开辟的字符数组的首地址赋给p。p指向的是字符串常量，常量的内容不可改变。p指向字符串常量或字符数组是合法的。
45、注意：数组，数组名是指向数组第一个元素的指针，它的值不可以被改变。而在函数定义中，数组名也是一个指针，但它的值可以改变，它可以指向其他字符变量。
46、字符数组由若干元素组成，每个元素存放一个字符。而字符串指针中存放的是地址（字符串的首地址），而不是将字符串存放到字符串指针中。
47、字符串函数，puts和gets、strcpy和strncpy（复制时连同字符串的'\0'一起复制）、strcat和ctrncat（覆盖dest结尾处的'\0'）、strcmp和strncmp、strlen（不包括'\0'）、strlwr和strupr、strstr和strchr（找字符串或字符第一次出现的位置）
48、不能将一个字符串常量或字符数组直接赋给另一个字符数组。strcpy是不安全的，存在安全漏洞，容易被黑客所利用。
49、sizeof获取所指向的字符串的长度，字符串最后的‘\0’也是一个字符。
50、catenate，
51、调试器gdb，
52、在Linux应用开发中，最常用的调试器是gdb。gdb和其他调试器一样，可以在程序中设置断点、查看变量值、一步一步地跟踪程序的执行过程。
53、gdb调试的对象是可执行文件，而不是程序的源代码。如果要使一个可执行文件可以被gdb调试，在编译器gcc编译程序时需要加入-g选项。-g告诉gcc在编译程序时加入调试信息，这样gdb才可以调试这个被编译的程序。
54、Mac中现在使用的是gdb的升级版lldb.
55、注意：如果要使gdb启动时不输出版权说明，可在执行时加上-q选项。
56、list命令用于列出程序的源代码。
57、注意：如果在调试过程中要运行Linux命令，则可以在gdb的提示符下输入shell命令。
58、run，使程序开始运行。断点使程序运行到某个位置时暂停下来，以便检查和分析程序。
59、断点在调试程序时非常有用，因此学习设置和管理断点是非常必要的。
60、以行号设置断点，
61、在gdb中，大部分是使用break命令为程序设置断点。最好用的是为某行设置断点。
62、注意：gdb的命令可以简写，如list用li，continue用cont。
63、学习是一个循序渐进的过程，随着对C语言的接触日益增多，慢慢地就会完全理解。
64、全局静态变量对其他文件是不可见的。而局部静态变量只在定义它的函数内有效。static的用途：限制变量的作用域；设置变量的存储域。
65、静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数使用，因此可以避免其他源文件使用该变量。
66、注意：在程序中malloc函数与free函数须成对出现。使用malloc分配了一块内存，使用完毕后必须使用free函数将其释放。

第 5 章 C语言预处理、结构体和make的使用
1、在C语言源程序中加入一些编译预处理命令可以提高编程效率，加快编译速度。
2、预处理命令是在编译源程序前先对源程序进行处理。
3、注意：预处理命令并不是C语言的一部分，因此每条预处理命令不需要以分号来结束。
4、用一个标识符来表示一个字符串，称为宏。宏替换，在编译预处理时，将程序中所有的宏名用相应的字符串来替换。
5、无参宏和有参宏。“#”代表本行是编译预处理命令。define是宏定义的关键字，标识符是宏名。字符串是宏名所替换的内容，可以是常数、表达式等。
6、注意：宏定义和其他编译预处理命令不是以分号结尾的。
7、宏定义允许嵌套。宏的作用是从宏定义开始到本程序文件结束为止。
8、有参数宏的形式参数不是变量，不分配内存，无需说明数据类型。
9、文件包含，#include，它把指定源文件的全部内容包括到当前源程序文件中。
10、尖括号只在缺省目录（是由用户设置的编程环境决定的）里找指定文件。双引号则先在源程序文件所在目录里查找指定文件，如果找不到再到缺省目录里找。
11、条件编译，可减少被编译的语句，从而减少可执行程序的长度，缩短程序运行时间。
12、注意：声明结构体也是一个C语言语句，因此要以分号作为该语句的结束。
13、“.”是成员运算符，用于取得结构体中的成员，它在所有运算符中优先级最高。
14、注意：只能引用结构体变量中的各个成员，而不能引用整个结构体变量。
15、在C语言中，为了方便使用和直观，把(*p).number改为p->number。
16、共用体中的变量共享一块内存。
17、编译器处于提高访问效率的目的，在编译分配存储空间时往往要进行对其操作。
18、不能把共用体变量作为函数参数，也不能使函数返回共用体变量，但可以使用指向共用体变量的指针。
19、typedef声明新类型名来替代已有的类型名。typedef只是为某种类型声明一个别名，和声明数据类型一样。实际项目开发中，往往使用typeof为某种已存在的数据类型声明一个别名，使用该别名定义的变量往往有特殊用途，可增加程序的可读性和可维护性。
20、C语言是一种适合编写系统程序的语言。
21、右移，移入0的称为逻辑右移，移入1的称为算术右移。
22、位域，C语言允许在一个结构体中以位为单位来使用内存，以位为单位的成员称为位域或位段。
23、Linux环境下的大型项目开发中，通常把整个系统划分为若干模块，每个模块完成某一相对独立的功能，各个模块相互作用以构成一个完整地系统。
24、Linux一个用来维护程序模块关系和生成可执行程序的工具---make。需要Makefile或makefile文本文件（定义整个项目的编译规则。定义了模块间的依赖关系，指定文件的编译顺序，以及编译所使用的命令）
25、make从Makefile文件中获取模块间的依赖关系，判断哪些文件过时了，确定哪些文件需要重新编译，然后编译。
26、Makefile文件的基本单元是规则。
27、通常make把Makefile文件的第一个规则的目标作为最终目标文件。
28、Makefile构成：显示规则、隐含规则、使用变量、文件指示和注释。
29、规则的主要思想：目标文件的内容由依赖文件决定，依赖文件的任何一处改动，将导致目前已经存在的目标文件过时。规则的命令为重新生成目标文件提供了方法。这些命令都是shell命令。
30、缺省属性：命令执行遇到错误就退出make。命令行属性：-，执行本命令行的命令时如遇错误，就绪执行不退出make。+，本行命令始终被执行。@，执行命令时不在屏幕上打印命令的内容。
31、将一个目标声明为伪目标的方法是将它作为特殊目标”.PHONY“的依赖。
32、make不会试图去查找该目标的依赖文件。
33、搜索目录，make可识别一个特殊的变量”VPATH“。
34、变量值是一个文本字符串。区分大小写。
35、”=“赋值的变量是递归展开变量，通过”:=“赋值的变量是立即展开变量。”?=“条件赋值，只有此变量在之前没有赋值的情况下才会对这个变量进行赋值。
36、好处：在变量未定义时就可以使用变量。可能造成死循环。
37、自动变量，$@（指代目标文件）、$%（静态库的成员）、$<（第一个依赖文件名）、$>（）
38、Linux中，一般称.a文件为文档文件，也称静态库文件。
39、注意：自动变量只能用在规则的命令中，不能出现在规则的目标文件列表或依赖文件列表。
40、为了简化Makefile的编写，make命令在实现时内嵌了隐含规则。
41、可通过改变预定义变量的值来改变隐含规则。
42、使用库可以大大节省空间，所以系统提供的标准函数一般都是以库的形式提供。
43、静态库也称文档文件，它是以.o为结尾的文件，使用ar命令对它进行维护和管理。
44、频繁使用的短小函数，C语言做好用宏定义实现。节省调用函数的开销，效率最高。
45、1000(2)-1(2)=0111(2)，正好是原数取反，用这种方法来求1的个数是高效率的。
46、谭浩强《C语言程序设计》、Ritchie《C程序设计语言》（经典）、David《C语言教程：模块化程序设计》
gcc使用手册、gdb中文使用手册、make中文使用手册。
47、卡耐基大学Randal E.Bryant和David O.Hallarom教授的《深入理解计算机系统》，它详细分析了程序是如何生成和执行的，从程序员的角度深入探究了计算机系统的内部工作原理。

第 二 篇 Linux系统编程
第 6 章 文件操作
1、Linux系统编程是指程序员使用系统调用或C语言本身所携带的库函数来设计和编写具有某一特定功能的程序。shell命令是操作系统提供给普通用户使用的接口。
2、应用程序只需要包含相应的头文件就可以使用这些函数。以函数库的方式提供。编译程序时，gcc会自动链接一些常用的库。或指定库
3、shell命令下输入man命令来查看函数原型。
4、Linux的文件结构，
5、Linux，安全的操作系统，它是以文件为基础而设计的。
6、目录也是一种文件，称为目录文件。内容是该目录的目录项，目录项是该目录下的文件和目录的相关信息。
7、创建一个目录时，系统自动创建两个目录项：.和..
8、操作系统通过文件系统可以方便地对磁盘上的文件进行管理。
9、对设备驱动的访问两种途径：通过设备驱动本身提供给的接口（绕过文件系统直接读写磁盘，不稳定）；通过虚拟文件系统（VFS）提供给上层应用程序的接口。
10、VFS是虚拟的，不存在的，都是只存在于内存而不存在于磁盘之中的，即只有在系统运行起来以后才在。
11、Linux文件系统支持多种不同的文件系统。EXT2、EXT3.windows（vfat）
12、硬盘，最小单位一个盘面上的一个磁道上的一个扇区，文件系统是由一系列块（block）构成的，每个块的大小因不同的文件系统而不同。但一个文件系统一旦安装完成，块的大小就固定了。通常一个块的大小是一个扇区的大小，而一个扇区通常为512字节。
13、Linux文件的分类：普通文件、目录文件、字符特殊文件、块特殊文件、FIFO（用于进程间的通信，也称命名管道）、套接字（网络通信）、符号链接（指向另一个文件，是另一个文件的引用）。
14、对一个目录具有读许可权的任一进程都可以读该目录的内容，但只有内核可以写目录。
15、程序中查看文件的类型则需要使用stat/fstat/lstat函数族。
16、Linux是一个安全的操作系统，说它安全，很重要的一个原因是对用户访问权限的控制。
17、chmod修改对文件访问权限。r=4，w=2，x=1；程序设计时，可通过chmod/fchmod函数对文件访问权限进行修改。
18、在编写跨平台程序时，最好使用C语言的标准库函数（fopen、fread等）以方便移植，因create、open等系统调用使用文件描述符来标识文件，而文件描述符是UNIX/Linux特有的，不方便移植。
19、对内核而言，所有打开的文件都由文件描述符标识（非负整数，取值在0~NR_OPEN之间）。Linux中NR_OPEN为255，也就是说每个程序最多只能打开256个文件。
20、文件描述符0代表标准输入文件（键盘），文件描述符1代表标准输出文件（显示器），文件描述符2代表标准错误输出（显示器）。
21、当且仅当第二参数使用了O_CREATE时，需要使用第三个参数mode，以说明新文件的存取权限。
22、新文件的实际存取权限是mode与umask按照（mode &~ umask）运算以后的结果。
23、注意：creat只能以只写的方式打开创建的文件，creat无法创建设备文件，设备文件的创建要使用mknod函数。
24、creat()相当于这样使用open()，open(const char *pathname, (O_CREATE | O_WRONGLY | O_TRUNC))。
25、注意：close函数调用成功时并不保证数据能全部写会硬盘。
26、进程结束时，内核会自动关闭所有已打开的文件，建议在程序中显式地调用close函数。
27、read函数，返回值表示实际读取到的字节数，如果返回0，表示已到文件尾或是无可读取得数据，此外文件读写指针会随读取到的字节移动。
28、lseek允许文件指针的值设置到文件结束符（EOF）之后，但这样做并不改变文件的大小。常用：将文件读写指针移到文件开头；将文件读写指针移动到文件结尾；获取文件读写指针的当前位置。
29、注意：有些设备（或说是设备文件）不能使用lseek。Linux系统不允许lseek()对tty设备进行操作，此项操作会使lseek返回错误代码ESPIPE。
30、dup和dup2系统调用都可以用来复制文件描述符。复制成功，返回最小的尚未被使用的文件描述符。指向同一个文件，共享所有锁定、读写指针和各项权限或标志位。dup2，可指定newfd数值，若newfd已经被程序使用，系统就会将其关闭，以释放该文件描述符。
31、shell中的重定向功能就是通过dup和dup2函数对标准输入和标准输出的操作来实现。
32、fcntl函数，用来对已打开的文件描述符进行各种控制操作以改变已打开文件的各种属性。
33、文件记录锁，提供非常详细的控制，它能对文件的某一区域进行文件记录锁的控制。一个进程只能设置某一文件区域上的一种锁。旧的锁会被新的锁取代。
34、当进程结束或文件描述符fd被close系统调用时，锁会自动释放。
35、Linux系统的文件记录锁默认是建议性的。强制性锁机制中，内核对每一个open、read和write都要检查调用进程对正在存取的文件是否违背了某一把锁的作用。
36、单个进程在同一字节上只能设置一种锁，新的锁会取代旧的锁。锁的不兼容规则是针对于多个进程之间的。
37、ioctl函数，通常用来控制设备，控制特殊设备文件的属性。参数request决定了参数argp是向ioctl传递数据还是从ioctl获取数据。
38、程序中获取文件属性，stat/fstat/lstat(返回是符号链接文件本身的状态信息)函数。对于符号链接文件，stat返回的是符号链接指向的文件状态信息。文件大小，以字节计算；对符号链接，该大小是其所指向的文件名的长度。
39、若某一目录具有sticky位(S_ISVTX)，则表示在此目录下的文件只能被该文件所有者、此目录所有者或者root来删除或改名。
40、struct stat结构，常用：st_mode、st_uid、st_gid、st_size、st_atime、st_mtime.
41、设置文件属性：chmod/fchmod，修该文件的存取权限；chown/fchown/lchown，修该文件的用户id和组id。truncate/ftruncate,修改文件的大小；utime，改变任何文件的st_mtime域和st_ctime域，即存取时间和修改时间；umask，设置文件创建时使用的屏蔽字，并返回以前的值。
42、文件的所有者只能改变文件的组id为其所属组中的一个，超级用户才能修改文件的所有者id，任意修改文件的用户组id。如果参数指定为-1，文件的用户id和组id不会被改变。
43、注意：chown系统调用会清楚set-uid位和set_gid位（清除S_ISUID和S_ISGID）.
44、rename可用来修改文件名或文件位置。如果文件已存在，则原文件会被删除。
45、文件删除使用unlink，目录文件的删除使用rmdir系统调用。通用remove（封装前两者）
46、mkdir创建一个新的空目录。空目录中会自动创建.和..目录项。所创建的目录的存取许可权由mode（mode&~umask）指定。
47、注意：mkdir只能删除由参数pathname指定的空目录。
48、每个进程（可以理解为运行中的程序）都有一个当前目录，此目录是搜索所有相对路径名的起点（不以斜线开始的路径名为相对路径）。
49、当前工作目录是进程的一个属性。getcwd，将当前的工作目录绝对路径复制到参数buf所指的内存空间。
50、chidir，运行后并不能如cd命令一样进行目录的切换。因为chdir只影响调用该函数的进程，对其他进程，如其父进程的当前工作目录，则修改不了。这也是cd命令作为少数几个Shell内置命令的原因。
51、只要对目录具有读权限，就可以获取目录信息。

第 7 章 进程控制
1、OS的主要任务是管理计算机的软、硬件资源。现代OS的主要特点在于程序的并行执行，LinuxOS亦是如此。OS借助于进程来管理计算机的软、硬件资源，支持多任务的并行执行。OS最核心的概念就是进程。
2、Linux是一个多用户多任务的OS。
3、进程简单的讲就是运行中的程序，Linux系统的一个重要特点是可以同时启动多个进程。进程是OS资源管理的最小单元。
4、进程是一个动态的实体，是程序的一次执行过程。进程是动态的，而程序是静态的；
5、为了让计算机在同一时间内能执行更多任务，在进程内部又划分了许多线程。线程是比进程更小的能独立运行的基本单位。线程基本上不拥有系统资源，它与同属一个进程的其他线程共享进程拥有的全部资源。
6、Linux下通过命令ps或pstree查看当前系统中的进程。
7、LinuxOS中，每个进程都是通过唯一的进程ID标识的。进程ID是一个非负数。
8、Linux进程的结构：代码段、数据段、堆栈段。
9、Linux进程的状态：运行(R)、可中断等待(S)、不可中断等待(D,uninterruptible sleep)、僵死(Z,zombile)、停止(T,traced or stopped)。
10、ps -eo pid stat     后缀符，意义：<（高优先级进程），N（低优先级），L（内存锁页，即页不可以被换出存），s（该进程为会话首进程），I（多线程进程），+（进程位于前台进程组）。
11、程序转化为进程通常步骤：内核将程序读入内存，为程序分配内存空间；内核为该进程分配进程标识符（PID）和其他所需资源；内核为该进程保存PID及相应的状态信息，把进程放到运行队列中等待执行，程序转化为进程后就可以被操作系统的调度程序调度执行了。
12、进程的内存映象是指内核在内存中如何存放执行可执行程序文件。
13、从内存的低地址到高地址，代码段、数据段、未初始化数据段、堆、栈。高地址还存储了命令行参数和环境变量。
14、创建进程的两种方式，一是由操作系统创建；二是由父进程创建。
15、子进程又可创建进程，这样形成一个进程家族。子进程可以继承其父进程几乎所有的资源。
16、系统调用fork是创建一个新进程的唯一方法（创建一个进程通常也称为fork一个进程），除了极少数以特殊方式创建的进程，如init进程，它是内核启动时以特殊方式创建的。
17、创建一个子进程后，父进程和子进程争夺CPU，抢到CPU者执行，另一个挂起等待。几个进程同时执行一个应用程序通常用处不大，更常见的使用方法是子进程在被fork后可以通过调用exec函数执行其他程序。
18、fork函数非常特殊，它有两个返回值，即调用一次返回两次（前提，进程创建成功，创建失败，只返回-1）。两次返回的值不同，子进程返回0，而父进程的返回值为新创建的子进程的进程ID。
19、创建进程失败的原因，通常是父进程拥有的子进程的个数超过了规定的限制，此时errno值为EAGAIN，内存不足（ENOMEM）。
20、孤儿进程由init进程收养。
21、vfork，调用一次，返回两次；创建的子进程共吸纳过父进程的地址空间，也就是说子进程完全运行在父进程的地址空间上，子进程对该地址空间中任何数据的修改同样为父进程所见；vfork保证子进程先运行。vfork不会拷贝父进程的地址空间（减少了系统开销）。
22、fork创建一个子进程时，子进程只是完全复制父进程的资源（开销很大的系统调用）。这样得要的子进程独立于父进程，具有良好的并发性。哪个进程先运行取决于系统的调度算法。
23、注意：使用vfork时要谨慎，最好不要允许子进程修改父进程共享的全局变量和局部变量。
24、守护进程（daemon）是指在后台运行的、没有控制终端与之相连的进程。通常周期性的执行某种任务。
25、守护进程的启动方式：在Linux系统启动时从启动脚本/etc/rc.d中启动；可由规划进程crond启动；还可由用户终端执行。
26、编写创建守护进程时，尽量避免产生不必要的交互。编写要点：让进程在后台执行（调用fork产生一个子进程，然后使父进程退出）；调用setid创建一个新对话期；禁止进程重新打开控制终端；关闭不再需要的文件描述符；将当前目录更改为根目录；将文件创建时使用的屏蔽字设置为0；处理SIGCHILD信号。
27、控制终端、登录会话和进程组通常是从父进程继承下来，守护进程要摆脱它们，不受它们影响，方法是调用setid使进程成为一个会话组长。
28、父子进程终止的先后顺序不同会产生不同的结果。
29、注意：exec调用并没有生成新进程。唯一保留的是进程ID。
30、环境变量，包括用户的主目录，终端类型、当前目录等，它们定义了用户的工作环境。env命令查看环境变量值。
31、execv，通过路径名方式调用可执行文件作为新的进程映象。
32、execve、execl、execle（要显式指定环境变量）、execvp、execlp
33、注意：参数argv和参数envp的大小是受限制的。Linux操作系统通过宏ARG_MAX来限制它们的大小（和）。
34、exec函数族只有execve是系统调用。其它5个都是库函数。
35、Shell脚本必须以所示的格式开头，第一行必须为#!interpretername[arg]，interpretername可以是Shellhuo其它解释器。arg是传递给解释器的参数。
36、waitpid提供一个wait的非阻塞版本。WNOHANG
37、只有超级用户进程才能更改实际用户ID。
38、su命令却能使一个普通用户变成特权用户。su是一个”set_uid“程序。su程序的文件属主是root
39、执行一个设置了set_uid位的程序时，内核将进程的有效用户ID设置为文件属主的ID。而内核检查一个进程是否具有访问某文件的权限时，是使用进程的有效用户ID来进行检查的。
40、nice系统调用是getpriority和setpriority函数的组合形式。

第 8 章 线程控制
1、线程是计算机中独立运行的最小单位，运行时占用很少的系统资源。看成OS分配CPU时间的基本单位。
2、优点：同一进程内的线程共享进程的地址空间；线程的切换速度要远快过进程的切换速度；线程间的通信更加方便和省时。提高应用程序的响应速度；可以提高多处理器效率（发挥硬件的潜力）；可以改善程序的结构。
3、Linux支持POSIX多线程接口，称为pthread（Posix Thread）。需要头文件pthread.h，链接时需要使用libpthread.a。
4、线程函数，pthread_once,函数执行次数要被限制为一次。
5、pthread_attr_t结构体，指明待创建线程的属性。
6、函数执行次数要被限制为一次，这种情况下使用pthread_once函数。
7、线程终止，一种是通过return从线程函数返回，二是用函数pthread_exit()使线程退出。
8、线程终止读入最重要问题是资源释放的问题，特别是临界资源（被线程独占）。死锁（灾难性的）
9、pthread_join用来等待一个线程的结束。
10、注意：在主线程中不能过早地从main函数返回。
11、pthread_cleanup_push()、pthread_cleanup_pop()用于自动释放资源。这两个函数必须成对出现，且必须位于程序的同一代码段中才能通过编译。
12、线程终止时的另一个要注意的问题是线程同步的问题。
13、终止的线程所占用的资源不会随着线程的终止而归还系统，而是仍为线程所在的进程持有。
14、处于DETACHED状态的线程无法由pthread_join()同步。
15、一个可“join”的线程所占用的内存仅当有线程对其执行了pthread_join()后才会释放，因此为了避免内存泄露，所有线程的终止时，要么已被设为DETACHED，要么使用pthread_join()来回收资源。
16、注意：一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，其余调用pthread_join()的线程返回错误代码ESRCH。
17、进程内的所有线程共享进程的数据空间，因此全局变量为所有线程共有。
18、创建线程的私有数据（Thread-specific Data，或TSD），线程私有数据可被各个函数访问，但对其他线程是屏蔽的。
19、线程私有数据采用了一种被称为一键多值的技术，即一个键对应对个数值。首先要为每个线程数据创建一个关联的键。操作线程私有数据的函数有4个,pthread_key_create(创建一个键)，pthread_setspecific(为一个键设置线程私有数据), pthread_getspecific(从一个键读取线程私有数据)，pthread_key_delete(s删除一个键)
20、Linux的TSD池，.创建一个TSD就相当于将结构数组中的某一项设置为“in_use”,并将其索引返回给*key，然后设置destructor函数为destr_function。
21、key一旦被创建，所有线程都可访问它，但各线程可根据自己的需要往key中填入不同的值，这就相当于提供了一个同名不同值的全局变量。一键多值靠的是一个关键数据结构数组，即TSD池。
22、注意：线程数据的释放必须在释放键之前完成。
23、线程最大的特点就是资源共享性，然而资源共享中的同步问题是多线程编程的难点。
24、线程同步，互斥锁、条件变量和异步信号。
25、互斥锁通过锁机制来实现线程间的同步。在同一时刻它通常只允许一个线程执行一个关键部分代码。使用互斥锁前必须先进行初始化操作。初始化两种方式：一种是静态赋值法，将宏结构常量PTHREAD_MUTEX_INITIALIZER赋给互斥锁；另一种是通过pthread_mutex_init函数初始化互斥锁。
26、互斥锁属性：PTHREAD_MUTEX_TIMED_NP(普通锁),PTHREAD_MUTEX_RECURSIVE_NP(嵌套锁)，PTHREAD_MUTEX_ERRORCHECK_NP(检错锁)，PTHREAD_MUTEX_ADAPTIVE_NP(适应锁)。
27、注意：加锁时，不论哪种类型的锁，都不可能被两个不同的线程同时得到，其中一个必须等待解锁。在同一进程中的线程，如果加锁后没有解锁，则其他线程将无法再获取锁。
28、当一个互斥锁使用完毕后，必须进行清除。清除一个互斥锁意味着释放它所占用的资源。
29、由于在Linux中，互斥锁并不占用内用，因此pthread_mutex_destroy除了解除到互斥锁的状态以外没有其他操作。
30、条件变量是利用线程间共享的全局变量进行同步的一种机制。两个动作：一个等待使用资源的线程等待“条件变量被设置为真”；另一个线程在使用完资源后“设置条件为真”。保证条件变量能被正确修改，条件变量要受到特殊保护，实际使用中互斥锁扮演着一个保护者的角色。
31、异步信号，信号与任何线程都是异步的，信号到达线程的时间是不定的。如果有多个线程可接收异步信号，则只有一个被选中。如果并发的多个同样的信号被送到一个进程，每一个将被不同的线程处理。
32、在Linux系统中，线程是在内核外实现的。进程是在内核中实现的。Linux线程本质上是轻量级的进程。
33、软件开发中，通过编写错误处理代码可以快速地发现问题所在。
34、通过错误码得到错误的描述信息。（errno.h）不能根据errno的值来判断一个函数执行是否成功。当函数调用失败时，errno值才有意义。
35、错误码是一些定义在errno.h中的宏，通常以字母E（代表error）开头。 sterror和perror可通过错误码获取标准的错误提示信息。

第 9 章 信号及信号处理
1、信号（signal）是一种软件中断，它提供了一种处理异步事件的方法，也是进程间唯一的异步通信方式。
2、信号的来源，硬件方式：终端按键，硬件异常产生信号（除0、无效的存储访问等）；软件方式：终端kill命令，进程调用kill或sigqueue函数发出信号，某种软件条件已经具备（alarm或settimer）。
3、信号的种类，可靠信号和不可靠信号。
4、注意：Linux线程机制使用了前3个实时信号。Linux下没有16和32号信号。
5、在Linux系统中，信号的可靠性是指信号是否会丢失，或者说该信号是否支持排队。信号的产生和递送之间的时间间隔，称为信号未决（pending）
6、进程可调用sigpending将信号设置为阻塞。优先传递不可靠信号。
7、进程对信号的响应：捕捉信号；忽略信号；按照系统默认方式处理。
8、Linux系统中对信号的处理主要由signal和sigaction函数完成。pause，用来响应任何信号，不过不做任何处理。
9、注意：SIGKILL和SIGSTOP这两个信号不能被捕获或忽略。
10、Linux下的signal函数由sigaction实现的。
11、函数不可重入：使用了静态的数据结构；调用了malloc函数或free函数；使用了标准I/O函数。
12、信号处理期间自动屏蔽了正在被处理的信号，而使用setjimp/longjmp跳出信号处理程序时又不会自动将信号屏蔽码修改回原来的屏蔽码，从而引起该信号被屏蔽。sigsetjmp/siglongjmp
13、信号的发送主要由函数kill、raise、sigqueue、alarm、settimer及abort完成。
14、注意：只有root权限的进程才能向其他任一进程发送信号，非root权限的进程只能向属于同一个组或同一个用户的进程发送信号。
15、信号SIGINT的编号在所有Linux系统中都为2.
16、最新一次调用alarm函数会取消之前一次的设定。注意：alarm只设定为发送一次信号，如果要多次发送，就要对alarm进行多次调用。
17、alarm和settimer使用同一个定时器，因次会相互影响。
18、信号的屏蔽，又称信号阻塞。
19、sigset_t表示信号集。注意：所有应用程序在使用信号集前，要对该信号集调用一次sigemptyset和sigfillset以初始化信号集。因为C语言编译器将不赋初值的外部和静态变量都初始化为0.
20、每个进程都有一个信号屏蔽码，它规定了当前阻塞不能递送给该进程的信号集。
21、man命令获得帮助或查阅相关书籍。编译器，调试器。正确的关键词在搜索引擎上搜索。
22、学习编程，不断循环：“阅读书籍和资料-->上机编程实践-->遇到问题-->解决”。

第 10 章 进程间通信
1、方式：管道(pipe)、有名管道(named pipe)、消息队列(message queue)、信号量(semophore)和共享内存(shared memory)，信号(signal)和套接字(socket)。
2、Linux软件开发中极为常用的库开发技术。
3、Internet Process Connection，IPC编程技术。
4、Linux下进程间通信的方法基本上是从UNIX平台继承而来的。system V IPC和基于套接字的进程通信。
5、进程的亲缘关系通常指父子进程关系。
6、共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。往往与如信号量，配合使用。
7、管道半双工，单向通信的机制。缓冲区大小是受限制的，传送的是无格式的字节流。创建，pipe函数，是一种文件。注意：管道一旦创建，就可作为一般的文件来使用，对一般文件进行操作的I/O函数也适用于管道。
8、注意：只有在管道的读端存在时，向管道中写入数据才有意义。
9、dup和dup2提供了复制文件描述符的功能。
10、有名管道，
11、消息队列是一个存放在内核中的消息链表，每个消息队列由消息队列标识符标识。
12、消息缓冲结构，msgbuf。注意：mutext虽然定义为char类型，并不代表消息只能是一个字符串，消息内容可以为任意类型。
13、msqid_ds，保存消息队列当前的状态信息。
14、每个消息队列在系统范围内对应唯一的键值。ftok函数，
15、注意：IPC_EXCL单独使用没有任何意义。
16、ftok-->msgget-->msgsnd/msgrcv。msgctl，获取和设置消息队列属性。
17、信号量是一个计数器，常用于处理进程或线程的同步问题，特别是对临界资源访问的同步。信号量的值大于或等于0时可供并发进程使用的资源实体数；小于0时代表正在等待使用临界资源的进程数。注意：信号量与信号是没有关系的。内核维护semid_ds
18、ftok-->semget-->semctl
19、信号量的值只能由PV操作来改变。Linux下PV操作通过函数semop实现。
20、共享内存就是分配一块能被其他进程访问的内存。内核维护shmid_ds。
21、ftok-->shmget-->shmat/shmdt--->shmctl
22、读写者问题
23、库是一种软件组件技术，库里面封装了数据和函数，提供给用户程序调用。可使程序模块化，提高程序的编译速度，实现代码重用，使程序易于升级。
24、Windows系统，静态链接库(.lib)和动态链接库(.dll)。Linux通常把库文件放到/usr/lib或/lib目录下。Linux库文件名由前缀lib，库名及后缀3部分组成。动态链接库(.so)，静态链接库(.a)
25、载入顺序是不一样的。静态库的代码在编译时就拷贝到应用程序中，节省编译时间。动态链接库是在程序开始运行后调用库函数时才被载入，被调函数在内存中只有一个副本，且动态库可以在程序运行期间释放动态库所占用的内存。
26、创建静态库步骤：在一个头文件中声明静态库导出函数；在一个源文件中实现静态库所导出的函数；编译源文件，生成可执行代码；将可执行代码所在的目录文件加入到某个静态库中，并将静态库拷贝到系统默认的存放库文件的目录下。
27、库编译时无需带上前缀和后缀。
28、ar命令创建和修改静态库。
29、编译函数库源程序时加上-shared选项即可。两种使用动态链接库：像使用静态库一样（gcc命令调用）；通过调用系统函数来使用动态链接库（库必须在当前目录下）。
30、注意：引用动态链接库时，必须含有路径。如果只是用*.so，则必须保证这个库所在目录包含在PATH环境变量中。
31、《UNIX环境高级编程》(W.Richard Stevens)        《Solaris系统编程》(Rich Teer)       Linux内核  《深入理解Linux内核》第三版(Bovet和Cesati)           《Linux设备驱动编程》第三版(Corbet)

第 三 篇 Linux网络和图形界面编程
第 11 章 网络编程
1、网络相关的理论基础
2、网络模型和协议，为了减少协议设计的复杂性，大多数网络模型都是按层(layer)的方式来组织的。每一层都为上一层提供一定的服务，而把如何实现本层服务的细节对上一层加以屏蔽。
3、分层的思想也是设计大型软件的一种重要思想，有些操作系统就是基于分层的思想设计和实现的。
4、开放系统互联(OSI)的规范。普遍使用的是TCP/IP模型。几乎所有互联网设备都支持TCP/IP协议。
5、网络接口层，包含多种逻辑链路控制和媒体访问协议。负责将Internet层发送来的数据分成帧，并通过物理链路进行传送，或从网络上接收物理帧，抽取数据并转交给其上的Internet层。
6、Internet层(网络层)，负责在发送端和接收端之间建立一条虚拟路径。IP协议，并不保证数据能完整正确地到达目的地，这个任务由它上面的传输层来完成。ARP(地址解析协议)和RARP协议(反向地址解析协议)用于IP地址和物理地址(网卡地址)的相互转换。如果数据在传输过程中出现问题，该层的ICMP协议将生产错误报文。
7、传输层，TCP或UDP协议在两台主机间传输数据。TCP，提供可靠的面向连接的服务，它保证数据能完整地按顺序地传送到目标计算机。在速度上会有些损失。UDP提供简单的无连接服务，它不保证数据能按顺序、正确地传送到目的地(但可由它的上层来保证)，它不用建立连接，通常速度比TCP快些。TCP协议和IP协议都需要网络层提供通往目的地的路由。传输层提供端到端，即应用程序之间的通信。该层的主要功能有差错控制、传输确认和丢失重传等。
8、应用层，面向用户提供一系列访问网络的协议，如FTP协议，Telnet、SMTP、HTTP(超文本传输协议).点对点共享文件协议(近几年十分流行)BitTorrent协议，该协议基于HTTP协议。使用该协议构建的BT下载工具具有比特精灵、BitTorrent等。
9、协议，就是通信实体为实现正确的通信而制定的规格。TCP/IP是由许多协议构成的协议簇。
10、物理地址(如网卡地址)和IP地址。以太网，物理地址就是一个48位的位串，此地址在网卡的生产过程中就已经固定了，是不可更改的，且是全球唯一的。ifconfig查看本机的物理地址。
11、每块网卡代表计算机的一个网络接口，多块网卡，称这种计算机为多宿主计算机(Multihomed Computer)
12、与底层硬件技术无关的通用地址来标识网络上的每台计算机，这就是IP地址。由32bit构成，分两部分：计算机所在的网络号和该网络给计算机分配的主机号，分别称为网络ID和主机ID。
13、有些地址是专用的，不能用来标识计算机。
14、IP地址按一定格式分成5类：A类(8 + 24，第一位固定为0)、B类(16 + 16，10)、C类(24 + 8，110)、D类和E类(较少使用)。
15、127.0.0.1，是一个特殊的地址，它指代本机，用于测试本机上的TCP/IP协议是否正常工作。ping 127.0.0.1，如果有回应说明本机上的TCP/IP协议工作正常。
16、TCP/IP上的每台主机还有一个32位的子网掩码，用来区分IP地址的网络号和主机号。将IP地址与子网掩码进行按位“与”运算就可以得到IP地址的网络号，网络号是一台主机所处的网络的编号。
17、IPv6是一个128位的IP地址(2的128次)。IPv6预计2020年前后进行大规模的实际应用。
18、一台计算机上的多个应用程序，TCP和UDP协议采用16位的端口号来识别它们。不同的进程可以绑定到不同的端口上，互不干扰。保留端口即知名端口(0~1024),由权威机构规定其用途。如21（TCP）由FTP协议专用，80(TCP)由HTTP协议专用；其余的为自由端口，用户进程可自由申请和使用。
19、IP协议是网络层最重要的协议。主要负责路由，当到达同一目的地有多条路由时，IP协议会选择一条最短路由来将数据分组传送到目的计算机。IP数据报，它由IP首部和数据两部分组成。
20、版本，4、6；最大生存时间(Time to Live，TTL)；数据报每经过一个路由器，路由器将TTL值减1，当TTL减为0时，数据报被丢弃，并该路由器会向发送者返回一个ICMP超时报文，告知数据被丢失。TTL默认为64，最大255.协议，0x06(TCP)，0x11(UDP)；报头校验和只校验IP首部，不校验数据。IP选项是一个可选的字段，主要用于网络调试。
21、应用程序采用UDP协议无需建立和维持连接。UDP不保证数据报按顺序、正确地到达目的地。UDP校验和根据IP首部、UDP首部和数据计算出来的值(设为0，表明发送端计算机没有计算校验和)。
22、TCP通信的过程：step1，连接的发起端(称为客户端)向目标计算机(服务器)发送一个请求建立连接的数据包；step2，服务器收到请求后，对客户端的同步信号作出响应，并发送自己的同步信号给客户端；step3：客户端对服务器端发来的同步信号进行响应，连接建立完成，就可以进行数据传输了。
23、TCP关闭：step1，请求主机发送一个关闭连接的请求给另一方；step2，另一方收到关闭连接请求后，发送一个接受请求的确认数据包，并关闭它的socket连接；step3，请求主机收到确认数据包后，发送一个确认数据包，告知另一方其发送的确认已收到，请求主机关闭它的socket连接。
24、套接字编程，20世纪80年代初，美国政府提供资金，委托加利福尼亚大学伯克利分校在UNIX操作系统下实现针对TCP/IP协议的应用程序编程接口。首先被应用于Berkeley Software Distribution(BSD)UNIX系统。
25、Linux下的网络编程就是指套接字编程。
26、套接字地址结构，struct_sockaddr(通用的套接字地址)，TCP/IP协议(AF_INET)，一般编程中并不对该结构体直接操作，而是使用另一个与它等价的数据结构：sockaddr_in来设置地址，然后通过强制类型转换成sockaddr类型。
27、每种协议族都有自己的协议地址格式。TCP/IP的地址格式为sockaddr_in。
28、创建套接字，socket函数，
29、协议族：AF_UNIX(只在本机内进行通信的套接字)、AF_INET、AF_INET6。套接字类型：SOCK_STREAM、SOCK_DGRAM、SOCK_RAW.
30、当使用原始套接字时，系统无法唯一地确定协议，此时就需要使用该参数(protocl)指定所使用的协议。(默认设置为0)。
31、建立链接，connect函数，在一个指定的套接字上创建一个连接。对于SOCK_DGRAM类型的套接字，调用connect函数的好处是不必在每次发送和接收数据时都指定目的地址(只是告诉内核与该套接字进行通信的目的地址，只有该目的地址发来的数据才会被该socket接收)。
32、通常一个面向连接的套接字只能调用一次connect函数，而对于无连接的套接字可多次调用connect函数以改变与目的地址的绑定。将参数serv_addr中的sa_family设置为AF_UNSPEC可以取消绑定。
33、htons是字节顺序转换函数，inet_aton函数将一个字符串转换成一个网路地址。
34、bind，将一个套接字和某个端口绑定在一起。服务器端的IP地址和端口号一般是固定的。该函数一般只有服务器端程序调用。将sin_addr设置为INADDR_ANY而不是某个确定的IP地址就可以绑定到任何网络接口。
35、listen，把套接字转化为被动监听。服务器端设置一个连接队列，记录已建立的连接，参数backlog指定该连接队列的最大长度。连接队列已经达到最大，之后的连接请求将被服务器拒绝。
36、由socket创建的套接字是主动套接字，可用来主动请求连接到某个服务器(通过函数connect)。
37、注意：函数listen只是将套接字设置为倾听模式以等待连接请求，它并不能接收连接请求，真正接收客户端连接请求的是后面是函数accept。
38、accept，用来接受一个连接请求。只能对面向连接的套接字使用accept函数。
39、套接字设置非阻塞方式，fcntl。
40、send，用来在TCP套接字上发送数据。只能对于处于连接状态的套接字(accept成功返回的套接字描述符)使用。发送数据太长而不能发送，出现错误；发送数据大于该套接字的缓冲区剩余空间大小时，send一般会阻塞。
41、注意：执行成功只是说明数据写入套接字的缓冲区，并不表示数据已经成功地通过网络发送到目的地。
42、recv，用来在套接字上接收数据。函数接收到数据就返回，并不会等地啊接收到参数len指定长度的数据才返回。
43、sendto，UDP套接字上发送数据。
44、recvfrom，UDP接收数据。shutdown，关闭一个套接字，但功能更强大。它允许对套接字进行单向关闭或全部禁止。
45、主要系统调用函数：字节顺序和转换函数，
46、TCP/IP协议规定了在网络上必须采用网络字节顺序(即大端模式，高字节数据存低地址，低字节数据存高地址)。
47、Linux为大小端模式的转换提供了4个函数：htonl(host to network long(unsigned int))、htons(host to network short(unsigned short))。ntohl、ntohs反过来。
48、inet系列函数，inet_aton,inet_addr(已过时),inet_network,inet_ntoa,inet_makeaddr,inet_lnaof,inet_netof
49、控制套接字属性，getsockopt，setsockopt。
50、套接字操作层次：SOL_SOCKET(通用套接字)、IPPROTO_IP(IP层套接字)、IPPROTO_TCP(TCP层套接字)。
51、SOL_SOCKET的选项：SO_KEEPALIVE、SO_RCVLOWAT和SO_SNDLOWAT、SO_RCVTIMEO和SO_SNDTIMEO、SO_BINDTODEVICE、SO_DEBUG(只对TCP套接字使用)、SO_REUSEADDR、SO_TYPE、SO_ACCEPTCONN、SO_DONTROUTE、SO_BROADCAST、SO_SNDBUF和SO_RCVBUF、SO_ERROR。
52、SO_KEEPALIVE，若没设置，即使TCP连接已经很长时间没有数据传输时，系统也不会检测这个连接是否有效。对于服务器进程，如果某一客户端非正常断开连接，则服务器进程将一直被阻塞。服务器程序需要设置SO_KEEPALIVE，如果某个客户端一段时间内没有反应则关闭连接。
53、SO_RCVLOWAT和SO_SNDLOWAT，Linux下这两个值都为1且不能更改，也就是说只要有数据接收或发送。
54、Linux系统中，如果一个socket绑定了一个端口，该socket正常关闭或程序退出后的一段时间内，该端口依然维持原来的绑定状态，其他程序无法绑定该端口。SO_REUSEADDR解决这个问题。
55、实际应用中要在网络上广播数据必须硬件支持广播且使用的是SOCK_DGRAM套接字。
56、对于TCP类型，缓冲区太小会影响TCP的流量控制；对于UDP，数据缓冲区满则后续数据将被丢弃。实际应用中应根据需要社会之一个合适的大小。
57、注意：调用完函数getsockopt之后so_error的值将自动被重新初始化。
58、多路复用select(实现第二种方式)。一种方式是，实现多路复用的最简单的方法是采用非阻塞方式套接字，服务器不断地查询各个套接字的状态，如果有数据到达则读出数据，如果没有则查看下一个套接字。轮询过程中浪费了大量的CPU时间，效率非常低。另一种方式，服务器进程并不主动地询问套接字状态，而是向系统登记希望监视的套接字，然后阻塞；当套接字上有事件发生时(如数据到达)，系统通知服务器进程告知哪个套接字发生了什么事件，服务器进程查询对应套接字并进行处理。
59、注意：这里的文件描述符既可以是普通文件的描述符，也可以是套接字描述符。
60、系统为文件描述符集合提供了一些的宏，FD_CLR、FD_ISSET、FD_SET、FD_ZERO。
61、注意：如果在循环中调用select，则参数timeout的初始化必须放在循环内部。Linux系统对select的实现中会修改参数timeout为剩余时间。
62、由于TCP是一种基于流的数据传输格式，数据没有固定格式，需要在应用程序中定义一定的数据格式。
63、编写安全的代码，TCP/IP协议族在设计时并没有考虑到网络安全问题，使得基于TCP/IP协议族构建的Internet在安全性方面非常脆弱。
64、在所有安全漏洞中，威胁最大对的是缓冲区溢出漏洞。黑客、病毒、蠕虫利用这类漏洞可在几秒钟获得系统的控制权或者利用这类漏洞使主机或网站瘫痪。主要原因是程序员在编写代码时缺乏安全意识，在程序中留下了许多安全漏洞。
65、网络攻击，扫描和探测、监听、拒绝服务、恶意软件。
66、探测是指使用工具自动探测主机中的漏洞，以便为下一步的攻击做准备。也可用来检测自己的网络或主机系统的安全性，发现漏洞及时下载补丁。
67、由数千台、数万台或更多的傀儡主机构成的僵尸网络可以称为网络原子弹。
68、缓冲区溢出：包括多种类型，如堆溢出、栈溢出、静态存储区溢出、数组越界等。程序中缺乏对输入数据的检查。
69、产生缓冲区溢出的根本原因是：C/C++语言本质上是不安全的。方法，对程序中定义的缓冲区作严格的边界检查。不允许将多余的数据写入缓冲区中。应尽量避免使用strcpy等存在溢出漏洞的函数，而使用strncpy或memcpy等作为替代。使用工具对代码进行检查(只能用于减少，并不能完全消除)。
70、Linux系统中，一个进程在内存中的数据主要分3个部分：文本段、数据段和堆栈段。
71、输入检查，对输入的参数进行检查是一个良好的编程习惯。对输入数据的类型、长度进行合法性检查。特别是指针参数，必须检查是否为NULL，它所指向的空间是否大于缓冲区空间。
72、常用的端口扫描技术有多种：TCP connect扫描、TCP SYN扫描、TCP FIN扫描。
73、connect成功，说明目标计算机的该端口是打开的。未打开(返回-1，且错误码为ECONNREFUSED).
74、注意：在运行本端口扫描程序前，最好先关闭防火墙，因为有的防火墙禁止以这种方式对主机进行探测。
75、当向目的主机未打开的UDP端口发送UDP数据时，目标设备会返回一个“ICMP端口不可到达"的错误报文。且函数sendto将出错并将错误码设置为ECONNREFUSED，可利用这一点进行UDP端口扫描。
76、要编写出功能强大、高效率的网络应用程序，必须对TCP/IP协议非常熟悉。《TCP/IP详解》、《用TCP/IP进行网际互联》。
77、编写基于Client/Server模型程序时，服务器端的心梗尤为重要。其效率、并发性以及安全性是难点，《UNIX网络编程》(Richard W.Stevens)
78、《编写安全的代码》(微软公司两位安全专家撰写)

第 12 章 GTK+图形界面编程
1、Linux下的图形界面编程。基于C语言的具有面向对象特征的GTK+图形界面编程。框架、基本原理、常用控件的使用。
2、Qt是一个跨平台的图形用户开发库，它不仅支持Linux操作系统，还支持所有类型的UNIX以及Windows操作系统。Qt良好的封装机制使它模块化程度非常高，可重用性很强，Qt提供了丰富的API供开发人员使用。使用Qt开发的图形用户界面程序具有良好的稳定性和健壮性。
3、桌面环境KDE(K Desktop Evironment即K桌面环境)就是使用Qt作为其底层库开发出来的。
4、GTK+，
5、两类C库：标准C库和Linux的系统调用。glib，GDK、GTK+、GNIME应用程序常用的库（包含内存分配、字符串操作、日期和时间、定时器等，也包括链表、队列、树等工具函数）。X，控制图形显示的底层函数库(包括所有窗口显示、响应键盘和鼠标操作等)。GDK，(GIMP绘图包)简化程序使用X函数库而开发的，提高开发效率。GTK+，就是GIMP工具包，它把GDK提供的函数组织成对象，使用C语言模拟出面向对象的特征；其重要组成部分是widget(控件，也称小部件)。GNOME，对GTK+的扩展，用来控制整个桌面。
6、GIMP(GNU Image Minipulation Program即GNU图形处理程序)。GDK(GIMP Drawing kit)
7、安装GTK源代码。头gtk/gtk.h。gtk_init，定位和打开图形显示，并对颜色、信号等进行初始化。gtk_windows_new，创建顶级窗口。事件，GTK+都有相应的消息信号产生。g_signal_connect，用于在空间和消息处理函数间建立关联。
8、注意：编译命令中的字符串`pkg-config --libs --cflags gtk+-2.0`两边的反引号。
9、回调函数，在程序中定义，但程序中并没有显式调用而是由系统在事件发生后自动回调。
10、图形用户界面的程序是事件驱动的程序。
11、gtk+使用一些宏将子类强制转换为父类。
12、排列控件，box(盒子)、table(表格)。
13、《GTK+2.0编程范例》宋国伟；《GNOME/GTK+编程宝典》；