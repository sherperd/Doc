序
1、并发编程的几个误解：并发就是多线程；只有大型服务器才需要考虑并发；并发编程很复杂，必须掌握很多底层技术。
2、理念：按软件的不同层次进行明确分工，我只负责我所实现的这个层次，底层技术是为上层服务的，我只负责选择和调用，不管内部的实现过程。
3、国内开发人员通病：分工不够细、技术关注不够精。
4、利用现成的库开发出高质量的软件，对技术能力的考验并不低于开发底层库。
5、麝香猫成为代表并发和多线程的完美吉祥物。
6、竞态条件（race condition）
7、并发性正成为现代程序的一个必备特性。
8、推荐阅读：Prallel Programming with Microsoft .NET（Microsoft Press），英文原版电子书可以从网上下载（内容有些过时）如，“future模式”部分应该用异步编程，“流水线(pipeLine)”应该用任务TPL数据流。异步编程，推荐阅读MSDN，特别是“Task-based Asynchronous Pattern”文档。TPL数据流，推荐阅读微软发布的“Introduction to TPL Dataflow”文档。响应式扩展（Rx），资料Lee Campbell写的Introduction to Rx。
9、从事写作：“你将有一年的时间无法陪伴家人”。

第 1 章 并发编程概述
1、优秀软件的一个关键特征就是具有并发性。
2、新版.NET中的程序库和语言特征，已经让并发编程变得简单多了。
3、并发：同时做多件事。
4、多线程：并发的一种，它采用多个线程来执行程序。实际上，直接使用底层线程类型在现代程序中基本不起作用。
5、比起老式的多线程机制，采用高级的抽象机制会让程序功能更加强大、效率更高。
6、一旦你输入new Thread()，那就太糟糕了，说明项目中的代码太过时了。
7、线程池要求多线程继续存在。线程池存放任务的队列，这个队列能够根据需要自行调整。线层池产生了另一个重要的并发形式：并行处理。
8、并行处理：把正在执行的大量的任务分割成小块，分配给多个同时运行的线程。
9、并行处理是多线程的一种，多线程是并发的一种。
10、异步编程：并发的一种形式，它采用future模式或者回调（callback）机制，以避免产生不必要的线程。
11、一个future（或者promise）类型代表一些即将完成的操作。
12、新版future类型有Task和Task<TResult>。
13、异步操作：启动了的操作将会在一段时间后完成。
14、异步编程是一种功能强大的并发形式。
15、响应式编程（reactive programming），一种声明式的编程模式，程序在改模式中对事件作出响应。基于异步事件的（asynchronous event），而不是异步操作（asynchronous operation）。
16、异步事件可以没有一个实际的“开始”，可以在任何时间发生，并且可以发生多次，如用户的输入。
17、如果使用了async，最好就一直使用它。
18、每个任务块要尽可能的互相独立。
19、任务不要特别短，也不要特别长。


第 2 章 异步编程基础
1、暂停一段时间，Task.Delay。简单的指数退避
2、实际产品的开发中，建议采用更周密的方案，如微软企业库中的瞬间错误处理模块（Transient Error Handling Block）
3、Task.Delay适合于对异步代码进行单元测试或者实现重试逻辑。要实现超时功能的话，最好使用CancellationToken。
4、返回完成的任务，Task.FromResult只能提供正确的同步Task对象。TaskCompletionSource
5、报告进度，异步操作执行的过程中，需要展示操作的进度。IProcess<T>、Process<T>
6、若果一个方法可以报告进度，就该尽量做到可以被取消。
7、等待一组任务完成，Task.WhenAll。一般不检查所有的异常。通常情况下，只处理第一个错误就足够了，没必要处理全部错误。
8、只要异步代码与LINQ结合，显式的“具体化”序列（即对序列求值，创建集合）就会使代码更清晰。
9、等待任意一个任务完成，Task.WhenAny。通常需要在Task对象完成后继续使用await。
10、任务完成时的处理，
11、避免上下文延续。如果在UI线程上运行的延续任务（continuation）太多，会导致性能上的问题。UI线程中有多少个延续任务算多（每秒100个左右尚可，1000就太多了）
12、处理async Task方法的异常，只有Task对象被await调用时，才会引发异常。
13、处理async void方法的异常

第 3 章 并行开发的基础
1、分解计算密集型的任务片段，并将它们分配给多个线程。
2、并行聚合，通过局部值（local value）来实现，只在并行循环内部存在的变量。循环中的代码使用LocalFinally委托来对每个局部值进行聚合。并行LINQ对聚合的支持，比Parallel类更加顺手。
3、并行调用，Parallel.Invoke。
4、动态并行，直接使用Task类（最简单）。
5、Task类的功能很强大，Parallel类和并行LINQ只是为了使用方便，从而对Task类进行了封装。
6、并行LINQ，非常适用于数据流的操作。
7、相比PLINQ，Parallel类与系统中的其他进程配合得更好。


第 4 章 数据流基础
1、TPL数据流（dataflow）库的功能很强大，可用来创建网格（mesh）和管道（pipeline），并通过它们以异步的方式发送数据。
2、数据流的代码具有很强的“声明式编程”风格。
3、链接数据流块，默认情况下，链接的数据流块只传递数据，不传递完成情况（或出错信息）。
4、传递出错信息，故障状态，会删除所有的数据（并停止接收新数据）。被AggregateException封装很多层，用AggregateException.Flatten方法可以简化错误处理过程。
5、断开链接，在处理的过程中修改数据结构（高级应用）。建立或断开链接时，线程都是完全安全的。
6、限制流量（throttling），BoundedCapacity属性。默认情况下，每个数据流块会维护一个输入缓冲区，在处理数据之前接收任意数量的数据。可用于分叉的负载平衡。
7、数据流块的并行处理，难点：找出哪些数据流块需要并行处理，方法：在调试时暂停数据流的运行，在调试器中查看等待的数据项的数量（就是还没有被数据流块处理的数据项）。MaxDegreeOfParallelism参数，代表并发的层次，即一定数量的槽（slot）。
8、创建自定义数据流块，Encapsulate方法，

第 5 章 Rx基础（Reactive Extension）
1、LINQ，查询是延后执行，只有在需要的时候才会从序列中获取数据。（拉取模式）
2、Rx把事件看作是依次到达的数据序列。将Rx认作是LINQ to event也是可以的（推送模式）
3、Rx查询规定了在事件到达时程序该如何响应。
4、Rx在LINQ基础上构建，增加了一些功能强大的操作符，作为扩展方法。
5、转换.NET事件，subscribe、SubscribeOn（控制订阅和退订的上下文）
6、事件是Rx流数据的主要来源。
7、发通知给上下文，ObserveOn，把通知转移到一个Rx调度器上。
8、用窗口和缓冲对事件分组，Buffer和Window。Buffer等待组内的所有事件，然后把所有事件作为一个集合发布。Window用同样的方法进行分组，但它是在每个事件到达时就发布。限流（throttling）
9、Rx尽量做到了线程不可知（thread agnostic）
10、用限流和抽样抑制事件流。Throttle和Sample。Throttle建立了一个临时窗口，超时期限可以设置（常用于文本框自动填充场合）。Sample建立了一个有规律的超时时间段，每个时间段结束时，它就发布该时间段内最后一条数据。标准LINQ的Where操作符
11、超时，单一的异步操作（如，等待Web服务请求的响应）。Timeout在输入流上建立一个可调节的超时窗口。非常适用于异步操作。

第 6 章 测试技巧
1、单元测试两大好处：更好的理解代码。修改代码时更有把握（提前准备，以免以后麻烦）。
2、async方法的单元测试。单元测试框架检测到方法的返回类型是Task，会自动加上await等待任务完成，然后将测试结果标记为“成功”或“失败”。
3、对每个测试进行超时设置很有用。通常将每一个测试的超时参数设置成2秒。
4、预计失败的async方法的单元测试，建议不要使用ExpectedException（更适用于测试某个特定点抛出的异常，而不是整个测试过程中随时抛出的异常）。使用ThrowException
5、对错误处理进行测试，与测试正确的场景一样重要。
6、async void方法的单元测试，要尽最大可能避免这个问题，而不是去解决它。进行代码重构，而不是使用AsyncContext。
7、在async代码中，关键准则之一就是避免使用async void。
8、数据流网格额单元测试，
9、Rx Observable对象的单元测试。SingleAsync操作符返回一个Task<T>对象，该对象在下一个事件到达时完成。SingleAsync可用来做简单的单元测试。
10、Return操作符创建一个只有一个元素的冷序列（cold sequence），可用它来构建简单的存根（stub）。
11、存根代码中另一个重要操作符是Throw，它返回一个以错误结束的Observable对象。
12、用虚拟时间测试Rx Observable对象，允许调用它的程序指定调度器。用TestScheduler可以对时间进行完整地控制。使用虚拟时间立即完成。

第 7 章 互操作
1、用async代码封装Async方法与Completed事件，
2、基于事件的异步模式（EAP），基于任务的异步模式（TAP）
3、在新编写的代码时都要使用HttpClient。只有在维护以前遗留代码时才用WebClient。
4、用async代码封装Begin/End方法。使用TaskFactory类型的一个FromAsync方法。
5、异步编程模型（APM）
6、用async代码封装所有异步操作，
7、用async代码封装并行代码，将并行处理封装进Tesk.Run，并使用await。只能用于UI代码。在服务端很少用并行处理。
8、用async代码封装Rx Observable对象，
9、用Rx Observable对象封装async代码，
10、Rx Observable对象和数据流对象，

第 8 章 集合
1、
