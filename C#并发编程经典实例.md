序
1、并发编程的几个误解：并发就是多线程；只有大型服务器才需要考虑并发；并发编程很复杂，必须掌握很多底层技术。
2、理念：按软件的不同层次进行明确分工，我只负责我所实现的这个层次，底层技术是为上层服务的，我只负责选择和调用，不管内部的实现过程。
3、国内开发人员通病：分工不够细、技术关注不够精。
4、利用现成的库开发出高质量的软件，对技术能力的考验并不低于开发底层库。
5、麝香猫成为代表并发和多线程的完美吉祥物。
6、竞态条件（race condition）
7、并发性正成为现代程序的一个必备特性。
8、推荐阅读：Prallel Programming with Microsoft .NET（Microsoft Press），英文原版电子书可以从网上下载（内容有些过时）如，“future模式”部分应该用异步编程，“流水线(pipeLine)”应该用任务TPL数据流。异步编程，推荐阅读MSDN，特别是“Task-based Asynchronous Pattern”文档。TPL数据流，推荐阅读微软发布的“Introduction to TPL Dataflow”文档。响应式扩展（Rx），资料Lee Campbell写的Introduction to Rx。
9、从事写作：“你将有一年的时间无法陪伴家人”。

第 1 章 并发编程概述
1、优秀软件的一个关键特征就是具有并发性。
2、新版.NET中的程序库和语言特征，已经让并发编程变得简单多了。
3、并发：同时做多件事。
4、多线程：并发的一种，它采用多个线程来执行程序。实际上，直接使用底层线程类型在现代程序中基本不起作用。
5、比起老式的多线程机制，采用高级的抽象机制会让程序功能更加强大、效率更高。
6、一旦你输入new Thread()，那就太糟糕了，说明项目中的代码太过时了。
7、线程池要求多线程继续存在。线程池存放任务的队列，这个队列能够根据需要自行调整。线层池产生了另一个重要的并发形式：并行处理。
8、并行处理：把正在执行的大量的任务分割成小块，分配给多个同时运行的线程。
9、并行处理是多线程的一种，多线程是并发的一种。
10、异步编程：并发的一种形式，它采用future模式或者回调（callback）机制，以避免产生不必要的线程。
11、一个future（或者promise）类型代表一些即将完成的操作。
12、新版future类型有Task和Task<TResult>。
13、异步操作：启动了的操作将会在一段时间后完成。
14、异步编程是一种功能强大的并发形式。
15、响应式编程（reactive programming），一种声明式的编程模式，程序在改模式中对事件作出响应。基于异步事件的（asynchronous event），而不是异步操作（asynchronous operation）。
16、异步事件可以没有一个实际的“开始”，可以在任何时间发生，并且可以发生多次，如用户的输入。
17、如果使用了async，最好就一直使用它。
18、每个任务块要尽可能的互相独立。
19、任务不要特别短，也不要特别长。


第 2 章 异步编程基础
1、暂停一段时间，Task.Delay。简单的指数退避
2、实际产品的开发中，建议采用更周密的方案，如微软企业库中的瞬间错误处理模块（Transient Error Handling Block）
3、Task.Delay适合于对异步代码进行单元测试或者实现重试逻辑。要实现超时功能的话，最好使用CancellationToken。
4、返回完成的任务，Task.FromResult只能提供正确的同步Task对象。TaskCompletionSource
5、报告进度，异步操作执行的过程中，需要展示操作的进度。IProcess<T>、Process<T>
6、若果一个方法可以报告进度，就该尽量做到可以被取消。
7、等待一组任务完成，Task.WhenAll。一般不检查所有的异常。通常情况下，只处理第一个错误就足够了，没必要处理全部错误。
8、只要异步代码与LINQ结合，显式的“具体化”序列（即对序列求值，创建集合）就会使代码更清晰。
9、等待任意一个任务完成，Task.WhenAny。通常需要在Task对象完成后继续使用await。
10、任务完成时的处理，
11、避免上下文延续。如果在UI线程上运行的延续任务（continuation）太多，会导致性能上的问题。UI线程中有多少个延续任务算多（每秒100个左右尚可，1000就太多了）
12、处理async Task方法的异常，只有Task对象被await调用时，才会引发异常。
13、处理async void方法的异常

第 3 章 并行开发的基础
1、分解计算密集型的任务片段，并将它们分配给多个线程。
2、并行聚合，通过局部值（local value）来实现，只在并行循环内部存在的变量。循环中的代码使用LocalFinally委托来对每个局部值进行聚合。并行LINQ对聚合的支持，比Parallel类更加顺手。
3、并行调用，Parallel.Invoke。
4、动态并行，直接使用Task类（最简单）。
5、Task类的功能很强大，Parallel类和并行LINQ只是为了使用方便，从而对Task类进行了封装。
6、并行LINQ，非常适用于数据流的操作。
7、相比PLINQ，Parallel类与系统中的其他进程配合得更好。


第 4 章 数据流基础
1、TPL数据流（dataflow）库的功能很强大，可用来创建网格（mesh）和管道（pipeline），并通过它们以异步的方式发送数据。
2、数据流的代码具有很强的“声明式编程”风格。
3、链接数据流块，默认情况下，链接的数据流块只传递数据，不传递完成情况（或出错信息）。
4、传递出错信息，故障状态，会删除所有的数据（并停止接收新数据）。被AggregateException封装很多层，用AggregateException.Flatten方法可以简化错误处理过程。
5、断开链接，在处理的过程中修改数据结构（高级应用）。建立或断开链接时，线程都是完全安全的。
6、限制流量（throttling），BoundedCapacity属性。默认情况下，每个数据流块会维护一个输入缓冲区，在处理数据之前接收任意数量的数据。可用于分叉的负载平衡。
7、数据流块的并行处理，难点：找出哪些数据流块需要并行处理，方法：在调试时暂停数据流的运行，在调试器中查看等待的数据项的数量（就是还没有被数据流块处理的数据项）。MaxDegreeOfParallelism参数，代表并发的层次，即一定数量的槽（slot）。
8、创建自定义数据流块，Encapsulate方法，

第 5 章 Rx基础（Reactive Extension）
1、LINQ，查询是延后执行，只有在需要的时候才会从序列中获取数据。（拉取模式）
2、Rx把事件看作是依次到达的数据序列。将Rx认作是LINQ to event也是可以的（推送模式）
3、Rx查询规定了在事件到达时程序该如何响应。
4、Rx在LINQ基础上构建，增加了一些功能强大的操作符，作为扩展方法。
5、转换.NET事件，subscribe、SubscribeOn（控制订阅和退订的上下文）
6、事件是Rx流数据的主要来源。
7、发通知给上下文，ObserveOn，把通知转移到一个Rx调度器上。
8、用窗口和缓冲对事件分组，Buffer和Window。Buffer等待组内的所有事件，然后把所有事件作为一个集合发布。Window用同样的方法进行分组，但它是在每个事件到达时就发布。限流（throttling）
9、Rx尽量做到了线程不可知（thread agnostic）
10、用限流和抽样抑制事件流。Throttle和Sample。Throttle建立了一个临时窗口，超时期限可以设置（常用于文本框自动填充场合）。Sample建立了一个有规律的超时时间段，每个时间段结束时，它就发布该时间段内最后一条数据。标准LINQ的Where操作符
11、超时，单一的异步操作（如，等待Web服务请求的响应）。Timeout在输入流上建立一个可调节的超时窗口。非常适用于异步操作。

第 6 章 测试技巧
1、单元测试两大好处：更好的理解代码。修改代码时更有把握（提前准备，以免以后麻烦）。
2、async方法的单元测试。单元测试框架检测到方法的返回类型是Task，会自动加上await等待任务完成，然后将测试结果标记为“成功”或“失败”。
3、对每个测试进行超时设置很有用。通常将每一个测试的超时参数设置成2秒。
4、预计失败的async方法的单元测试，建议不要使用ExpectedException（更适用于测试某个特定点抛出的异常，而不是整个测试过程中随时抛出的异常）。使用ThrowException
5、对错误处理进行测试，与测试正确的场景一样重要。
6、async void方法的单元测试，要尽最大可能避免这个问题，而不是去解决它。进行代码重构，而不是使用AsyncContext。
7、在async代码中，关键准则之一就是避免使用async void。
8、数据流网格额单元测试，
9、Rx Observable对象的单元测试。SingleAsync操作符返回一个Task<T>对象，该对象在下一个事件到达时完成。SingleAsync可用来做简单的单元测试。
10、Return操作符创建一个只有一个元素的冷序列（cold sequence），可用它来构建简单的存根（stub）。
11、存根代码中另一个重要操作符是Throw，它返回一个以错误结束的Observable对象。
12、用虚拟时间测试Rx Observable对象，允许调用它的程序指定调度器。用TestScheduler可以对时间进行完整地控制。使用虚拟时间立即完成。

第 7 章 互操作
1、用async代码封装Async方法与Completed事件，
2、基于事件的异步模式（EAP），基于任务的异步模式（TAP）
3、在新编写的代码时都要使用HttpClient。只有在维护以前遗留代码时才用WebClient。
4、用async代码封装Begin/End方法。使用TaskFactory类型的一个FromAsync方法。
5、异步编程模型（APM）
6、用async代码封装所有异步操作，
7、用async代码封装并行代码，将并行处理封装进Tesk.Run，并使用await。只能用于UI代码。在服务端很少用并行处理。
8、用async代码封装Rx Observable对象，
9、用Rx Observable对象封装async代码，
10、Rx Observable对象和数据流对象，

第 8 章 集合
1、使用合适的集合对于并发程序来说是必不可少的。
2、不可变集合是永远不会改变的集合。多个线程访问是安全的。
3、线程安全集合混合使用了细粒度锁定和无锁技术，以确保线程被阻塞的时间最短。
4、对很多线程安全集合进行枚举操作时，内部创建了该集合的一个快照（snapshot），并对这个枚举进行操作。
5、生产者/消费者集合是一种可变集合，带有特殊目的：支持（可能有多个）生产者向集合推送项目，同时支持（可能多个）消费者从集合取走项目。
6、不可变栈和队列，ImmutableStack
7、不可变集合采用的模式是返回一个修改过的集合，原始的集合是不变化的。
8、不可变集合非常适用于共享状态，但不适合用来做交换数据的通道。特别是在线程间的通信不要使用不可变队列，可改用生产者/消费者队列，以获得更好的效果。
9、不可变列表，内部是用二叉树组织数据的。让不可变列表的实例之间共享的内存最大化。
10、不可变Set集合，
11、可先快速地以可变方式构建，然后转换成不可变集合。
12、不可变字典，
13、字典是处理应用状态时最普遍又实用的工具。它能用在任何类型的键/值查询。
14、线程安全字典，ConcurrentDictionary<TKey, TValue>，索引语法的功能相对较弱，它不支持根据当前的值进行修改的方法。适合用在需要共享数据的场合，即多个线程共享同一个集合。
15、阻塞队列，BlockingCollection<T>类可用作管道。默认是阻塞队列，
16、阻塞栈和包，
17、异步队列，BufferBlock<T>
18、异步栈和包，AsyncCollection<T>
19、阻塞/异步队列，

第 9 章 取消
1、取消采用协作方式，即可以请求某段代码取消，但不能强制它取消。
2、取消是一种信号，包含两个不同的方面：触发取消的源头和响应取消的接收器。CacellationTokenSource、CancleationToken
3、取消被看作是一种特殊类型的错误。
4、发出取消请求，
5、通过轮询响应取消请求，大多数情况下，只需要把Cancellation传递给下一层就行了。
6、超时后取消，被取消的代码需要监视取消标记
7、取消async代码，
8、取消并行代码，把标记作为参数传入是最好的做法。提高用户体验。
9、取消响应式代码，在代码中释放订阅接口。只有在边界上才引入CancellationToken，以保持代码清晰。
10、取消数据流网格，每一个块都支持取消，可在DataflowOptions中设置。取消一个运行中的块，数据就会丢失。
11、注入取消请求，连接的取消标记。释放已连接的取消标记源。
12、与其他取消体系的互操作，轮询通常用于计算密集型代码，回调函数通常用于其他情况。
13、注意释放回调函数注册。

第 10 章 函数式OOP
1、现代程序需要异步编程，现在的服务器程序必须有更好的可扩展性，用户端程序必须有更好的交互性。
2、异步编程是函数式的（functional）。
3、引入async对异步开发的主要突破，是在异步编程时仍然可以用过程式编程的思维方式思考。
4、异步接口和继承，
5、异步是一种具体的实现方式。对于一个异步方法的定义，可以用异步方式实现，也可以用同步方式实现。
6、可以用await等待的是类，不是方法。
7、异步构造：工厂。构造函数是不能异步的，也不能使用await关键字。将构造函数与一个异步的初始化方法配对使用。
8、主要的依赖注入或控制反转库都不能与异步代码一起使用。
9、异步构造：异步初始化模式。定义一个属性Task Initialization{get;}
10、只要混合类的初始化过程完成了，就能保证它所依赖的每个类型也是经过初始化的。部件的初始化过程中产生的任何异常，会传递给混合类的初始化过程。
11、异步属性，该属性不会用于数据绑定。应该选用其他方案。读取属性时是否启动一个新的异步操作。
12、不要用Result或await把异步代码强制转换为同步代码。很容易造成死锁。
13、对同步代码来说，对外提供状态的属性其语义是非常明确的，但对于异步代码就没有明显正确的语义。
14、异步事件，延期（deferral），用来跟踪异步事件处理器。
15、一般来说，提出一个事件后就不再关心事件处理器何时完成。
16、异步销毁，把销毁看成一个取消请求是Windows平台上的惯例。
17、文件流和套接字在关闭时，会取消所有运行中的读/写过程。

第 11 章 同步
1、主要类型：通信和数据保护
2、局部数据是独立于其他代码的。
3、若果共享的数据只是用来读取的，就不需要同步。
4、数据保护是为了每段代码访问数据时能得到一致的结果。
5、确定“同一时间只运行一段代码”的上下文，就不需要同步。
6、集合，同步的是三个条件：多段代码、共享数据、修改数据。
7、阻塞锁，基本的lock语句就可以很好的处理99%的情况。
8、锁使用的四条重要的规则：限制锁的作用范围；文档中写清锁保护的内容；锁范围内的代码尽量少；在控制锁的时候绝不运行随意的代码。
9、应该把lock语句使用的对象设为私有成员，并且永远不要暴露给非本类的方法。
10、异步锁，SemaphoreSlim（.NET4.5或更高版本）。AsyncLock(低版本)
11、阻塞信号，ManualResetEventSlim。
12、异步信号，信号是一种通用的通知机制。
13、限流，

第 12 章 调度
1、代码必须在某个线程上运行。调度器（scheduler）是一个确定代码运行地点的对象。
2、系统默认的调度器通常是最合适的。
3、调度到线程池，Task.Run（更利于正确编写和日后维护）。例外：单线程单元线程
4、在ASP.NET中，处理请求的代码本身就是在线程池中运行的，强行把它放到另一个线程池通常会适得其反。
5、并行和数据流代码默认在线程池中执行。
6、进行动态并行开发时，要用Task.Factory.StartNew
7、任务调度器，TaskScheduler（它便于移植，使用起来也相对容易）。
8、响应式扩展引入了一个更通用的调度器抽象类：IScheduler。
9、调度并行代码，
10、用调度器实现数据流的同步，

第 13 章 实用技巧
1、初始化共享资源，Lazy<T>，在构造这个类的实例时，用一个工厂委托（factory delegate）进行初始化。通过Value属性使这个实例变得可用
2、


