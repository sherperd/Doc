1、XAML字集：WPF XAML、XPS(XML Pagper Specification) XAML、Silverlight(跨平台的浏览器插件) XAML、WF(Work Flow) XAML。
2、XAML的设计目标是具有逻辑性、易读性而且简单，没有被压缩。
3、WPF使用BAML(Binary Application Markup Language,耳机在脑后应用程序标记语言)。XAML文件编译被转换为BAML，BAML作为资源被嵌入到最终的DLL或EXE程序集中。
4、XML基础知识，http://www.w3schools.com/xml.
5、XAML文档基本框架，
6、WPF应用程序只使用几个元素作为顶级元素：Window、Page、Application。只能有一个顶级元素。
7、WPF使用相对度量系统。
8、XAML解析器会检查用于元素的XML名称空间。
9、通过使用URI格式的名称空间，不同组织就基本不会无意中使用相同的名称空间创建不同的基于XML的语言。
10、名称空间信息使得XAML解析器可找到正确类。
11、XAML通过使用Class特性简化，连接包含应用程序的时间处理程序。Class特性告诉XAML解析器用指定的名称生成一个新类。
12、编译应用程序，界面的XAML被转换为CLR类型声明，这些类型声明与代码隐藏类文件中的逻辑代码融合到一起，形成单一的单元。
13、注意：InitializeComponent()扮演者重要的角色。它调用LoadComponent()方法，从程序集中提取BAML(编译过的XMAL)，并使用它来构架用户界面。
14、命名元素，控件必须包含XAML Name特性。用于帮助集成代码隐藏类。
15、RuntimeNameProperty特性指示哪个属性的值将作为类型的实例的名称(通常使用Name属性)。
16、注意：只要符合几条基本规则，可使用XAML创建任何类型的实例。XMAL创建自定义类。
17、元素的特性设置相应对象的属性。
18、XML特性中的值总是纯文本字符串，但对象的属性可以是任何.NET类型。
19、简单属性与类型转换器，简单灵活。在代码中使用类型转换器，语法有些复杂。
20、注意：XML、XAML区分大小写，类型转换器通常不区分大小写。
21、复杂属性，属性元素语法(property-element syntax)。可添加名称为Parent.PropertyName的子元素。
22、可在嵌套元素内部添加其他标签来实例化特定的类。
23、注意：可为任何属性使用属性元素语法。如果属性具有合适的类型转换器，通常使用更简单的属性-特性方式，会更加简洁。
24、任何XAML标签集合都可用一系列执行相同任务的代码语句代替。
25、标记扩展，一种以非常规的方式设置属性的专门语法。{}。所有标记扩展都由继承自System.Windows.Markup.MarkupExtension基类的类实现。XAML解析器，创建StaticExtension类的一个实例，然后调用ProvideValue()方法获取静态属性返回的对象。最后使用检索的对象设置属性值。
26、附加属性，可用于多个控件但在另一个类中定义的属性。常用于控件布局。包含两个部分的命名语法使用XAML解析器能够区分开普通属性和附加属性。
27、附加属性根本不是真正的属性。实际会被转换为方法调用。
28、DependencyObject类旨在存储实际上没有限制的依赖属性的集合。
29、附加属性是WPF的核心要素。它们充当通用的可扩展系统。
30、嵌套元素，IList接口，IDictionary接口，ContentProperty特性。
31、属性可支持多种类型的集合。需要添加一个标签来指定集合类。
32、注意：如果集合默认为null，需要包含用于指定集合类的标签，以便创建集合对象。如果有一个默认的集合实例且只需要为它填充元素，可忽略这一部分。
33、注意：所有继承自ContentControl类的控件只允许包含的那一的嵌套元素。所有继承自ItemsControl类的控件都允许包含一个条目集合，该集合映射到控件的某些部分(如条目列表或节点树)。所有继承自Panel类的控件都是用来组织多组控件的容器。
34、ContentControl、ItemsControl和Panel基类都是用ContentProperty特性。
35、特殊字符与空白，用实体引用代替那些特殊字符，实体引用是XAML解析器能够正确解释的特定字符编码。
36、注意：只有当使用特性设置属性值时，才需要使用引号字符实体，因为引号用于指示特性值的开始和结束。
37、默认情况下，XAML折叠所有空白。空格、Tab键及硬回车的长字符串将被转换为单个空格。使用xml:space="preserve"特性(是XML标准的一部分)。
38、通过代码设置文本框中的文本，所有空格都将被使用。
39、事件，WPF事件模型依赖于事件。
40、WPF遵循书序：设置Name属性(如果设置)，关联任意事件处理程序，设置其他属性。所有对属性变化作出响应的事件处理程序在第一次设置属性时都会被触发。
41、使用其他名称空间中的类型，将.NET名称空间映射到XML名称空间。xmlns
42、XMAL不支持有参构造函数。且WPF中的所有元素都包含无参构造函数。需要能够使用公共属性设置您所期望的所有细节。XAML不允许设置公共字段或调用方法。
43、在类的构造函数中硬编码信息，并使异常处理变得复杂。更好的方法是使用少许时间处理代码来控制对象，而完全不使用XAML。
44、加载和编译XAML，只使用代码，使用代码和未经编译的标记(XAML)，使用代码和编译过的标记(BAML)。
45、XAML模板被编译为BAML，并嵌入到最终的程序集，编译过的BAML在运行时被提取出来，用于重新生成用户界面。
46、编译WPF，两个阶段的编译处理过程。
47、部分类不包含实例化和初始化控件的代码，这项任务由WPF引擎在使用Application.LoadComponent()方法处理BAML时执行。
48、C#和VB支持CodeDOM模型。
49、使用XMAL文件而不创建任何代码，称为松散代的XAML文件，可在Internet Explore浏览器中直打开。
50、IE只能显示驻留的页面，不能显示单独的窗口。


第 3 章 布局
1、在任何用户界面设计中，有一半的工作是以富有吸引力、灵活使用的方式组织内容。真正的挑战是确保界面布局能够恰到好处的适应不同的窗口尺寸。
2、WPF用不同的容器(container)安排好布局。布局逻辑。非常地址基于坐标的布局。
3、基于类似Web的流(flow)布局。
4、WPF布局原则，WPF窗口只包含单个元素。原因：Window类继承自ContentControl类。
5、布局由您使用的容器来决定。原则：不应显示设定元素(如控件)的尺寸；不应使用屏幕坐标指定元素的位置；布局容器的子元素"共享"可用空间；可嵌套的布局容器。
6、典型用户界面使用Grid面板作为开始。
7、布局过程：测量(measure)和排列(arrange)。
8、通常可通过设置最小窗口尺寸来避免裁剪问题。
9、注意：布局容器不能提供任何滚动支持。滚动由特定的内容空间-ScrollViewr-提供。
10、大多数布局元素(Canvas控件除外)都使用自动布局，并未提供显式定位元素的能力。
11、对齐方式，边距(元素间的空间，左上右下)，
12、为得到正确的控件边距，需要采用一些艺术手段。需要考虑相领控件边距设置的相互影响。尽可能始终如一地保持不同的边距设置，避免为不同的设置不同的值。
13、最小尺寸、最大尺寸以及显式地设置尺寸。将控件限制在正确范围内。
14、使用样式(一种允许重复使用(甚至自动应用)属性设置的特性)，标准化的属性。
15、Border控件，不是布局面板，常与布局面板一起使用。只能包含一段嵌套内容。并为其添加背景或在其周围添加边框。
16、显示边框，必须设置BorderBrush和BorderThickness。Border是装饰元素(decorator)
17、注意：WrapPanel面板是唯一一个不能通过灵活使用Grid面板代替的面板。
18、DockPanel，沿着一条边缘来拉伸所包含的控件。停靠顺序很重要。
19、Grid面板，是将窗口分割成更小区域的理想工具。
20、Grid面板支持三种设置尺寸的方式：绝对设置尺寸方式(最无用的策略)、自动设置尺寸方式(最有用的)、按比例设置尺寸方式。
21、布局舍入(layout rounding)，UseLayoutRounding设置为true。WPF确保布局容器中的所有内容对齐到最近的像素便捷，从而消除了所有模糊问题。
22、WPF会使用反锯齿功能"混合"原本清晰的像素边界边缘。
23、跨越行和列，
24、布局经验，对于一次性的布局任务，使用更小的布局容器(如StackPanel)。标准化布局，Grid
25、分割窗口，分割条由GridSplitter类表示。指导原则：GridSplitter对象必须放在Grid单元格中；GridSplitter对象总是改变整行或整列的尺寸；需为其设置最小尺寸；GridSplitter对齐方式还决定了分割条是水平的还是竖直的。
26、确保将GridSplitter放到正确的单元格中，并设置正确的对齐方式。
27、共享尺寸组(shared size group)，目标：保持用户界面独立部分的一致性。优点：使独立的Grid控件具有相同的比例。
28、共享的列可用于不同的网格中。设置SharedSizedGroup属性即可。共享尺寸并不是全局的。
29、可使用共享尺寸组来同步具有列标题的不同网格。
30、使用Canvas面板进行基于坐标的布局。创建绘图表面。轻量级的布局容器。注意：不能同时使用Canvas.Rigth和Canvas.Left属性。
31、注意：如果与其他元素一起使用Canvas面板，将它的ClipToBound属性设置为true。
32、Z顺序，控制Canvas元素的层叠方式。
33、InkCanvas元素，用于接收手写表输入。包含两个集合：Children、Strokes集合。
34、WPF布局概念，如根据内容改变尺寸、拉伸以及嵌套等。
35、动态内容，组合式用户界面，
36、可使用Visibility属性动态调整各种界面。
37、在窗口排列内容的几个附加功能：特殊容器(ScrollViewer、TabItem、Expander)、Viewbox(内置缩放功能)、文本布局(大块格式化文本布局工具)。


第 4 章 依赖属性(Dependency property)
1、 依赖属性使用效率更高的保存机制，并支持附加功能。如更改通知(change notification)以及属性值继承(在元素树中向下传播默认属性值的能力)。它是动画、数据绑定、以及样式的基础。
2、依赖属性是专门针对WPF创建的。使用普通的.NET属性过程(property procedure)进行封装。
3、注意：只能为依赖对象(继承自DependencyObject的类)添加依赖项属性。
4、字段使用readonly，只能在类的静态构造函数中对其进行设置。
5、注意：属性封装器不是验证数据或引发事件的正确位置。技巧是使用依赖项属性回调函数。
6、依赖属性遵循严格的优先规则来确定它们的当前值。
7、WPF使用依赖项属性的方式，更改通知和动态值识别。依赖属性会和触发受保护的名为OnPropertyChangedCallback()方法。该方法通过两个WPF服务(数据绑定和触发器)传递信息，并调用PropertyChangedCallback回调函数。
8、WPF属性获取最终值(基本值)：默认值，继承而来的值，来自主题样式的值，来自项目样式的值，本地值。(优先级低->高)
9、优点：占用的资源较少。
10、WPF决定属性值的四步骤：确定基本值；如果属性是使用表达式设置的，就对表达式进行求值(数据绑定和资源)；如果属性是动画的目标，就应用动画；与西宁CoreceValueCallback回调函数来修正属性值。
11、依赖属性被硬编码连接到一小部分WPF服务中。
12、共享的依赖项属性，
13、附加属性是一种依赖属性，由WPF属性系统管理，不同之处在于附加属性被应用到的类并非定义附加实行的那个类。
14、创建附加属性时，不必定义.NET属性封装器。附加属性可被用于任何依赖对象。
15、在定义任何类型的属性时，都需要面对错误设置属性的可读性。
16、应用程序试图设置依赖属性，作用过程：CoerceValueCallback方法有机会修改提供的值，或者返回DependencyProperty.UnsetValue，这回完全拒绝修改；接下来酒瓯ValidateValueCallback方法；若前两个阶段都获得成功，会触发PropertyChangedCallback方法。
17、验证通常应该被添加到属性过程的设置部分。
18、验证会带哦函数有一个限制：它们必须是静态方法而且无权访问正在被验证的对象。使用数值强制(coercion
),强制是在验证之前发生的一个步骤，它允许修改数值，使其更加容易被接受，这个回调函数是关联到FrameworkPropertyMetaData对象的方法。
19、CoerceValueCallback回掉函数处理相互关联的属性。
20、确保当以不同的顺序设置属性时不会出错。
21、学习更多WPF内部运行原理最好方法之一是产看WPF基本元素的代码。浏览胆码最好的工具之一是Reflector，可查看依赖属性的定义，浏览初始化它们的静态够走啊函数代码，甚至可分析在类代码中使用它们的方式。


第 5 章 路由事件
1、路由事件具由更强传播能力的事件，可在元素树中向上默冒泡和向下隧道传播，并沿着传播路径被事件处理程序处理。
2、事件路由为在最合适的位置写紧凑的、组织良好的用于处理事件的代码提供了灵活性。
3、内容模型允许使用许多不同的元素构建简单元素，并且这些元素都拥有自己独立的事件集合。
4、路由事件由之都的静态字段表示，在静态构造函数中注册，并通过标准的.NET事件定义进行封装。
5、使用EventManager.RegisterRoutedEvent()方法注册
6、内同元素是可以被放入流文档中单独内容片段。
7、使用RaiseEvent()方法引发事件。
8、保持额外的事件处理代码层，将会有更大的灵活性。
9、路由事件三种方式出现：直接路由事件(direct event)、冒泡路由事件(bubbling event)、隧道路由事件(tunneling event)。
10、通常选择最合适的事件路由层完成这一任务。
11、RoutedEventArgs类。
12、按钮被设计为挂起MouseUp事件。
13、可在代码中关联附加事件，需要使用UIElement.AddHandler方法，而不能使用+=运算符语法。
14、最好确保每个按钮在XAML中都有Name属性设置，从而可以通过窗口类的一个字段访问相应的对象，并使用事件发送者比较引用。或设置Tag属性。
15、隧道路由事件易于识别，都以单词Preview开头。WPF成对定义路由事件。隧道事件总是在冒泡事件之前被触发。
16、将隧道路由事件标记为已处理股，就不会发生冒泡路由事件。两个事件共享RoutedEventArgs类的同一个实例。
17、识别事件的路由策略，通过分析事件的静态字段以编程方式获得相同信息。RoutingStrategy。
18、最重要的事件5类：生命周期事件、鼠标事件、键盘事件、手写笔事件、多点触控事件(仅在Win7中支持)。
19、生命周期事件，Initialized、Loaded、Unloaded.
20、XAML解析器负责调用BeginInit和EndInit方法。
21、创建窗口，会自下而上地初始化每个元素分支。Loaded事件加载元素顺序相反，为所有元素都引发Loaded事件后，窗口就变得可见的，且元素都已被呈现。
22、Closing事件，用户关闭或注销计算机导致应用程序被关闭，不能收到(可使用Application.SessionEnding事件)。
23、InitializeComponent中异常，会在XAML解析器解析也卖弄时抛出异常，与InnerException属性中的原始异常一起被封装到一个没有用处的XAMLParseException对象中。
24、Windows键盘设置，持续按下一个键一段事件，会重复引发按键事件。
25、使用KeyConverter类将Key值转换为更有用的字符串。最好同时处理PreviewTextInput事件(该事件负责大多数验证)和PreviewKeyDown事件。
26、TextBox控件没有提供更好的按键处理。关注数据绑定，通常由绑定对象提供验证，通过异常标识错误，并且非法数据会触发在用户界面中的某个位置显示错误消息。
27、WPF使用层次结构的元素布局实现Tab键切换焦点的顺序。TabIndex，相同值，WPF会使用自动Tab顺序。
28、获取键盘状态，KeyboardDevice。修饰键：Shift、Ctrl、Alt。
29、注意：实现应用程序范围内功能的较好方法是使用WPF命令系统。
30、鼠标输入，MouseEventArgs对象
31、鼠标命中测试，IsMouseOver，IsMouseDirectlyOver，通常用于构建样式触发器，自动修改元素。
32、 鼠标单击，MouseButtonEventArgs对象，ClickCount属性。
33、Windows应用程序对鼠标键的释放时间进行响应(对“up”事件而非“down”事件进行响应)
34、捕获鼠标，Mouse.Capture，并传递恰当的元素以捕获鼠标，直到再次带哦用Mouse.Capture并床底空引用为止。有时用于可被拖放并可以改变尺寸的元素。通过处理元素的LostMouseCapture事件来响应鼠标捕获的丢失。
35、鼠标捕获通常用于短时间的操作，如拖放。注意：改用UIElement类方法，CaptureMouse和ReplaceMouseCapture，只在合适的元素上调用这些方法，唯一限制是不允许使用CaptureMode.SubTree选项。
36、鼠标拖放，System.Windows。DragDrop
37、拖放三个步骤：用户单击元素，并保持鼠标键为按下状态；用户将鼠标移到其他元素上；当用户释放鼠标键是，元素接受信息并决定如何处理接收到的信息。
38、可通过拖放操作交换任意类型的对象。两个应用程序间，ISerializable或IDataObject接口的对象。XmlWriter和XmlReader对象。务必检查System.Windows.Clipboard类。
39、多点触控输入，识别手势，可使用仿真器模拟多点触控输入。基本做法是为计算机连接多个鼠标并安装来Muti-Touch Vista开源项目的驱动程序。
40、多点触控的输入层次，原始触控、操作、内置的元素支持。
41、WPF支持的通用手势：移动(pan)、缩放(zoom)、旋转(rotate)、轻按(tap).
42、原始触控,TouchEventArgs对象。将每个触点都是为单独设备，并为每个独立的设备指定唯一的ID。
43、操作，IsManipulationEnable属性。
44、通过变换对象可采用数学方法改变任何WPF元素的外观。获取ManipulationDelta对象提供的信息，并使用这些系想你配置MatrixTransform。
45、惯性(intertia)，可更逼真、更流畅地操作元素。处理ManipulationInertiaStaring事件。
46、使用会自动应用的行为或使用具有硬编码逻辑的自定义控件。
47、可通过WPF样式和触发器使用声明式标记自动实现许多简单的编程操作。


第 II 部分 进一步研究WPF
第 6 章 控件
1、WPF控件的类别：内容控件、带有标题的内容控件、文本控件、列表控件、基于范围的控件、日期控件。
2、WPF领域，控件被描述为与用户交互的元素--能接收焦点并接受键盘或鼠标输入的元素。
3、Contol类，基础结构：设置控件内容对齐方式的能力；设置Tab键顺序的能力；支持绘制背景、前景和边框；支持格式化文本内容的尺寸和字体。
4、前景旨文本，背景指控件的表面。更强大的对象：Brush对象。
5、自定义按钮外观的每个方面，需要使用模板。
6、确保程序能够根据配置的变化进行更新，需要使用动态资源。Alpha值为0表示完全透明。
7、RGB与scRGB(64位值)，属性相互关联，RGB值和scRGB值之间不呈现线性关系。
8、在XAML中设置颜色，使用颜色名或颜色值。WPF解析器将使用指定的颜色自动创建SolidColorBrush对象。
9、注意:画刷支持自动更改通知。画刷继承自System.Windows.Freezable类。所有可冻结的对象都有两种状态---可读状态和只读状态(或冻结状态)。
10、注意：有些控件不支持BorderBrush和BorderThickness属性。Button对象完全忽略它们。
11、字体，
12、注意：除非字体属性被用于Control类的继承类，否则没有任何意义。
13、字体家族，相关字体的集合。选择字体时，必须提供完整的字体家族名称。
14、文本装饰和排版，TextDecorations和Typography属性,支持更高级的文本控制。TextDecorations提供4中修饰，为文本添加几类线，包括BaseLine、OverLine、Strikethrough和Underline。流文档--用于创建丰富的可读文档。
15、TextBlock元素是Label控件的轻量级版本，对于少量可换行的文本内容。
16、字体继承，字体属性是依赖属性，且依赖属性能够提供的特性之一就是属性继承。能够流经那些根本就不支持相应属性的元素。
17、Background属性不使用属性继承。在UIElement类中，AllowDrop、IsEnabled以及IsVisible属性都使用属性继承。
18、注意：只有将FrameworkPropertyMetadata.Inherits标志设置为true时，依赖属性才支持属性值继承。
19、字体替换，确保选择的字体在用户计算机上已经存在。可将FontFamily属性设置为由逗号分隔的字体选项列表。
20、System.Windows.Media。Forms类的静态SystemFontFamilies集合，可获得在当前计算机上已安装的所有字体的列表。
21、FontFamily对象允许检查其他细节，如行间距和关联的字体。
22、WPF未提供德尔要素之一是字体选择对话框。
23、字体嵌入，首先向应用程序添加字体文件(通常具有.ttf扩展名的文件)，并将Build Action选项设置为Resource。需要在字体家族名称之前添加字符序列"./#"。WPF将“./”字符解释为“当前文件夹“。与XAML打包系统相关内容。需要考虑许可问题。可使用Microsoft提供的免费字体属性扩展实用工具来检查字体的嵌入权限（http://www.microsoft.com/typography/TrueTypeProperty21.mspx）。
24、文本格式化模式，WPF能更清晰地显示文本，在LCD监视器上尤其如此。缺点：较小尺寸的文本，会变得模糊，边缘周围的颜色干扰。TextOptions.TextFormattingMode附加属性（针对较小尺寸文本，小于15），并将其设置为Display(不是标准Ideal)
25、若结合旋转、缩放、改变外观的变换，应总是用WPF的标准文本显示模式。针对GDI风格的优化是在变换之前应用的。
26、鼠标光标，Cursors类，鼠标光标、沙漏光标、手状光标、调整尺寸的箭头光标。Cursor属性的类型转换器能识别属性名称。
27、ForceCursor，父元素可覆盖子元素的光标位置。Mouse.OverrideCursor，覆盖每个元素的Cursor属性。WPF支持自定义光标。.cur光标文件(小位图).ani动画光标文件。Cursor对象不直接支持URI资源语法。为应用程序添加光标文件作为资源，作为可用于构造Cursor对象的数据流检索该资源。Applcation.GetResourceStream().
28、内容控件(content control)，可包含并显示一块内容。可包含单个嵌套元素的控件。只能包含一个子元素。使用单个容器，防止大量内容。
29、Content属性，支持任何类型的对象。两类：未继承自UIElement类的对象(调用控件的ToString方法获取文本)、继承自UIElement类的对象(使用UIElement.OnRender方法在内容控件的内部进行显示)。
30、注意：OnRender方法并不立即绘制对象---只是生成WPF在屏幕上绘图所需要的图形表示。
31、注意：不能直接在布局容器中放置字符串内容。需要使用继承自UIElement的类对字符串进行封装。
32、注意：Windows元素不允许放置到内容控件中。会抛出异常。检查是否为顶级容器。
33、ContentTemplate，创建一个模板，告诉控件如何显示它无法识别的对象。可更加智能地显示非继承自UIElement的对象。可使用各种属性值，将它们布置到更复杂的标记中。
34、对齐内容，
35、WPF内容原则，
36、注意：通过改变控件的内容未必总能获得期望的效果。可应用新的控件模板，该百年控件外观感觉的所有方面。
37、标签，Label控件支持记忆符(mnemonics)---能够为链接的控件设置焦点的快捷键。添加了Target属性，使用指向另一个控件的绑定表达式。
38、标签文本中的下划线指示快捷键(如确实需要在标签中显示下划线，必须添加两个下划线)。所有记忆符都使用Alt键和已经确定的快捷键工作。
39、快捷键字符通常是隐藏的，指导用户按下Alt键。取决于系统设置。
40、 TextBlock元素通过TextWrapping属性支持换行。
41、按钮，所有按钮都支持访问键，与Label控件中的级衣服类似。添加下划线字符来标识访问键。
42、IsCancel，取消按钮，ESC键，触发按钮。IsDefault，接受按钮，Enter键触发。
43、用户依赖快捷键方式，花一些时间在创建的每个窗口中定义这些细节是有意义的。需编写事件处理程序。
44、IsDefaulted属性，可编写出特定类型的样式触发器。
45、GridViewColumnHeader、RepeatButton、ToggleButton，通常不单独使用，通过组合来构建更复杂的控件，或通过继承扩展其功能。RepeatButton构建高级德尔ScrollBar控件。ToggleButton在工具栏中非常有用。
46、CheckBox，RadioButton(GroupName属性)，继承自ToggleButton类。三态，null---表示不确定状态，显示为具有阴影的复选框。
47、GroupBox容器，封装单选按钮，通常约定这么做。显示一条边框和一个用于按钮组的标题。
48、工具提示，是内容控件，可放置任何可视化元素。可改变各种时间设置来控制工具提示的显示和隐藏速度。ToolTip，所有能放到WPF窗口上的元素都可以使用该属性。
49、注意：不要在工具提示中放置与用户进行交互的控件。ToolTip窗口不能接收焦点。Popup控件。
50、用于放置工具提示的策略：根据鼠标的当前位置、根据悬停鼠标的元素的位置、根据另一个元素(或窗口)的位置、使用偏移、使用绝对坐标、使用运行时的计算结果。
51、设置ToolTipService属性，可配置显示工具提示的相关延迟时间。ToolTipService属性值是不能继承的。
52、Popup控件，永远不会自动显示。
53、Run元素用于格式化TextBlock控件中的你特定部分----一块流内容。
54、注意：可使用触发器显示和隐藏Popup控件---触发器是当特定属性遇到特定值是会自动发生的动作。
55、特殊容器，较复杂的：ScrollViewer，提供了虚拟界面，允许用于围绕更大的元素滚动。通常用来封装布局容器。
56、让大量内容那个适应有限的空间，滚动是重要的特性之一。
57、注意：具有隐藏滚动条的内容仍然是可滚动的(可使用方向键滚动内容)。自定义滚动按钮，仅使用Hidden值，临时组织ScrollViewer控件执行任何操作，只能使用Disabled。
58、ScrollViewer控件最奇特的特征是允许其包含的内容参与滚动过程。
59、StackPanel类对象IScrollInfo接口的是吸纳使用逻辑滚动，从元素滚动到元素，而不是逐行滚动。
60、GroupBox，常用来对数量不多的相关控件进行分组。具有圆角和标题的边框。
61、TabItem，表示TabControl控件中的一页。IsSelected，指示选项卡(tab)当前是否显示在TabControl控件中。
62、Expander，封装了一块内容，通过单击小箭头按钮可显示或隐藏所包含的内容。在线帮助以及Web页面经常使用这种技术。
63、WPF鼓励使用流式布局模型，可很方便地处理会大幅度增大或缩小的内容区域。
64、使用WPF中的模板系统，可完全自定义扩展和折叠箭头。
65、处理展开问题的策略：为窗口设置最小尺寸；设置窗口的SizeToContent属性；通过硬编码Expander控件的Height和Width属性来限制其尺寸；使用ScrollViewer控件创建可滚动的扩展部分(需)。
66、Grid和Expander控件不能很好地集成，不能正常更新行高。
67、文本框能够包含的内容是有限的。RichTextBox控件可存储更复杂的内容，可包含复杂元素组合的FlowDocument对象。可检查LineCount属性准确地获取文本框中共有多少行。
68、文本框，AcceptsReturn、AcceptsTabs。选择文本，SelectionStart，SelectionLength，SelectedText。SelectionChanged对文本选择变化加以响应。AutoWordSelection。Undo。代码操作文本框中的文本时，可使用BeginChange()和EndChange()方法将一系列动作合并起来；可在单个步骤中将这些操作撤销。
69、拼写检查，SpellCheck。是WPF特有的功能。拼写检查根据为键盘的输入语言来决定使用哪个词典。Language(xml：lang特性)，只局限于4种语言：英语、西班牙语、法语和德语。词典文件，具有.lex扩展名的文本文件，#地区ID。
70、PasswordBox，内部只是用System.Security.SecureString对象(纯文本对象)。内存中的存储方式，以加密方式在内存中保存。密钥是随机生成的，存储在一块从来不会写入到磁盘的内存中。当控件爱你呗销毁时，PasswordBox控件会自动为保存在内存中的SecurityString对象嗲偶用Dispose方法。
71、列表控件，ItemsControl类，所有基于列表的控件都使用的基本功能。提供了填充列表项的两种方式。Items集合，在WPF中使用数据绑定的方式更普遍(将ItemsSource属性设置为希望显示的具有数据项集合的对象)。
72、选择器：ListBox、ComboBox、TabControl；具有跟踪当前选项(selectedItem)或其位置(SelectedIndex
)。封装列表项，以不同的方式选择列表项，用于菜单、工具栏以及树的类。
73、注意：ListBox，SelectionMode，Multiple、Exctended(Ctrl、Shift)。SelectedItems集合。
74、注意：阅读有蓝色背景的黑色文本比较困难。可使用数据模板解决。
75、SelectedItem或SelectedItems属性(查找当前项)，RemovedItems，AddedItems。
76、使用嵌套对象，有一项技术可为特定的对象检索ListBoxItem封装器。使用常被忽视的ContainerFromEement方法。
77、ComboBox和ListBox类之间的重要区别是它们在窗口中呈现自身的方式。它使用下拉列表，意味着只能选择一项。在组合框中通过输入文本选择一项(IsEditable，且确保选项集合中存储的是普通的纯文本ComboBoxItem对象)。局限：改变尺寸，需为Width提供硬编码值。
78、基于范围的控件，ScrollBar、ProgressBar、Slider。继承自RangeBase类。工作方式有很大的区别。Value是双精度浮点数(ValueChanged事件)。不必直接使用ScrollBar控件。
79、Slider，偶尔用到。ProgressBar，指示长时间运行任务的进度(甚至可能不知道任务需要执行多长时间)，不能与用户进行交互。IsIndeterminate，周期性地显示从左到右跳动的绿色脉冲门通用Window约定，表示工作正在进行中。状态栏中使用。
80、日期控件，Calendar和DataPicker(占用空间少)。长日期通常包含月份和天的名称。DisplayDateChanged事件(浏览到新的月份时触发)。CalendarOpened和CalendarClosed事件，DateValidationError事件。当用户打开日历视图会丢弃非法值，可选择填充一些文本以向用户通知发生了问题。


第 7 章 Application类
1、捕获未处理的错误、显示初始化屏幕、检索命令行参数等。
2、处理及注册的文件类型，使应用程序能在同一个地方管理任意数量的文档。
3、程序集资源，每个资源是一块可嵌入到编译过的应用程序中的二进制数据。资源成为非常好的存储库。
4、应用程序的生命周期，Web中运行，XBAP(XAML Browser Application).，使用相同的Application类，引发相同的生命周期事件，并采用与基于窗口的标准WPF应用程序相同的方式使用程序集资源。
5、Application标签。StartupUri，XAML文档(已编译过，并作为BAML资源被其纳入到应用程序集中)。
6、URI系统是在应用程序中引用资源的通用方法。
7、应用程序的关闭方式：OnLastWindowClose、OnMainWindowColse、OnExplicitShutdown。
8、调用Shutdown方法会导致Run方法立即返回，单仍客人继续运行Main方法中的其他代码或相应Exit事件。
9、注意：将ShutdownMode设置为OnMainWindowClose，且关闭了主窗口，Application对象将在Run方法返回之前自动关闭其他所有窗口。
10、应用程序事件，Startup(检查命令行参数，通过StartupEventArg.Args数组提供)、Exit(不能取消关闭，但可重新启动应用程序)、SessionEnding、Activated、Deactivated、DispatcherUnhandledException(不处理异常，设置Handled为true，继续运行应用程序)。
11、重写应用程序时，首先调用基类的实现。不是使用消息框，而应该显示几个确认对话框。
12、Application类的任务，显示初始化界面、处理命令行参数、访问当前的Application对象(在窗口之间进行基本交互)、在窗口之间进行交互、单实例应用程序。
13、WPF应用程序的运行速度快。第一次启动时，会有一些延迟。CLR首先需要初始化.NET环境，然后启动应用程序。
14、WPF提供的简单初始化页面特性：为项目添加图像文件(bmp、png、jpg)；在Solution Explorer中选择图像文件；将Build Action修改为SplashScreen。
15、无法通过显示一系列的多幅图像或动画让初始化界面图形得到更富有想象力的效果。唯一能该百年的细节是初始化界面褪去的速度。
16、结构化特点方式在窗口之间进行交互，保存窗口的引用(使一个窗口可访问另一个窗口)。可选择创建跟踪文档窗口的集合。
17、注意：窗口集合，变化的，Windows集合。
18、单实例应用程序，降低应用程序开销、集中某些特性、基础不同窗口。使用全局mutex对象(OS提供的用于进程间通信的同步对象)，简单，但功能有限。需要能够发现远程服务器，并使用它来传递命令行参数。
19、WPF推荐：使用Windows窗体提供的内置支持，在后台处理杂乱的问题。旧式应用程序类充当了WPF应用程序类的封装器。创建单实例应用程序封装器，添加Microsoft.VisualBasic.dll，从WindowsFormsApplicationBase类继承自定义类。
20、SingleInstanceApplicationWrapper类、ApfApp类、Startup类---构成了单实例WPF应用程序的基础。
21、注意：WPF的未来版本最终会支持单实例应用程序。
22、注册文件类型，Windows注册文件扩展名(.testDoc)，并将其与应用程序相关联。使用Windows资源管理器手动注册或编辑注册表的代码。
23、文件注册任务通常由安装程序执行。
24、Windows User Account Control(UAC，用户账户控制)。三种级别，应用程序使用asInvoke运行级别。requirAdministrator运行级别或highestAvailable，需要创建应用程序清单文件---包含可嵌入到编译过的程序集中的XML块。
25、程序集资源，向项目添加文件，在Properties窗口将Build Action设置为Resurce来添加自己的资源。为更合理地组织资源，可在项目中创建子文件夹，然后使用这些子文件夹组织不同类型的资源。易于更新，只需替换文件并重新编译程序即可。
26、注意：不要设置为Embedded Resource。不要使用Project Properties窗口中使用Resource选项卡(WPF不支持)。
27、单独的资源流使用一下格式命名：AssemblyName.g.resources。可使用反编译公江湖查看资源。ildasm不支持。Reflector支持。
28、检索资源，低级方式是检索封装数据的StreamResourceInfo对象，可通过代码Application.GetResourceStream完成。具体访问
29、GetResourceStream封装了ResourceManager类和ResourceSet类。
30、UnmanagedMemoryStream对象，一次读取一个字节。
31、pack URI，寻址编译过的资源。pack://application:,,,/~(绝对URI)。语法来自XPS(XML Paper Specification，XML页面规范)。三个逗号实际是三个转义的斜杠。
32、当使用绝对URI时，可使用指向程序集资源的文件路径、用于网络共享的UNC路径、Web站点URL以及pack URI。
33、内容文件，可将为编译的文件专门标记为内容文件。WPF声音类不支持程序集资源(技术基础造成，Win32API和媒体播放器)。
34、WPF为程序集添加了AssemblyAssociatedContentFile特性，公告每个内容文件的存在。
35、本地化，WPF中，本地化的划分并不细致，而将XMAL文件作为本地化单元。WPF是根据驻留用户界面的线程的CurrentUICulture属性作出决定的。
36、.NET使用附属程序集(satellite assemblies).本地化程序的挑战在于整个工作过程--如何从项目中提取XAML文件。
37、建议原则：不硬编码的宽度和高度；将Window.SizeToContent设置为Width、Height或WidthAndHeight；使用ScrollViewer控件封装大量文本。
38、本地化通常涉及第三方翻译服务，使用服务对原始文本进行处理。管理本地化过程的方法。LocBaml命令行工具。
39、为本地化准备标记元素，添加专门的Uid特性(MsBuild可自动完成)。提取可被本地化的内容。生成附属程序集。
40、并不是所有能够本地化的内容都被定义为用户界面中的本地化属性。使用XAML资源。


第 8 章 元素绑定
1、数据绑定是一种关系。目标属性始终是依赖属性。依赖属性具有内置的更改通知支持。
2、引用附加属性，在一个类中定义但应用于绑定元素的属性，需要在圆括号中封装属性名称。
3、绑定表达式。绑定错误，WPF不会引发异常来通知于数据绑定相关的问题，WPF输出了绑定失败细节的跟踪信息(Output窗口)。绑定模式，双向绑定，需要更大的开销。
4、OneWayToSource，设置非依赖项属性的属性，前提是提供数值的属性本身是依赖项属性。
5、明确设置绑定模式永远不是坏主意。
6、基于标记的绑定更清晰且需要完成的工作更少。
7、代码绑定，创建动态绑定；删除绑定，创建自定义控件。
8、代码检索绑定，两种方式：BindingOperations.GetBinding来检索相应的Binding对象；GetBindingExpression，ResolvedSource属性。
9、多绑定，可链接绑定，但更清晰的方法是应当尽可能地将元素直接绑定到它们使用的数据。
10、可使用Binding对象的UpdateSourceTrigger属性立即进行更新。
11、在何处放置绑定表达式是由编码模型的逻辑决定的。
12、绑定更新，从目标到源---未必会立即发生，行为由Binding.UpdateSourceTrigger属性控制(PropertyChanged\LostFocus\Explicit\Default)。大多数属性的默认行为是PropertyChanged，但TextBox.Text属性默认行为是LostFocus。
13、PropertyChanged更新模式会使应用程序的运行更缓慢，可能会导致源对象在编辑完成之前重新更新自身。可能引起验证问题。
14、绑定延迟，Delay属性。
15、绑定到非元素对象，唯一的要求是显示的信息必须存储在共有属性中。需要放弃ElementName属性，使用：Source(指向源对象的引用)、RelativeSource(引用)、DataContext(将同一个对象的多个属性绑定到不同的元素时)。
16、获取数据对象：资源中提取数据对象、通过编码生成数据对象、数据提供程序的帮助下获取数据对象。
17、Source,指向一些已经准备好了的静态对象；绑定到先前作为资源创建的对象。
18、RelativeSource，根据相对目标对象的关系指向源对象。绑定到自身或其父元素。使用属性设置语法而不是使用Binding标记扩展。Self、FindAncestor、PreviousData、TemplateParent。控件模板和数据模板。
19、DataContext，注意：如果使用Source属性创建明确标识源的绑定，元素就会使用源而不会使用可能得到的任何数据上下文。


第 9 章 命令 
1、事件是非常低级的元素。功能被划分为一些高级的任务。可通过不同的动作和用户界面元素触发，包括主菜单、上下文下单、键盘快捷键以及工具栏。
2、在WPF中，可定义这些任务---命令---并将控件连接到命令，不需要重复编写事件处理代码。
3、命令模型还为存储和本地化命令的文本标题提供了一个中心场所。局限性：缺少命令历史，以及不支持应用程序范围内的撤销特性。
4、设计良好的Windows应用程序中，应用程序逻辑不应位于实际爱你处理程序，而应在更高层的方法中编写代码。其中的每个方法都代表单独的应用程序“任务”
5、WPF模型，两个重要特性：将事件委托到适当的命令；使控件的启用状态和相应命令的状态保持同步。
6、WPF问题：命令跟踪、“可撤销的”命令；具有状态并可处于不同"模式"的命令。
7、WPF命令模型，由许多可变得部分组成。4个重要元素：命令(任务--不包含执行应用程序任务的代码)、命令绑定、命令源、命令目标。
8、ICommand接口(命令模型的核心)，
9、当命令状态改变时引发CanExecuteChanged事件。指示信号，应调用CanExecute方法检查命令的状态。可用，命令源可自动启用自身，命令不可用，禁用自身。
10、RoutedCommand，是WPF中唯一实现了ICommond类。不包含任何应用程序逻辑，各个RoutedCommand对象具有相同的功能。
11、使用预先构建命令的有蒂娜：为继承提供了更好的可能。命令是WPF可插入体系架构的主要部分之一。
12、RoutedCommand，增加InputElement参数，三个属性：命令名称、包含命令的类(OwnerType)、任何可用于触发命令的按键或鼠标操作(InputGestures集合中)。
13、RoutedUICommand类，用于具有文本的命令。只增加了Text属性，为命令显示的文本。
14、命令库，超过100条。5个专门的静态类的静态属性提供：ApplicationCommands、NavigationCommands、EditingCommands、ComponentCommands、MediaCommands。
15、单独的命令对象仅是一些标志器，不具有实际功能。额外特征：默认输入绑定。
16、执行命令，命令绑定将执行转发给普通的事件处理程序。
17、触发命令，将它们关联到实现了ICommandSource接口的控件，其中包括继承自ButtonBase类的控件、单独的ListBoxItem对象、HyperLink以及MenuItem。三个属性：Command(必需)、CommandParameter、CommandTarget。
18、命令绑定，将命令关联到命令源时，命令源将会被自动禁用(按钮查询了命令的状态，且命令还没有与其关联的绑定)。三件事：当命令被触发时执行什么操作；如何确定命令是否能够被执行；命令在何处起作用。
19、习惯上为窗口添加所有绑定，但CommandBindings属性实际是在UIElement基类中定义的(任何元素都支持该属性)。
20、若在多个窗口中使用相同的命令，需要在这些窗口中分别创建命令绑定。
21、窗口应酌情将其工作委托给其他组件。
22、VS没有为定义命令绑定提供任何设计时支持。对连接控件和命令的支持也较弱。
23、微调命令文本，两种技术重用命令文本：直接从静态命令对象中提取文本(只能调用命令对象的ToString方法)。使用数据绑定表达式。
24、在创建了命令绑定后改变命令文本，不会产生人恶化效果。
25、直接调用命令，目标元素是WPF开始查找命令绑定的地方。
26、禁用命令，
27、WPF命令模型不支持更新复选框按钮的用户界面状态。
28、具有内置命令的控件，
29、ToolBar类提供了一些内置逻辑，可将其子元素的CommandTarget属性动态设置为当前具有焦点的控件。ToolBar控件有单独的焦点范围(focus scope)，且在其上下文中按钮是具有焦点的。
30、ToolBar和Menu，默认将FocusManager.IsFocusScope设置为True。
31、三种方法禁用内置命令，控件提供用于关闭命令支持的属性；添加新的CanExecute事件处理程序，并总响应为false(不完美)；使用InputBinding集合删除触发命令的输入(NotACommand, 什么也不做)。
32、类绑定，class binding。
33、高级命令，
34、自定义命令，实例化一个新的RoutedUICommand对象。遵循WPF库中的范例，通过静态属性提分工自定义命令。使用，需要将.NET名称空间映射为XML名称空间。
35、在不同位置使用相同的命令，范围(scope)。创建命令绑定，并向多个CommandBindings集合中添加同一个绑定。XAML，需要使用WPF资源。
36、使用命令参数，
37、创建通用的、可重用的Undo特性，需要创建一组全新的“能够撤销的”命令类，以及一个特定类型的命令绑定。
38、设计自己用于跟踪和但转命令的系统，但使用CommandManager类保存历史。
39、CommandHistoryItem类，命令名称；执行命令的元素；在目标元素中被该改变了的属性；可用于保存受影响元素以前状态的对象。
40、内存，限制在历史中存储的项的数量，或使用更加智能(也更加复杂)的方法只存储被改变的数据的信息。
41、为最大限度地利用WPF命令，需要通过Model View ViewModel(MVVM)模式使用扩展了WPF的独立工具包。例子：Prism。


第 12 章 资源
1、WPF资源是一种保管一系列有用对象(如画刷、样式、模板)的简单方法，从而使您可以更容易地重用这些对象。
2、对象资源也是重用WPF样式的基础。
3、注意：程序集资源是一块嵌入到编译过的程序集中的二进制数据。对象资源是希望在某个位置定义并在其他几个位置重复使用的.NET对象。
4、资源基础，优点：高效、可维护性、适应性。
5、资源集合，每个元素都有Resources属性，该属性存储了一个资源字典集合(ResourceDictionary类的实例)。可包含任意类型的对象，并根据字符串编写索引。
6、通常在窗口级别定义资源。
7、使用资源，标记扩展，动态资源，静态资源。
8、资源的层次，XAML解析器遇到他不知道的资源静态引用时，会抛出异常。可使用动态资源避免问题，但没必要增加额外的开销。
9、只要不在同一个集合中多次使用相同的资源名，就可以重用资源名称。使用找到的第一个资源(从自己的资源集合开始找)。
10、静态资源(只从资源集合中获取对象一次)和动态资源(每次需要对象时都会重新从资源集合中查找对象)。
11、Brush类继承自Freezable类，它有一个基本的变化跟踪特性(如不需要改变，能被“冻结”为制度状态)。
12、一般规则(使用动态资源)：资源具有依赖于系统设置的属性；准备通过编程方式替换资源对象。
13、注意：极少数情况下，动态资源用於提高第一次架子啊窗口时的性能。静态资源总是在创建窗口时加载，动态资源在第一次使用它们时加载。除非资源非常大并且非常复杂(解析资源标记会耗费较长时间)。
14、非共享资源，关闭共享，需使用Shared特性。
15、重用Image元素，更合理的做法是存储相关信息(用于指定图像源的BitmapImage对象)，并子啊多个Image元素之间共享。
16、共享相同的属性，最好使用样式。
17、通过代码访问资源，通过名称从资源集合中提取资源。FindResource方法，TryFindResource。
18、通常在标记中定义资源。
19、应用程序资源，App.XAML中。指导原则：如果对象需要被广泛重用，可使用应用程序资源。如果只在两三个窗口中使用，可考虑在每个窗口中分别定义资源。
20、系统资源，动态资源主要用于辅助应用程序对系统环境变量的变化作出响应。三个类：SystemColors、SystemFonts、SystemParameters。注意：System.Windows名称空间。
21、使用静态标记扩展访问静态属性。
22、注意：资源键不仅是名称---告诉WPFcongnaer查找特定资源的引用。
23、资源字典，多个项目之间共享资源。只是XAML文档，除了存储希望使用的资源外，不做其他任何事情。Build Action-->Page(保证获得最佳性能而将资源字典编译为BAML)。Action-->Resource，被嵌入到程序集中，但不会被编译，在运行时解析它的速度要稍慢一些。
24、使用资源字典，需要将其合并到应用程序某些位置的资源集合中。通常合并到应用程序的资源集合中。定义一个或多个可重用的应用程序"皮肤"。存储需要被本地化的内容(如错误消息字符串)
25、资源集合总是ResourceDictionary对象。不允许合并使用相同资源名称的资源字典。XamlParseException异常。
26、在程序集之间共享资源，可复制并分发包含资源字典的XAML文件(不能对版本进行任何控制)。更有条理的方法是将资源字典编译到单独的类库程序集中，并分发组件。
27、不必手动指定资源，当加载新的资源字典时，窗口的所有DynamicResource引用都会被自动重新评估。
28、使用ComponentResoureKey标记扩展，专门针对这种情况设计的。必须使用动态资源，不能使用静态资源。
29、WPF的资源扩展功能，当使用特定类型的非字符串键名时，会自动引用。
30、generic.xaml文件中的资源被认为是默认主题的一部分，且总是可用的。
31、类引用是WPF允许和其他程序集共享资源的关键部分。
32、对象资源最大的实际用途之一是存储样式--可应用多个元素的属性设置集合。


第 11 章 样式(style)和行为(behavior)
1、样式，组织和重用格式化选项的重要工具。
2、行为，是一款重用用户界面代码的更有挑战性的工具。基本思想L使用行为封装一些通用的UI功能。
3、样式基础，样式是可应用于元素的属性值集合。WPF样式更加强大，能设置任何依赖项属性。支持触发器，可使用模板重新定义控件的内置外观。
4、注意：属性值继承是依赖项属性提供的许多可选的特性之一。
5、在使用资源设置属性时，正确地匹配数据类型是非常重要的。类型转换器和直接设置特性值。
6、通过定义将所有字体细节捆绑在一起的自定义类。然后作为资源创建对象，并在标记中使用它的各种属性。(繁琐的标记)
7、解决方案：可定义独立的用于封装所有希望设置的属性的样式。Style
8、样式通过元素的Style属性插入到元素中。
9、创建更多样式，可在样式级别设置尽可能多的细节。调整用户界面可有更大的灵活性，并使干扰程度降到最低。
10、严格的讲，不要同时使用样式和资源。
11、唯一限制，设置器只能改变依赖属性。
12、WPF极少使用事件设置器这种技术。使用事件触发器，以声明对的方式定义所希望的行为，转为实现动画而设计。
13、多层样式，每个WPF元素一次只能使用一个样式对象。
14、注意：可使用BaseOn属性创建一条完整的样式继承链。
15、样式继承和代码继承存在问题：依赖性使应用程序更脆弱。
16、除非，第二个样式是第一个样式的特例，且只改变了继承来的大量设置中的几个特征。否则不要使用样式继承。
17、通过类型自动应用样式，让设计变得复杂，在具有许多样式和多层样式的复杂窗口中，很难跟踪是否通过属性值继承或通过样式设置了某个特定属性；窗口中的格式化操作在开始时通常更一般，对那会逐渐变得越来越详细。
18、触发器，可自动完成简单的样式改变，而这通常需要使用样板事件处理逻辑。通过Style.Triggers集合链接到样式。
19、以声明的方式扩展代码的功能。
20、Triggers集合，只支持事件触发器。
21、简单触发器，为任何依赖属性关联。指定正在监视的属性，以及正在等待的属性值。
22、触发器是众多覆盖从依赖项属性返回的值的属性提供者之一。
23、触发器在标记中的排列顺序完全决定了最终结果。
24、控件模板锁定了按钮外观的某些特定方面。控件模板经常使用触发器以充分利用这两个特征：可以完全地自定义控件，并且可以响应鼠标悬停、单击以及其他事件来改变它们可视化外观的某些方面。
25、MultiTrigger，它提供了一个Conditions集合。可通过该集合定义一系列属性和值的组合。
26、事件触发器，动作---动画。XAML中，必须在股市板中定义每个动画，故事板为动画提供了时间线。
27、每个动画对象执行本质上相同的任务：在一定时期内修改依赖项属性。
28、DoubleAnimation，在一段给定的时间内将任和双精度数值逐渐改变为设定的目标值。
29、动画行为是一旦动画完成就继续处于激活状态，从而保持最后的属性值。
30、当依赖属性等于某个特定值时也可以执行动画。技巧：不为属性触发器提供任何Setter对象，而是设置Trigger.EnterActions和Trigger.ExitActions属性。有一个动画集合。
31、行为，Expression Blend创作者开发了成为行为(behavior)的特征。创建封装了一些通用用户界面功能的行为。将该空间链接到适当的行为并设置行为的属性.在Expression Blend中,只通过拖放操作就可使用行为。
32、样式，为帮助构建一致的、组织良好的界面。限制，属性设置仅是用户界面基础的一小部分。用于用户界面任务的代码(如驱动动画、实现平滑效果、维护用户界面状态，支持拖放、缩放以及停靠等)。
33、自定义控件，必须作为可视化内容和代码的紧密链接包装进行创建。强大，但不能适应于需要大量具有类似功能的不同控件的情况。
34、获取行为支持，只需手动编写标记。两种选择：可安装Expression Blend 3/4；Expression Blend  3 SDK。
35、重用用户界面代码通用块的结构不是WPF的一部分。它被捆绑到Expression Blend.
36、理解行为模型，行为特性具有两个版本，Silverlight(针对浏览器的富客户端插件)，WPF。
37、WPF触发器支持更加强大的样式和控件模板。Expression Blend触发器支持快速的不需要代码的应用程序设计。
38、指导原则：行为模型不是WPF的核心部分；Expression Blend组件感兴趣，投入；分析Expression Blend提供的功能完整的行为类。第三方组件。
39、创建行为，行为旨在封装一些UI功能。每一个行为都提供了一个服务。
40、Blend中的设计时行为支持。


第 III 部分 图画和动画
第 12 章 形状、画刷和变换
1、普通控件和自定义绘图之间有明显区别。绘图特性只用于特定的应用程序---如游戏、数据可视化和物理仿真。
2、理解形状，shape，专门用于简单的直线、椭圆、举行以及多边形等。绘图图元(primitive).继承FrameworkElement类，形状是元素。形状绘制自身；使用与其他元素相同的方式组织形状；形状支持与其他元素相同的事件。
3、WPF可使用可视化层(visual layer)编程，提高性能。
4、Shape类，Path最强大(能将多个基本形状组合成单独的元素)。
5、当为图形应用动画时，变换特别有用。
6、矩形和椭圆，需要设置Height和Width，然后设置Fill或Stroke属性使形状可见。
7、Grid面板包含了一个按比例改变尺寸的行。改变形状尺寸的行为依赖于Stretch属性的值。
8、如果使用Canvas容器，标签的顺序是很重要的。
9、在可自由流动的动态用户界面中锁定一小部分绘图逻辑，是一种非常好的方法。
10、使用Viewbox控件缩放形状。继承Decorator。只接受一个子元素，并拉伸或缩写子元素以适应可用空间。常用于矢量图像而不是普通控件。
11、Viewbox控件中的形状根据窗口增大的比例改变它们的大小。不能确定最初尺寸。固定尺寸是它的原始尺寸。
12、直线，必须设置Stroke。使用负坐标。缺点：不能使用流内容模型。注意：不能使用Line和Polyline形状创建曲线，需要使用Path。
13、折线，Points属性，PointCollection对象，在XAML中使用基于简单字符串的语法填充该集合。点的列表，并在每个坐标之间添加空格或逗号。
14、多边形，Polygon，添加最后一条线段，将最后一个点连接到开始点。
15、为确定是否填充区域，WPF计算为了到达形状的外部必须闯过的直线的数量。Nonzero(两直线数量的差不为0)填充规则。
16、直线线帽和直线交点，注意：使用Square结束的直线扩展了这一额外的距离。
17、除Line形状外，其他都允许使用StrokeLineJoin属性扭曲它们的拐角。
18、点划线，dash line，StrokeDashArray选择实线段的长度和断开空间(空白)的长度。点划线在线段和空白之间交替其模式。
19、strokeDashCap，注意设置都会在点划线的端点增加直线宽度的一半距离。解决方法是增加额外的空白以进行补偿。
20、像素对齐，WPF将尺寸舍入到最近的设备像素。将SnapsToDevicePixels设置为True，像素对齐(pixel snapping)特性。
21、画刷，填充区域，笔画(stroke)。支持更改通知；支持部分透明；通过SystemBrushes类可访问这样的画刷。
22、通过ImageBrush画刷使用位图填充区域。BMP、PNG、GIF及JPEG。设置ImageSource属性来指定希望使用的图像。
23、通过为ImageSource属性提供DrawingIamge对象，创建由XAML定义矢量内容的ImageBrush画刷。降低开销，或使用矢量图形创建平铺模式。
24、注意：WPF会使用图像中的任何透明信息。支持GIF文件中的透明区域以及PNG文件中的完全透明或半透明区域。
25、Stretch="Uniform"，为适应容器在缩放图像时保持图像的宽高比。
26、可使用Viewbox属性从图像上剪裁有兴趣使用的一小部分。指定4个数值描述从源图像上剪裁并使用的巨型部分(左上角，宽高)。Viewbox使用的是相对坐标系统
27、平铺的ImageBrush画刷，按比例平铺；按固定尺寸平铺。Viewport、ViewportUnits与TileMode属性，决定平铺图像的尺寸和排列方式。
28、自动改变平铺图像的尺寸是一项非常有用的功能，但也要付出代价。
29、VisualBrush画刷，不常用，获取元素的可视化元素，并使用该内容填充任意表面。只是复制了元素的外观。监视元素外观的变化。内容不可交互，赋值其他地方的"真实"内容的静态内容。生动预览效果
30、"真实反射"(live reflection)是WPF中最知名的被过度使用的效果之一。
31、BitmaoCacheBrush画刷，Target属性，采用可视化内容(已经通过变换、剪裁、效果以及透明设置进行了改变)并要求显卡在显存中存储该内容。缺点：渲染位图以及将其赋值到显卡的初始化步骤需要比较短但可察觉到的额外时间。
32、动画会强制窗口在每一秒内重新绘制多次，值得考虑使用位图缓存。CacheMode属性应用缓存，WPF在后台使用BitmapCacheBrush画刷获取相同的效果。
33、变换(transform)，许多绘图任务将更趋简单；通过不加通告地切换形状或元素使用的坐标系统来改变形状或元素绘制方式的对象。
34、所有变换都使用矩阵数学改变形状的坐标。继承自Freezable类，意味着支持自动更改通知功能。
35、倾斜形状、重复形状、动画。
36、变换形状，RenderTransform属性指定位为希望使用的变换对象。根据使用的变换对象，需要填充不同的属性以配置变换对象。
37、RotateTransform的CenterX和CenterY属性存在限制，使用绝对坐标定义的，需要了解绘制内容的中心点的准确位置。RenderTransformOrigin,使用相对坐标系统设置中心点。
38、变换元素，可旋转、扭曲以及缩放WPF用户界面中的任意一部分。
39、LayoutTransform，在布局之前执行其工作。开销更大。为一组空间提供自动布局功能。很少使用，通常使用容器明确地放置形状，而不是使用自动布局。
40、只有很少几个元素不能被变换，它们的呈现工作并非由WPF本身负责。WindowsFormHost和WebBrower。变换不回影响元素的ActualHeight和ActualWidth属性，它们仍记录着变换之前的值。WPF保证流式布局以及外边距继续以相同的方式工作的部分原理。
41、透明，创建透过上面的元素可以看到的图形背景。创建多层动画和其他效果。
42、设置元素的Opacity属性；设置画刷的Opacity属性；使用具有透明Alpha值的颜色。
43、注意：不要过度使用透明特性。
44、透明掩码，OpacityMask，提供了更大的灵活性。可使元素的特定区域透明或部分透明。将形状主键褪色到完全透明。接受任何画刷，画刷的alpha通道确定了什么地方是透明的。设置时，会忽略颜色的其他细节。
45、结合使用OpacityMask和VisualBrush画刷创建反射效果。
46、WPF借助Geometry和Drawing对象，实现绘制效率更高的图形。从其他程序中导出插图。


第 13 章 几何图形和图画
1、Path类能够封装复杂的几何图形。
2、路径和几何图形，功能最强大的形状类。能够包含任何简单形状、多组形状以及更复杂的要素，如曲线。
3、Data属性，接受一个Geometry对象(抽象类)，该对象定义路径包含的一个或多个图形。
4、StreamGeometry，相当于PathGeometry的只读的轻量级类。节省内存，它不在内存中同时保存路径的所有单个分段，且这个类图一旦被创建就不能再修改。
5、几何图形定义形状，而路径用于绘制形状。
6、使用GeometryGroup组合形状，
7、通常，使用数量更少的复杂几何图形元素的窗口比具有大量较简单几何图形元素的窗口的性能要搞。
8、使用CombinedGeometry融合集合图形，专门用于组合重叠到一起并且不相互包含的形状。只使用Geometry1和Geometry2属性。GeometryCombineMode属性。只能合并两个形状。可使用嵌套对象即可。
9、注意：为几何图形应用变换时，使用Transform属性，因为定义了形状，且所有变换总在布局中使用路径之前被应用。
10、使用PathGeometry绘制曲线和直线，PathGeometry强大，但语法比较长。由一个或多个PathFigure对象构建。
11、每个PathFigure对象是一系列相互连接的直线和曲线，可闭合也可不闭合。
12、贝塞尔曲线是每个矢量绘图程序都会创建的要素，它们非常灵活。
13、回线(loop).
14、贝塞尔曲线算法，http://en.wikipedia.org/wiki/Bezier_curve.
15、微语言几何图形，Geometry mini-language，应用于Path元素，也称为路径微语言。M--创建PathFigure，L--创建线段，Z--结束PathFigure(并将IsClosed设置为true)。实际创建了StreamGeometry对象(以后在代码中不能修改图形)。
16、技巧：如果命令的参数值相对于前一个点，而不是使用绝对坐标进行计算，可使用小写的命令。
17、使用几何图形进行裁剪，Clip属性，约束元素的外边界以符合特定的几何图形。通常用于修建Image元素中的图像内容。
18、图画，Drawing，包含显示矢量图形或位图需要的所有信息。
19、GeometryDrawing对象视为矢量插图中的形状。可将标准的窗口元文件格式(.wmf)转换成准备插入用户界面的GeometryDrawing对象的集合。
20、Drawing类用于表示所有类型的2D图形，且还有一小组类继承自该类。
21、显示图画，DrawingImage(在Image元素中驻留图画)、DrawingBrush、DrawingVisual。
22、使用资源分解标记。作为不同资源定义每个DrawingImage或DrawingBrush对象，当需要时就可以引用定义的对象。
23、导出插图，将该内容的某些部分放到资源字典中。存储一个充满DrawingImage对象的字典，或存储一个保存DrawingBrush对象的字典。


第 14 章 效果和可视化对象。
1、可视化对象(Visual);效果(Effect);WriteableBitmap类；
2、像素着色器(pixel shader),修改单个像素。是硬件加速，且有许多已经制作好的效果。
3、图形化科学计算数据。(复杂的数据可视化)。
4、通过使用几何图形、图画和路径，可以降低2D图形的开销。不适合渲染大量图形元素的绘图密集型应用程序。如绘图程序、演示例子碰撞的物理模型程序或横向卷轴形式的游戏。图形元素数量问题。
5、使用低级的可视化层(visual layer)。基本思想：将每个图形元素定义为一个Visual对象，Visual对象是极轻量级的要素，比Geometry对象或Path对象需要的开销更小。
6、绘制可视化对象，DrawingVisual类，RenderOpen方法，返回一个可用于定义可视化内容的DrawingContext对象。绘制完毕后，需要调用DrawingContext.Close方法。
7、DrawingContext类由各种为可视化对象增加了一些图形细节的方法构成。绘制各种图形、应用变换以及改变不透明度等。
8、在元素中封装可视化对象。WPF元素将可视化对象添加到可视化树中。单个元素具有显示任意数量可视化对象的能力。AddVisaulChild和AddLogicalChild之策可视化对象；重写VisualChildrenCount属性并返回已经增加了可视化对象的数量；重写GetVisual方法，当通过索引号请求可视化对象时，添加返回可视化对象所需的代码。
9、在元素中封装可视化对象，最重要：定义可视化对象。
10、通常创建专用的自定义类来封装希望显示的可视化对象。
11、通过一组RadioButton对象，创建一组相互关联的按钮。
12、通过将背景色设置成白色(而不是透明)，可拦截画布表面上的所有鼠标单击事件。
13、在显示可视化对象需要做的工作：渲染可视化对象的代码，以及处理必须的跟踪袭击的容器。交互功能(命中测试)。
14、命中测试(hit testing)，编写代码以截获鼠标单击，并查找位于可单击位置的可视化对象。为DrawingCanvas类添加GetVisual方法(使用一个点作为参数并返回匹配的DrawingVisual对象)。为此使用了VisualTreeHelper.HitTest()静态方法。
15、拖放支持，需要跟踪，三个字段，isDragging、selectedVisual、clickOffset；
16、注意：WPF管理绘图过程，确保按照从GetVisualChild方法返回的可视化对象(顺序是在可视化对象集合中定义的顺序)。
17、复杂的命中测试，可检索位于特定点的所有可视化对象，即使它们被其他元素隐藏在后面也同样如此；还可找到位于给定几何图形中的所有可视化对象。需要创建回调函数。
18、回调方法实现了命中测试行为。
19、效果，目标：是提供一种简便的声明式方法，从而改进文本、图像、按钮以及其他控件的外观。模糊、辉光、阴影等。BlueEffect、DropShadowEffect、ShaderEffect。
20、高级着色着色语言(High Level Shading Language，HLSL)事先制作好的且已经编译过的效果。是Microsoft DirectX的一部分。
21、像素着色器是创建可重用效果的最强大、最灵活的方式。
22、位图效果(BitmapEffect),缺陷：不支持像素着色器；是用非托管的代码实现的；总使用软件进行渲染，不适用显卡资源。
23、BlueEffect，通过失焦透镜观察到的效果。Radius，默认5。
24、一次只能为一个元素应用一个效果。可通过将元素添加到高层的容器中来模拟多个效果(避免使用，降低性能)。应查找能够完成所有内容的单个效果。
25、ShaderEffect类没有提供就绪的效果。抽象类，创建自定义像素着色器。fxc.exe命令行工具，免费的Shazzam工具，编写和编译HLSL代码。编译成.ps文件。
26、图形开发人员。应查找线程的HLSL例子，第三方组件。
27、WriteableBitmap类，适合于需要操作单个像素的应用程序---如分形生成器、声音分析器、科学数据可视化工具，或处理来自外部硬件设备(如网络摄影机)的演示图像数据的应用程序。较复杂。
28、WPF允许使用Image元素显示位图。BitmapSource是只读的位图数据映射，而WriteableBitmap类是可修改的像素数组。
29、生成位图，以像素为单位的宽度和高度、两个方向上的DPI分辨率以及图像格式。
30、像素格式：Bgra32(蓝、绿、红、alpha)；Bgr32；Pbgra32(预先相乘)；BlackWhite、Gray2、Gray4、Gray8(压缩的，不支持颜色)；Indexed1、Indexed2、Indexed4、Indexed8(索引格式)。
31、WritePixels方法,将字节数组复制到指定位置的位图中。CopyPixels方法获取像素。
32、跨距(stride)的计算，是每行像素数据需要的字节数量。
33、更高效的像素写入，使用更大的块。
34、逐像素方法和一次写入策略。理解像素被打包进字节数组的方式，
35、使用WriteableBitmap后台缓冲区以进一步优化代码。
36、像素着色器是将原本设计用于下一代游戏的图形效果融入WPF应用程序。


第 15 章 动画基础
1、创建真正的动态用户界面。动画通常被用于应用效果。可使用声明式的方式创建动画。
2、视屏窗口，一块完全独立的区域---能播放视频，但用户不能与其进行交互。
3、WPF基于属性的动画系统。只有依赖属性使用动态的属性识别系统。
4、基于时间的动画，问题：绘制像素而不是控件；假定单一动画；动画帧率是固定的；复杂动画需要指数级增长的更复杂的代码。
5、基于属性的动画，基于依赖属性基础架构。只不过是在一段时间间隔内修改依赖属性值的一种方式。
6、创建正确动画的秘密在于需要修改什么属性。
7、WPF低级的基于帧的渲染支持。
8、基本动画，
9、引用类型不能应用动画，但它们的子属性可以。
10、Animation类，
11、两种类型的动画：线性插值过程，从一个值突然变成另一个值的动画(关键帧动画)；基于路径的动画(专业)。
12、动画类应通过它们执行的动画类型进行区别。XAML缺少泛型的支持。
13、WPF使用它所需的步长以确保在当前配置的帧率下得到平滑的动画。标准帧率：60帧/秒。
14、BeginAnimation，XMAL声明方式创建动画，"故事板"，"事件触发器"。
15、动画细节：开始值(From)、结束值(To)和整个动画执行的时间(Duration)。
16、注意：每个依赖属性每次只能响应一个动画。、如果开始第二个动画，将放弃第一个动画。
17、创建能够被触发多次，并逐次累加效果的动画；创建可能相互重叠的动画。
18、"鱼眼"效果。
19、By属性，
20、同时发生的动画，BeginAnimation，同时启动多个动画，立即返回。
21、动画的生命周期，
22、WPF动画是暂时的，它们不能真正改变基本属性的值。只是覆盖属性值。
23、创建将元素重新设置为原始状态的动画；创建可翻转的动画；改变FillBehavior属性；当动画完成时通过处理动画对象的Completed事件删除动画对象(常规事件，不是路由事件)。
24、Timeline类，MediaTimeline(播放音频或视频文件)；AnimationTimeline(用于基于属性的动画系统)；TimelineGroup(允许同步事件线并控制它们的播放)。
25、BeginTime数字那个只应用于动画的开始---不延迟反向动画。
26、加速和减速的动画常用于提供更趋于自然的外观。
27、对于构建动画来说，完美的情况是使用设计工具。
28、IsCumulative属性，告诉WPF如何处理每次重复。
29、在所有声明式动画中用到两个要素：故事板(是BeginAnimation方法的XAML等价物)；事件触发器(响应属性变化或事件，并控制故事板)。
30、通过故事板将动画指定到合适的元素和属性。
31、故事板(Storyboard)，是增强的时间线，可用来分组多个动画，且具有控制动画播放的能力。基本功能：使用TargetProperty和TargetName属性指向某个特定属性和特定元素。它在动画和希望应用动画的属性之间架起了一座桥梁。
32、样式提供了一中将事件触发器关联到元素的方法。4个位置定义事件触发器：样式(Styles.Triggers集合)、数据模板(DataTemplate.Triggers)、控件模板(Control.Triggers)、直接在元素中定义事件触发器(FrameworkElement.Triggers)
33、创建事件触发器时，需要制定开始触发器的路由事件和由触发器执行的一个或多个动作。动画，最常用的是BeginStoryboard(相当于调用BeginAnimation方法)。
34、创建当窗口第一次加载窗口时引发的动画，需要在Window.Triggers集合中添加事件触发以响应Window.Loaded事件。
35、设置附加属性，需要在括号中封装整个属性。
36、所有事件触发器都可启动动作。目前，WPF只提供了很少的针对与故事面板进行交互以及控制媒体播放而设计的动作。
37、XAML不支持内联运算。构建能够自动完成工作的IValueConverter接口。在窗口类中创建自定义的依赖属性以执行计算，然后将动画绑定到自定义的依赖属性。
38、FrameworkElement.Triggers集合，仅支持事件触发器。三种基本类型的WPF触发器：属性、数据、事件。
39、重叠动画，HandoffBehavior属性。覆盖(快照并替换)。融合。使用组合的HandoffBehavior行为需要更大的开销(原来动画的时钟不能被释放，手动释放动画时钟(Storyboard.ompeleted事件))。
40、同步的动画，
41、控制播放，
42、注意：停止动画不等于完成动画(除非将FillBehavior属性设置为Stop)。
43、必须在同一个Triggers集合中定义所有触发器。
44、通过BeginStoryboardName属性指定名称，连接到相同的故事板。
45、动态调整速度或位置，唯一的解决办法是使用代码。
46、通过改变顶部图像的透明度，在两幅图之间实现了渐变过滤效果。"擦除"，新图像显示在原图像的上面(为顶部图像创建透明掩码)。
47、监视动画进度，从故事板中检索当前动画时钟相关信息的唯一方式是使用方法。
48、通过Clock对象检索当前时间。
49、动画缓动，
50、线性动画缺点，通常让人觉得很机械且不够自然。高级的用户界面具有模拟真实世界系统的动画效果。
51、粗糙的缺少这些更细微特征的动画会给人留下笨拙的印象。改进动画并创建更趋自然的动画的秘诀是改变变化速率(设计根据某种方式加速或减速的动画)。
52、实现更趋自然动画的最简单方法是使用预置的缓动函数(easing function).
53、在专业的应用程序中会感觉到精致效果。
54、在动画开始时应用缓动与在动画结束时应用缓动。
55、WPF提供11个缓动函数类，EasingMode属性，用于控制是影响动画的开始(EaseIn)、是影响动画的结束(EaseOut)，还是同时影响动画的开始和结束(EaseInOut).
56、试错的体验。资源：WPF文档为每个缓动函数的行为提供了插图示例，显示动画如何随着时间修改属性值。范例程序，尝试不同的属性值。
57、创建自定义缓动函数，继承EasingFunctionBase类，并重载EaseInCore和CreateInstanceCore方法。
58、动画运行期间，每次更新动画的值时WPF都会调用EaseInCore方法。
59、动画性能，涉及视频、大位图以及多层透明等的效果。
60、为用户界面应用动画只不过是创建并配置正确的动画和故事面板对象。
61、降低最大帧率和缓存计算机显卡中的位图，可减轻CPU的负担。
62、期望的帧率，60帧/秒。降低帧率：动画使用更低的帧率看起来也很好，不希望浪费额外的CPU周期；在性能差的CPU或显卡上，效果更高。Timeline.DesiredFrameRate附加属性
63、注意：可使用Perforator工具，评估动画的执行情况及在特定的计算机上WPF是否能够达到60帧/秒。
64、通过读取静态属性RenderCapability.Tier以确定显卡支持的渲染级别。
65、位图缓存，通知WPF获取内容的当前位图图像，并将其复制到显卡的内存中。显卡可控制位图的操作和显示的刷新。这个过程比让WPF完成所有工作要快的多，且和显卡不断通信。
66、在使用位图缓存之前，需要确保真正合适。直到原则：绘制内容需要频繁绘制；尽量少缓存内容。
67、改变元素的内容、布局以及格式将强制重新渲染位图。
68、显存耗尽，WPF将被迫使用更慢的软件渲染。
69、性能分析工具，Perforator。
70、当启用位图缓存时，WPF采用元素当前尺寸的快照并将其位图复制到显卡中。RenderAtScale，解决像素化问题。
71、学习动画艺术了---决定为哪些属性应用动画，以及如何修改它们以便得到所希望的效果。


第 16 章 高级动画
1、指导原则，
2、动态变换，
3、变换提供了自定义元素的最强大方式之一。动画可改变已经存在的变换，但不能创建新的变换。
4、动态改变多个变换，TransformGroup对象设置LayoutTransform或RenderTransform。
5、动态改变画刷，常用，使用恰当的动画类型，深入到希望改变的特定子属性。
6、WPF,有一个有趣的Gradient Obsession的工具，用于构建基于渐变的动画。
7、VisualBrush画刷，可获取任意元素的外观，使用该外观可填充另一个表面。
8、动态改变像素着色器。
9、关键帧动画，由许多较短的段构成的动画。Linear+数据类型+KeyFrame
10、注意：使用关键帧动画不如使用多个连续动画功能强大。
11、离散的关键帧动画，Discrete+数据类型+KeyFrame。
12、缓动关键帧，
13、可创建数学公式指示动画的进度。
14、样条关键帧动画。Spline+数据类型+KeyFrame。创建更加连贯的加速和减速以及更逼真的动画效果。
15、基于路径的动画，动态改变与位置相关的属性时最有用。主要用于帮助沿着一条路径移动可视化对象。
16、注意：基于路径的动画始终以恒定的速度运行。WPF通过分析路径的总长度和指定的持续时间来确定速度。
17、基于帧的动画，只是用代码。响应静态的CompositionTarget.Rendering事件，触发该事件是为了给没帧获取内容。构建简单的侧边滚动游戏、创建基于物理的动画或构建粒子效果模型(如火焰、雪花以及气泡)。
18、一旦关联事件处理程序，WPF就开始不断地调用这个事件处理程序(只要渲染代码的执行速度足够快，WPF每秒将调用60次)。自行管理全部工作。
19、使用代码创建故事板。创建动画和故事面板，并将动画添加到故事板中，然后启动故事板即可。
20、当使用形状，当改变形状不会导致变形，且可修改图画中的单个部分或为其应用动画。
21、Word剪贴画转haunt为XAML，插入到word文档中，将Word文档保存为XPS文件。
22、在单独的用户控件中房子图形，可使得在用户界面中实例化该图形的多个副本更加容易。
23、DispatcherTimer，很好地用于WPF用户界面的计时器，它在用户界面线程触发事件。
24、WPF没有提供任何查找影响给定元素的动画的标准方式。


第 IV 部分 模板和自定义元素
第 17 章 控件模板
1、手工编写绘图逻辑不但非常耗时而且很困难。
2、自定义控件是必需的内容---它们是实现新颖世贸的用户界面的唯一方法。
3、Windows窗体控件类封装了来自Win32 API的核心要素，它们是不能改变的(不是由.NET代码实现的)。
4、理解逻辑树和可视化树，
5、添加的元素分类称为逻辑树。WPF编程人员需要耗费大部分时间构建逻辑树，然后使用事件处理代码支持它们。
6、WPF通过可视化树进入更深层次。它是逻辑树的扩展版本。它将元素分成更小的部分。
7、通过可视化树可完成以下两项非常有用的工作：可使用样式改变可视化树中的元素。可为控件创建新模板。
8、Snoop工具：深入研究可视化树。可检查任何当前正在运行的WPF应用程序的可视化树。放大任意元素。检查路由事件按，分析甚至修改元素属性。
9、控件模板(control template)，是用XAML标记块定义的。每个控件都有一个内置的方法，用于确定如何渲染控件。
10、每个WPF控件被设计成无外观的(lookless)。完全可重定义器可视化元素(元素)，但不能改变控件的行为。
11、模板类型(三种)，控件模板(ControlTemplate)、数据模板(DataTemplate\HierarchicalDataTemplate)、面板模板(ItemsPanelTemplate)。
12、数据模板用于在已有控件的内部添加元素。
13、修饰类，WPF使用哪个程序集取决于操作系统和主题设置。
14、通过编程获取标准控件模板的XAML。基本思想：从Template属性或去控件的模板，然后使用XamlWriter类，将该模板串行化到XAML文件中。
15、反射是用于检查类型.NET API。
16、控件模板的副本会被保存为资源。
17、创建控件模板，
18、内联模板，基本没意义。将控件模板定义为资源，并使用StaticResource引用该资源。
19、所有内容控件都需要ContentPresenter元素---它是表示"在此插入内容"的标记器，告诉WPF在何处保存内容。
20、标准的Windows设置中，下划线是隐藏的，且只要按下Alt键，访问键就会具有下划线。
21、模板绑定，模板可从应用模板的控件中提取一个值。量级更轻，针对在控件模板中使用而设计的。只支持单向数据绑定(控件向模板传递信息)。支持WPF的变化检测基础结构。
22、模板负责检索内边距值并使用该值在内容周围插入额外的空白。
23、改变属性的触发器，
24、使用名称是确保更新模板特定部分的最容易方法。
25、为确保该规则优先于其他相冲突的触发器设置，应当在触发器列表的末尾定义它。
26、样式被限制在一个小得多的范围之内。
27、使用动画的触发器，事件触发器允许控件更通畅地一点点从一个状态改变到另一个状态，从而进一步润色其外观。
28、使用EventTrigger驱动的动画执行的其他任务：显示或隐藏元素(Opacity)；告白你形状或位置(TTranslateransform)；改变光照或着色。
29、高级光照效果使用多层透明元素。
30、组织模板资源，在单独字典资源中定义一个更好的主意。为每个控件模板创建单独的资源字典。使用MergedDictionaries集合完成(使用资源字典)。
31、分解控件模板，资源、控件模板、样式规则。
32、通过样式应用模板，设计存在局限性，控件模板本质上硬编码了一些细节。
33、注意：如果在控件模板和样式中都设置了触发器，那么样式触发器具有优先权。
34、样式不包含控件模板，只是引用模板。
35、自动应用模板，技巧：使用类型样式，它会自动影响相应的元素类型并设置Template属性。
36、包含基于类型的样式的组合的资源字典通常(非正式地)被称为主题。主题能实现非凡的效果。工作：为项目添加资源字典，并将其合并到App.xaml文件的Application.Resources集合中。
37、WPF Fututures版本主题示例，http://tinyurl.com/ylojdry.在应用程序级别导入它们。
38、由用户选择的皮肤，运行时加载新的资源字典，并使用新加载的资源字典代替当前的资源字典。诀窍：检索ResourceDirectory对象，该对象经过编译并作为资源嵌入到应用程序中。
39、注意：使用DynamicResource引用时，首先要保证需要的资源位于资源层次结构中。
40、构建更复杂的模板，为成功地创建控件模板，需仔细查看相关控件的标准模板。
41、嵌套的模板，修改滚动条
42、ScrollBar控件出奇复杂。多部分结构。
43、控件模板示例，SimpleStyles是隐藏的WPF宝藏。
44、可视化状态(visual state)，WPF4中新特性。使用具有特定名称的部件和可视化状态，控件能提供标准化的可视化协定。TemplatePart和TemplateVisualState特性。
45、编写控件模板的方法：混合使用元素、绑定表达式以及触发器。
46、使用动画的事件触发器，编写改变自身以响应输入的控件模板。
47、基于触发器模板确定：需要模板设计人员深入理解控件的工作方式；实现过滤效果，会显得很笨拙。
48、诀窍：结合使用多层形状，每层使用不同的渐变画刷。学习其他人已创建的控件模板示例：http://tinyurl.com/3bk26g;http://msdn.microsoft.com/magazine/cc163497.aspx。


第 18 章 自定义元素
1、以前的Windows开发框架中，自定义控件扮演着中心角色。
2、样式、内容控件、控件模板、数据模板。
3、微调元素的外观时，自定义元素并非最佳选择；希望改变底层的功能时。
4、通常在专门的类库程序集(DLL)中放置自定义元素。Custom Control Library(WPF)
5、常用基类：FrameworkElement、Control、ContentControl、UserControl、ItemsControl/Selector、Panel、Decorator(Border和Viewbox)、特殊控件类。
6、创建基本的用户控件，设计用户控件对外界公开的公共接口(进行交互的属性、方法和事件)。
7、通过用户控件可使用相同的方式组装多个元素。
8、用户控件方法的缺点：限制了自定义的外观。       
9、为支持WPF特性，如数据绑定、样式及动画，控件的可写属性几乎都是依赖属性。step1：为之定义静态字段，并在属性名称的后面加上Property；step2：静态构造函数(注册)；step3:添加标准的属性封装器；
10、记住：属性封装器不能包含任何逻辑。
11、WPF不允许重新进入属性变化回调函数。
12、属性强制回调函数是针对不相关的并且可以相互覆盖或影响的属性设计的。
13、定义路由事件,step1：创建静态属性，并在事件名称的后面添加单词event；step2：静态构造函数(注册)；step3:添加标准的属性封装器；
14、添加标记，命名用户控件(避免在用户控件的标记中命名用户控件，并使用Binding.RelativeSource属性查找元素树，直到找到UserControl父元素)，
15、命令支持，两种方式为自定义控件添加命令支持：添加将控件链接到特定命令的命令绑定；为命令创建新的RoutedUICommand对象，作为自定义控件的静态字段；然后为这个命令对象添加命令绑定。
16、第一次创建控件时是创建命令绑定的最佳时机。
17、两种不同的方式触发命令：用户控件的某个元素具有焦点时，可使用默认的Ctrl+Z组合绑定；也可为客户添加用于触发的命令的按钮。
18、更可靠的命令，使用CommandManager.RegisterClassCommandBinding()方法关联静态的命令处理程序。必须在静态构造函数中创建命令绑定。
19、使用公共CommandBindings集合，问题：比较脆弱。
20、类事件处理程序总在实例事件处理程序之前调用，从而允许开发人员很容易地抑制事件。
21、深入分析用户控件，在后台，UserControl类的工作方式和其父类ContentControl非常类似。区别：UserControl类改变了一些默认值；它应用了一个新的控件模板；改变了路由事件的源。
22、无外观控件是没有标记的---需要的所有内容都在模板中。
23、创建无外观控件，继承自控件基类，但没有设计表面的控件。将其标记放到默认模板中，可替换默认模板而不会影响控件逻辑。
24、用户控件的目标是提供增补控件模板的设计表面，提供一种定义控件的快速方法，代价是失去了将来的灵活性。
25、为通知WPF正在提供新的样式，需要在自定义控件类的静态构造函数中调用OverrideMetadata()方法。需要在DefaultStyleKeyProperty(为自定义默认样式的依赖属性)属性上调用该方法。
26、需要将样式放在名为generic.xaml的资源字典中。必须放在项目文件夹的Themes子文件夹中。该样式会被识别为自定义控件的默认样式。
27、注意：在创建链接到父控件类属性的绑定表达式时，不能使用ElementName属性，需使用RelativeSource属性指示希望绑定到父控件(单向绑定，轻量级的TemplateBinding)。不能再控件模板中关联事件处理程序(需为元素提供能够识别的名称，并在控件构造函数中通过代码为它们关联事件处理程序)。使用“PART_元素名”的形式进行命名，除非关联事件处理程序或通过代码与它进行交互。
28、精简控件模板：添加部件名称，控件模板部件，记录模板部件。
29、WPF控件通过名称定为它们需要的元素。
30、WPF有一个专用的OnApplyTemplate()方法，如果需要在模板中查找元素并关联事件处理程序或添加数据绑定表达式，应重写该方法。
31、查看控件的默认样式，
32、WPF库中的所有控件都为它们的Style属性返回null引用。Style属性是为应用程序样式准备的。
33、支持可视化状态，为模板添加触发器来完成工作。选择部件和状态。
34、为确保最好、最灵活的模板支持，尽可能使用最通用的元素类型。
35、注意：为模板添加VisualStateManager元素，模板必须使用布局模板。布局模板包含控件的两个可视化对象和VisualStateManager元素(不可见)。VisualStateManager定义具有动画的故事板，控件在合适的时机使用动画改变其外观。
36、注意：当使用自定义过度时，仍必须设置VisualTransition.GeneratedDuration属性以匹配动画的持续时间。
37、关联元素，使用OnApplyTemplate()方法。VisualStateManager.GoToState()。
38、创建自定义模板。一种特殊但较常见的自定义控件开发子集。研究示例。
39、两步布局过程，测量阶段(measure pass)，面板决定其子元素希望具有多大的尺寸；排列阶段(layput pass)，为每个控件指定边界。
40、MeasureOverride()和ArraygeOverride()。
41、两步测量过程，Measure()方法，传递总的可用空间；MeasureOverride()，考虑外边距空间。
42、Canvas类的内部工作原理。
43、自定义绘图元素，OnRender()方法，它接收一个DrawingContext对象。
44、一些类需要负责绘制内容，在WPF中，这些类位于元素树的底层。
45、WPF保留模式图形系统的本质----由您定义内容，WPF无缝地管理绘制和刷新过程。
46、重写OnRender()方法不是渲染内容并且将其添加到用户界面的唯一方法。也可创建DrawingVisual对象，并使用AddVisualChild()方法为UIElement对象添加该可视化对象。
47、评估所需图形的复杂程度以及希望提供的交互能力。
48、通过在合适的时间调用InvalidateVisual()方法实现调用OnRender方法。
49、通用规则：切勿在控件中使用自定义绘图。
50、创建自定义装饰元素。继承Decorator类， OnMeasure()方法。
51、学习示例：http://tinyurl.com/9jtk93x;http://tinyurl.com/95sdzgx(基本日期控件和具有内置动画的面板等)。


第 V 部分 数据
第 19 章 数据绑定
1、WPF4.5，VisualizationPanel，提高大列表的性能。用于验证的INotifyDataErrorInfo接口。
2、使用自定义对象绑定到数据库。
3、创建自定义的数据访问组件。
4、构建数据访问组件，将它们编译进单独的DLL组件中。高效维护、优化以及酌情重用数据反复顾问代码并排除错误。
5、创建数据类时，应遵循的基本指导原则：快速打开和关闭连接；实现错误处理；遵循无状态的设计规则；在某个位置保存连接字符串。
6、在数据库中，通过存储过程执行查询。连接字符串不是硬编码的，而是从应用程序的.config文件的应用程序设置中检索得到的。
7、数据访问类使用方式：创建类的一个示例；将类中方法改成静态方法；创建类的单一实例，并通过另一个类的静态属性使用该实例(遵循"工厂"模式)。
8、“调用者通知”(caller inform)，异常处理。
9、数据对象是准备在用户界面中显示的信息包。
10、DataContext属性，为包含所有数据绑定表达式的Grid控件设置该属性，所有绑定表达式都会通过该属性使用数据填充自身。
11、具有null值的绑定，引用类型，如字符串和完整对象，总是支持null值。可预测的：目标元素根本不显示任何内容。可设置TargetNullValue属性来改变WPF对null值的处理方式。
12、TextBox.Text属性在默认情况下使用双向绑定。默认的源更新模式是LostFocus。代码从数据上下文中获取当前Product对象，并使用该对象提交更新信息。
13、显式地强制转移焦点。FocusManager.SetFocusedElement(this，(Button)sender);
14、更改通知，三种方法：将类中的每个属性都改为依赖属性(继承自DependencyObject类)，最合理的做法是将其用于元素----在窗口中具有可视化外观的类；可为每个属性引发事件；可实现INotifyPropertyChanged接口(数据对象)，在属性设置器中引发PropertyChanged事件。注意：可检索BindingExpression对象(使用FrameworkElement.GetBindingExpression()方法)，并调用BindingExpression.UpdateTarget()方法来触发更新(最笨拙的解决方案)。
15、提示：如果几个数值都发生了变化，可调用OnPropertyChanged()方法并传递空字符串，这会告诉WPF重新评估绑定到类的任何属性的绑定表达式。
16、绑定到对象集合，集合绑定需要智能程度更高的元素。在WPF中，所有派生自ItemsControl的类都能显示条目的完整列表。支持集合数据绑定的元素：ListBox、ComboBox、ListView和DataGrid、及Menu和TreeView。
17、通过数据模板可以完全控制数据项的显示方式。
18、ItemsControl类的三个重要属性：ItemsSource、DisplayMemberPath、ItemTempalte。
19、基本的IEnumerable接口仅支持只读绑定。如需编辑集合，需要更复杂的基础结构。
20、通过使用GridSplitter控件来调整窗口空间。
21、三种方法解决每个显示项显示：设置列表的DispalyMemberPath属性；重写ToString()方法，返回更有用的信息；提供数据模板。
22、组织文本框被编辑，可将文本框的IsLocked属性设置为true，更好的方法是使用只读的控件。
23、"主-详细信息"显示，父数据对象(通过属性提供相关子数据对象的集合)。使用TreeView控件显示产品的目录列表。
24、普通的.NET对象没有提供任何变化跟踪，可能希望使用ADO.NET的DataSet对象。
25、启用集合更改跟踪，需要使用实现了INotifyCollectionChanged接口的集合。大多数通用集合没有实现该接口，WPF提供了一个使用INotifyCollectionChanged接口的集合:ObservableCollection类。
26、Windows窗体中BindingList集合，实现IBindingList接口，包含的ListChanged事件。
27、绑定到ADO.NET对象，通过DataView对象绑定到列表上。DefaultView属性(默认的DataView对象)。DataView类实现了IBindingList接口。
28、在列表中选择的项不是DataRow对象----而是由DataView对象提供的精简过的DataRowView封装器。DataView中的默认过滤设置隐藏了所有已删除的记录。
29、绑定到LINQ表达式，LINQ示例：http://tinyurl.com/y9vp4vu。IEnumerable<T>接口，没有提供添加和删除项功能，实现需要使用ToArray()或ToList()方法将对象转换为数组或List集合。
30、可在ObservableCollection集合中封装普通集合以获得通知事件。
31、在VS中设计数据表单，首先创建VS数据源，然后在DataSource窗口拖动创建。
32、数据源是定义，通过数据源VS可识别您的后台数据提供程序，并使用数据源的代码生成服务。可创建封装了数据库、Web服务、已有数据访问类或SharePoint服务器的数据源。
33、最常用的选择是创建实体数据模型(entity data model)，实体数据模型是一系列生成类，这些类建立数据库中表的模型，并且可用于查询数据表，在一定程度上与本章使用的数据访问组件类似。
34、实体数据模型优点：可避免编写通过冗长乏味的数据代码。缺点：数据逻辑定制困难。
35、WPF的数据表单功能提供了用于构建数据驱动应用程序的快捷方法。简单的，通常使用于常规的商业应用程序。http://tinyurl.com/d2taskv官方文档。
36、提高大列表的性能，虚拟化、项容器再循环、缓存长度、延迟滚动。
37、良好的数据绑定系统不仅仅需要绑定功能，还需要能够处理超大量的数据而不会严重降低显示速度或消耗大量内存。WPF优化了其列表控件。所有继承自ItemsControl控件都支持。
38、UI虚拟化(UI virtualization),列表仅为当前显示项创建容器对象的一种技术。被硬编码到VirtualizingStakPanel容器，和StackPanel面板的功能类似。
39、ComboBox类使用标准的没有虚拟化支持的StackPanel面板。明确地通过提供新的ItemsPanelTemplate来添加虚拟化支持。
40、TreeView，默认关闭虚拟化支持。早起版本VirtualizingStakPanel面板不支持层次化数据。VirtualizingStakPanel.IsVirtualizing=“true”。
41、注意：如需支持虚拟化的Grid面板，需要从第三方组件供应商那里购买。
42、破坏UI虚拟化支持的因素：在ScrollView中放置列表控件；改变列表控件的模板并且没有使用ItemsPresenter；不使用数据绑定；
43、ItemsPresenter使用ItemsPanelTemplate，它指定了VirtualizingStakPanel面板。
44、使用即时界面创建以填充目录树。使用自己的优化策略。
45、数据虚拟化(data virtualization)，每次只获取一批记录的一种技术。更复杂的技术，它假定检索数据的代价比保存数据的代价更低。WPF没有提供支持。企业级开发人员支持：假装具有所有项的"伪"集合，但直到控件需要数据时才从后台数据源中查询数据。示例，http://bea.stollnitz.com/blog/?p=344
46、VirtualizingStakPanel.VirtualizationMode="Recycling"。提供了滚动性能，降低了内存消耗量。
47、CacheLength和CacheLengthUnit。
48、附加项的缓存用背景来填充。VirtualizingStackPanel将立即显示创建可见项集合。VirtualizingStakPanel将开始在优先级较低的后台线程上填充缓存。
49、延迟滚动(deferred scrolling)，用户在滚动条上拖动滚动滑块时不会跟新列表显示，当释放了滚动滑块时才刷新。IsDeferredScrollingEnabled。
50、VirtualizingStakPanel基于项的滚动(item-based scrolling)。ScrollUnit属性覆盖该行为。基于像素的滚动更加流畅，它允许使用较小的滚动间隔。
51、验证(validation)，是指用于捕获非法数值并拒绝这些非法数值的逻辑。
52、直接在控件中构建验证，这种低级的方法限制了灵活性。
53、WPF提供了能与前面讨论过的数据绑定系统紧密协作的验证功能。验证提供两种方法捕获非法值：可在数据对象中引发错误；可在绑定级别上定义验证。
54、注意：只有当来自目标的值正被用于更新源时才会应用验证---只有当使用TwoWay模式或OneWayToSource模式的绑定时才应用验证。
55、在数据对象中进行验证，优点：总会捕获所有错误。缺点：使数据对象变得更加复杂，且将用于前台应用程序的验证代码深入到了后套的数据模型中。
56、WPF会不加通告地忽略当设置和获取属性时发生的数据绑定错误。借助ExceptionValidationRule验证规则。
57、在复杂系统中，开发人员可构建丰富的商务对象模型而不是简单的数据对象层。
58、ExceptionValidationRule验证规则，是预先构建的验证规则，它向WPF报告所有异常。将它添加到Binding.ValidationRules集合中。System.Windows.Controls.Validation类的附加属性记录下验证错误。WPF采取的三个步骤：在绑定的元素上，将Validation.HasError附加属性设置为true；创建包含错误细节的ValidationError对象，并将该对象添加到关联的Validation.Errors集合中；如果Binding.NotifyOnValidationError属性设置为true,WPF就在元素上引发Validation.Error附加事件。
59、WPF自动将控件使用的模板切换为由Validation.ErrorTemplate附加属性定义的模板。
60、INotifyDataErrorInfo接口，WPF4.5，它还支持其他功能，如每个属性多个错误以及异步验证。只需三个成员。ErrorsChanged事件在添加和删除错误时引发；HasErrors属性返回true或false来只是数据对象是否包含错误；GetErrors()方法提供完整的错误信息。
61、引发一场来提示用户输入错误。WPF提供了两个接口，允许构建报告错误的对象而不会抛出异常，IDataErrorInfo和INotifyDataErrorInfo。目标：用更加人性化的错误通知系统替换未处理的异常。
62、使用私有集合来跟踪代码中的错误。INotifyDataErrorInfo接口要求将错误链接到特定属性。每个属性可以有多个错误。然后使用功能完备的错误对象，将多个错误信息片段绑定在一起，包括文本消息、错误代码和严重级别等详情。
63、为告知WPF使用INotifyDataErrorInfo接口，并通过该接口在修改属性时检查错误，在绑定的ValidatesOnNotifyDataErrors属性必须设为true。
64、通过创建数据对象来综合使用这两种方法：数据对象为某些错误类型抛出异常，并使用IDataErrorInfo或INotifyDataErrorInfo报告其他错误。
65、可使用通知和BindingValidationFailed事件告知用户。
66、自定义验证规则，和应用自定义转换器的方法类似。继承自ValidationRule的类，并为执行验证而重写Validate()方法。
67、验证逻辑的成败通过返回的ValidationResult对象标识。
68、通过将验证规则添加到Binding.ValidationRules集合中来讲之关联到元素。
69、验证总是在转换之前进行。
70、借助于.NET提供的System.Text.RegularExpression。Regex类，使用指定的正则表达式验证字符串。
71、响应验证错误，Error事件是使用冒泡策略的路由事件，可通过在父容器中关联事件处理程序来为多个控件处理Error事件。
72、获取错误列表，遍历元素树，测试每个元素的Validation.HasError属性。
73、显示不同的错误指示符号，
74、错误模板使用的装饰层，装饰层是位于普通窗口内容之上的绘图层。AdornedElementPlaceholder是支持这种技术的粘合剂，它代表控件本身，位于元素层中。问题：没有提供任何有关错误的附加信息。需使用数据绑定提取它们，好方法：使用第一个错误的错误内容，并将其用作自定义错误指示器的工具提示文本。
75、Validation.HasError属性，应用触发器。
76、验证多个值，可通过WPF数据绑定系统使用绑定组(binding group)创建应用这种规则的自定义验证规则。创建继承自ValidationRule类的自定义验证规则，将其附加到包含所有绑定控件的容器上。项级别验证(item-level Validation)
77、绑定组使用事务处理编辑系统，在运行验证逻辑之前需要正式地提交编辑。CommitEdit()方法。单击按钮或当编辑控件失去焦点时运行事件处理程序。
78、数据提供者，可通过数据提供者直接绑定到在标记的资源部分定义的对象。不成熟。
79、作为窗口(或其他一些容器)的资源定义数据对象。基本思想是创建封装器对象，在其构造函数中获取所需的数据。
80、所有数据提供者都继承自System.Windows.Data.DataSourceProvider类。ObjectDataProvider和XmlDataProvider。目标：让用户能在XAML中实例化数据对象，而不必使用事件处理程序。
81、可作为XAML中的资源明确创建视图对象，将控件绑定到视图，并使用代码为视图填充数据。主要用于希望提供应用排序和过滤定制视图的情况。
82、ObjectDataProvider，可从应用程序的另一个类中获取信息。功能：它能创建需要的对象并为构造函数传递参数；调用所创建对象中的方法，并向它传递方法参数；异步地创建数据对象。注意：是专门针对检索数据而设计的，而不是针对更新数据。
83、错误处理：配置ObjectDataProvider数据提供者，使其异步地执行工作。
84、异步支持，IsAsynchronous属性。其他技巧：使用WPF对多线程应用程序的支持，BackgroundWorker组件，得到取消支持和进度报告的优点。
85、异步数据绑定，IsAsync属性(用处很小)。Binding.IsAsync，仍必须等待。
86、WPF提供了基于异步绑定构建的优先绑定功能。可使用优先列表提供几个异步绑定。绑定的放置顺序很重要。
87、XmlDataProvider，提供了一种简捷方法，用于从单独的文件、Web站点或应用程序资源中提取XML数据，并使应用程序中的元素能使用提取到的数据。被设计为只读的，不具有提交数据修改的能力，且不能处理来自其它源(如数据库记录、Web服务消息等)的XML数据。一款专用工具。
88、首次按要定义它并通过设置Source属性将它指向恰当的文件。默认异步加载XML内容。使用XPath，首先确定根节点，然后绑定列表，最后需要关联显示产品细节的每个元素。
89、XPath是一个强大的标准，通过它可从文档中检索感兴趣的部分。使用类似路径的表示方法。
90、


第 20 章 格式化绑定数据
1、数据转换是一个功能强大的可扩展系统，WPF使用数据转换检查数值并转换它们。提供了应用条件格式和处理图像、文件以及其他类型专门内容的能力。
2、使用数据模板可自定义每个项在ItemsControl控件中的显示方式。是富数据表示工具的关键。
3、数据转换，将数值转换为恰当的显示形式，且若正在使用双向绑定，还需要进行反向转换。WPF提供了两个工具：字符串格式化(设置Binding.StringFormat)、值转换器(value converter功能更强大)。
4、StringFormat，使用标准的.NET格式字符串，{0:C}。以{}开头，转义字符串。注意：只有以花括号开头时才需要{}转义序列。只能在一个方向上工作。
5、时间，ISO Sortable标准，yyyy-MM-dd HH:mm:ss。
6、列表ItemStringFormat属性。格式化字符串自动向下传递到每个项获取文本的绑定。
7、值转换器简介，它负责在目标中显示数据之前转换数据源，且(对于双向绑定)在将数据应用回源之前转换新的目标值。它是WPF数据绑定难题中非常有用的一部分。使用方式：将数据格式化为字符串表示形式；创建特定类型的WPF对象；根据绑定数据有条件地改变元素中的属性。
8、创建值转换器，4个步骤：创建一个实现了IValueConverter接口的类；为该类声明添加ValueConversion特性，并制定目标数据类型；实现Convert()方法，该方法将数据从原来的格式转换为显示格式；实现ConvertBack()方法，该方法执行反向变换，将值从显示格式转换为原格式。
9、Parse和TryParse，不能处理包含了货币符号的字符串；解决方法：使用重载版本的System.Globalization.NumberStyles值的Parse或TryParse。
10、使用转换器，将项目名称空间映射到能够在标记中使用的XML名称空间前缀；创建PriceConvert类的一个实例，并将该实例指定给绑定的Converter属性。或在Resourcs集合中创建转换器对象，在绑定中使用StaticResource引用来指向资源中的转换器对象。
11、使用值转换器创建对象，
12、在数据库中的字段存储为字节数据的图片数据，可将二进制数据转换为System.Windows.Media.Imaging.BitmapImage对象，并将该对象存储为自定义数据对象的一部分。
13、Windows窗体应用程序，可使用System.Windows.Binding类的Format和Parse事件。
14、根据应用程序运行的位置，可能无法获得图像；除非图像即将显示，否则使用额外的内存保存图像是没有意义的。包含文件名称，不包含图像文件的完整路径。URI。
15、Image.Source属性期望一个ImageSource对象，且BitmapImage类继承自IamgeSource类。
16、改进：试图加载不存在的文件异常，设置DataContext、ItemsSource或Source属性时接收异常；还可添加能够保存BitmapImage对象的DefaultImage属性(设置默认图像)。
17、应用条件格式化，也可使用样式中的数据触发器、样式选择器以及模板选择器。
18、需要根据绑定的数据对象设置元素中的某个单独属性时，值转换器方法效果最好。容易，且能自动保持同步。
19、数据触发器，仅支持非常简单的测试是否相等的逻辑。优点：可使用它们应用特定类型的格式，且不需要编写任何代码就可以选择效果。
20、样式选择器和模板选择器，最强大的方法。可在目标元素中一次改变多个属性，且可改变项在列表中的显示方法。增加了复杂程度；且若绑定的数据发生变化，为了重新应用样式和模板，需要添加代码。
21、评估多个属性，技巧：用MultiBinding对象代替Binding对象，使用MultiBinding.StringFormat属性定义绑定属性的排列。借助值转换器(必须实现IMultiValueConverter接口，用于保存数值的数组而不是单个值，数组中的顺序与在标记中定义它们的顺序相同)，使用两个源字段完成更富有挑战性的工作。
22、列表控件，WPF提供了充足的格式化选择。大部分都构建进了ItemsControl基类中。定义了支持数据绑定定义以及两个重要格式化特性(样式和数据模板)的属性。
23、注意：ComboBoxItem或ListBoxItem类，不需要包含项的子集合，不需要继承自ItemsControl。
24、注意：Selector类不支持多项选择----ListBox控件通过它的SelectionMode和SelectedItems属性(本质上这是ListBox类为这个模型添加的所有内容)添加了这一支持。
25、列表样式。ItemContainerStyle，为单个项应用样式，列表控件会将其向下传递给每个项。
26、WPF的数据绑定系统自动生成列表项对象。
27、样式本身并不十分有趣，使用附加的触发器，演示就变得更加精彩了。
28、包含复选框或单选按钮的ListBox控件。
29、ContentPresenter元素获取任何最初在项中显示的内容。
30、交替条目样式，通常是通过稍微不同的背景颜色提供的，从而清晰地隔离行。WPF通过两个属性为交替项提供了内置支持：AlternationCount和AlternationIndex。技巧：使用触发器在ItemContainerStyle中检查AlternationIndex值并相应改变格式。
31、样式选择器，构建专门的继承自StyleSelector的类，负责检查每个数据项并选择合适的样式(在SelectStyle()方法中执行)。样式选择过程只执行一次，当第一次绑定列表时执行。可通过处理事件响应特定修改。重新指定样式选择器，
32、有依赖性在编译时灭有加强并且很容易遭到破坏。硬编码查找的值，限制了重用能力。更好的做法：创建使用一个或多个属性的样式选择器，从而指定一些细节。属性值以及样式都作为属性指定。SelectStyle方法使用反射查找合适的属性。
33、数据模板，允许组合使用来自绑定对象的多个属性，并以特定的方式排列它们或显示比简单字符串更高级的可视化表示。是一块定义如何显示绑定的数据对象的XAML标记。两种类型的控件支持数据模板：内容控件(ContentTemplate)和列表控件(ItemTemplate).
34、基于列表的模板特性实际上以内容模板为基础。模板都被用作列表中每项的ContentTemplate模板。
35、数据模板可包含任意元素的组合，还应当包含一个或多个数据绑定表达式，从而提取希望现实的信息。
36、查看数据绑定工作原理的最佳方式是首先分析不适用数据模板的基本列表。
37、在列表中使用Grid对象布局单个项时，可能希望使用SharedSizeGroup属性。可为单行或单列应用该属性，以确保这些行和列为所有的项使用相同的尺寸。
38、分离和重用模板，在资源集合中定义数据模板并赋予键名。如果希望在不同类型的控件中自动重用相同的模板，通过设置DataTemplate.DataType属性来确定使用模板的绑定数据的类型，不需要指定ItemTemplate设置。
39、注意：数据模板不需要数据绑定。不需要使用ItemsSource属性填充模板列表。两种方式：声明方式(XMAL中标记)或以编程方式(ListBox.Items.Add()方法)
40、使用更高级的模板，使用更复杂的控件、关联事件处理程序、将数据转换为不同的表达式以及使用动画。
41、在模板中放置控件，在按钮的Tag属性中存储一些额外的标识信息。通过删除Path属性来获取整个数据对象(优点：使更新列表选择变得更加容易)。
42、实现过滤的一种简单方法是使用数据视图。当单击View按钮时，将选择移动到新的列表项是个好主意。只在选中的项中显示View按钮(涉及修改和替换在列表中使用的模板)
43、改变模板，常用技术：使用数据触发器；使用值转换器；使用模板选择器。
44、数据触发器，局限：不能改变与模板相关的复杂细节，只能修改模板或容器元素中元素的单个属性。触发器只能测试相等----它们不支持更复杂的比较条件。
45、值转换器，检查绑定对象的属性并返回更合适的值。不允许执行动态改变。
46、模板选择器，赋予完全不同的模板。继承自DataTemplateSelector的类。检查绑定对象bing使用您提供的逻辑选择合适的模板。模板选择查找(通过PropertyToEvaluate指定的)属性，且如果该属性和(通过PropertyValueToHighlight)设置的值相匹配，就返回HighlightTemplate模板，否则返回DefaultTemplate模板。
47、模板选择器比样式选择器强大的多，每个模板都具有使用不同布局显示不同元素排列形式的能力。
48、为提高可维护性，不应为单个列表创建过多模板---而应当使用触发器和样式为模板应用不同的格式。
49、模板与选择，
50、Foreground属性使用属性继承。Background属性不适用属性继承，但默认的Background值是Transparent。
51、将模板中部分元素的背景显式绑定到ListBoxItem.Background属性的值。
52、Binding.RelativeSource属性从元素树中查找第一个匹配的ListBoxItem对象。
53、选择与设备像素对齐，将ListBox.SnapsToDevicePixels属性设置为true。确保不适用反锯齿效果。
54、考虑ListBoxItem.IsSelected属性，并设置另一个元素的Visibility属性。使用数据触发器，触发器需要成为只应用到一个容器的样式的一部分。
55、评估的属性在祖先元素中(ListBoxItem),访问它的唯一方法是使用数据绑定表达式。
56、从技术角度看，展开的细节始终存在，只不过是隐藏了而已。为非常长的具有复杂模板的列表使用这种设计，会影响性能。
57、改变项的布局，通过替换列表用于布局其子元素的容器来改变这种布局。设置ItemsPanelTemplate属性。
58、大多数列表控件使用VirtualizingStackPanel面板。确保能高效地处理大量的绑定数据。
59、不应设置新的ItemsPanelTemplate，除非使用类表显示数量适中的数据。
60、ComboBox控件，显示当前选择项的选择框和用于选择项的下拉列表。设置IsDropDownOpen属性来打开或关闭下拉列表。通常显示一个只读的组合框，可使它选择一个项，但不能随意输入自己的内容(IsEditable)。自动完成功能，会在当前文本框的下面显示所有可能项的列表(IsTextSerachEnabled)。提供了SelectionBoxItemTemplate属性(定义了为选择框使用的模板)，只读属性，它自动设置为与当前项相匹配，且不能提供不同的模板；但可硬编码或从窗口的资源集合中检索选择框模板。
61、WPF米有为使用系统跟踪的自动完成列表提供任何功能。如最近使用的URL以及文件列表。
62、使用非文本内容，且IsEditable属性为false，选择框将显示项的精确可视化副本。IsEditable为true，显示选择项的文本形式表示(WPF简单地为每个项调用ToString()方法)；解决方法：设置TextSearch.TextPath附加属性.用户不能与在选择框中显示的内容进行交互。
63、数据模型。
64、数据绑定模型(结合使用值转换器、样式和数据模板)可使用声明的方式完成许多工作。只不过是显示各种类型信息的通用方法。


第 21 章 数据视图
1、数据视图，在后台工作，用于协调绑定数据的集合。可添加导航逻辑并实现过滤、排序以及分组。
2、WPF4.5引入，两个数据绑定技巧：分组和虚拟化；实时成型(WPF如何监视绑定数据的变化并自动更新链接的视图)。
3、View对象，当将集合(或DataTable)绑定到ItemsControl控件时，会不加通告地在后台创建数据视图----位于数据源和绑定的控件之间。
4、数据视图是进入数据源的窗口，可跟踪当前项，且支持各种功能，如排序、过滤以及分组。
5、使用视图对象取决于数据对象的类型。所有视图都继承自CollectionView类，且有两个特殊实现：ListCollectionView和BindingListCollectionView。
6、CollectionView类的工作原理：如果数据源实现了IBindingList接口，就会创建BindingListCollectionView视图(绑定ADO.NET中的DataTable创建)；实现IList接口，会创建ListCollectionView视图(绑定ObservableCollection集合)；实现IEnumerable接口，基本的CollectionView视图。
7、注意：应避免绑定实现IEnumerable接口的，基本的CollectionView视图。对于大量的项和修改数据源的操作(如插入和删除)，性能不佳。
8、检索视图对象，使用System.Windows.Data.CollectionViewSource类的GetDefaultView()静态方法，总返回一个ICollectionView引用。需要根据数据源，将视图对象转换为合适的类。
9、视图导航，控制导航。简单，在窗口类中使用成员变量来保存视图的引用。
10、视图对象，确定列表中的项数(Count属性)，获取当前对象的引用(CurrentItem属性)，当前位置索引(CurrentIndex属性)。
11、默认情况，ItemsControl控件中选择的项和视图中的当前项并不同步。解决方案：无论和时再列表中选择一条记录，都简单地移动到新记录；更简单的方法，将ItemsControl.IsSynchronizedWithCurrentItem属性设置为true。
12、为了编辑使用查找列表，ComboBox控件是一个非常理想的编辑工具。处理关联的表。设置Text属性以绑定到恰当的字段，并使用ItemsSource属性填充选项列表。将低级的唯一ID转换为更有意义的名称，可使用值转换器。
13、以声明方式创建视图。构建CollectionViewSource对象，然后将CollectionViewSource对象绑定到控件。View和Source属性，SortDescriptions和GroupDescriptions属性(镜像了前面介绍过的同名视图属性)。Filter事件，用于执行过滤。 
14、注意：CollectionViewSource不是视图，而是用于检索视图的辅助类(使用GetDefaultView()方法)。
15、注意：SortDescription类不是WPF名称空间中的类。
16、WPF数据绑定为CollectionViewSource对象使用了一种特殊的例外处理方式。当在绑定表达式中使用CollectionViewSource对象时，WPF会要求CollectionViewSoure对象创建视图，然后将视图绑定到恰当的元素。
17、注意：开发人员很少使用不可靠的方法创建不适用代码的数据绑定。
18、使用多视图，最好在标记中定义所以视图，然后使用代码在适当的视图中进行交换。视图是动态变化的，创建多视图就比较合理。
19、过滤、排序与分组，视图跟踪数据对象集合中的当前位置。
20、过滤集合，显示符合特定条件的记录子集。Filter属性设置过滤器，实现有些笨拙(视图期望用户使用Predicate<object>实例，必须使用类型转换代码)。它接受一个Predicate委托(指向自定义的过滤方法)。
21、应当根据其他信息使用动态的过滤器。更复杂的过滤情形，使用不同的策略并创建专门的过滤类。
22、过滤类封装了过滤准则以及执行过滤的回调方法。
23、为希望应用过滤的每个窗口创建单独的过滤类通常更有用。原因是不能将多个过滤器链接在一起。
24、注意：可创建自定义类来实现解决这个问题，如，创建FilterChain类来封装IFilter对象的集合，且为了决定是否排除某个项而为每个IFilter对象调用FilterItem()方法。
25、使用一系列复选框让用户选择应用不同类型的过滤条件是一种常见的约定。
26、可通过将Filter属性设置为null来彻底删除过滤器。
27、过滤DataTable对象，ADO.NET，每个DataTable对象都与一个DataView对象相关联。DataView对象扮演和WPF视图对象相同的角色。RowFilter属性通过字段内容进行过滤，RowStateFilter属性通过行状态进行过滤。通过Sort属性支持排序。DataView对象不跟踪数据集中的位置。提供了用于锁定编辑能力的附加属性(AllowDelete、AllowEdit及AllowNew).通过DataTable.DefaultView属性获取DataView对象。
28、BindingListCollectionView视图不支持Filter属性，提供了CustomFilter属性(本身不能做任何工作---只是接收指定的过滤字符串，并使用这个过滤字符串设置DataView.RowFilter属性)。
29、使用DataView.RowFilter属性非常容易，但有点混乱。需要遵循所有的SQL约定。
30、排序，使用System.ComponentModel.SortDescription对象确定希望使用的字段。每个SortDescription对象确定希望用于排序的字段和排序方向。
31、注意：很少为同一DataView对象使用多个BindingListCollectionView视图，它们会共享相同的过程和排序设置。
32、为应用不同的排序顺序，首先要清楚已经存在的SortDescriptions集合。还可执行自定义排序，但只能用于ListCollectionView视图(提供的CustomSort属性接受一个ICompare对象，它在两个数据项之间进行比较)。
33、分组，根据单个属性值，也可使用复杂的方式进行分组(使用自定义的回调函数)。为CollectionView.GroupDescriptions集合添加System.ComponentModel。PropertyGroupDecription对象。
34、使用值转换器进行分组。
35、使用分组时，列表为每个分组创建了单独的GroupItem对象，且为列表添加了这些GroupItem对象。GroupItem是内容控件，所以每个GroupItem对象都包含一个适当的具有实际数据的容器(如ListBoxItem对象)。显示分组的秘密是个好似话GroupItem元素，使其突出显示。
36、ItemControl通过它的GroupStyle属性，提供了一个GroupStyle对象的集合。它并不是样式，它只是一个简便的包，为配置GroupItem对象封装了一些有用的设置。
37、HeaderTemplate，技巧：当编写绑定表达式时，不能绑定列表中的数据对象，而要绑定到分组的PropertyGroupDescription对象的Name属性。
38、确保用于排序的第一个SortDescription对象基于分组字段即可。
39、范围分组，创建一个类，检查一些信息并为了显示目的而将它放置到一个概念组中。通常用于使用特定范围内的数字或日期信息对数据进行分组。需要提供制转换器。
40、分组和虚拟化，即使控件支持虚拟化，也不会在启用虚拟化时使用。WPF使用新的VirtualizingStackPanel.IsVirtualizingWhenGrouping属性纠正了这个问题。
41、分组数据时会导致速度明显变缓。在实现此设计前需要对应用程序进行性能分析。
42、实时成型，WPF4.5引入。它监视特定属性中的变化。如果发现变化，就确定相应更改会影响当前视图并处罚刷新操作。增加了额外的开销，是否启用要酌情而定。三个独立属性：IsLiveFiltering、IsLiveSorting和IsLiveGrouping。还需告知集合需要监视哪些属性(LiveFilteringProperties、LiveSortingProperties、LiveGroupingProperties)。
43、ICollectionViewSource.Refresh()方法刷新视图，并确保正确的项出现在列表中。
44、要使用实时成型，需要满足以下三个标准：数据对象必须实现INotifyPropertyChanged；集合必须实现ICollectionViewLiveShaping；必须确定启用实时成型(需要设置多个属性)。
45、视图是数据绑定难题的最后一部分。它们是位于数据和显示数据的元素之间的非常有价值的附加层，通过视图可以管理在集合中的位置，且可灵活地实现过滤、排序和分组。


第 22 章 列表、树和网格
1、富数据控件：ListView，继承自ListBox，增加了对基于列显示额支持，并增加了快速切换视图或显示模式的能力，而不需要重新绑定数据以及重新构建列表；TreeView，是层次化容器，可创建多层数据显示；DataGrid，是WPF中功能最为完备的数据显示工具，它将数据分割到包含行和列的网格中，具有其他格式化特性(如冻结列以及设置单行样式的能力)，且支持就地编辑数据。
2、ListView控件，特殊的列表控件，它是专门针对显示相同数据的不同视图而设计的。构建显示每个数据项几部分信息的多列视图。View属性扩展，用于创建内容丰富的列表。
3、ViewBase，只不过是将两个样式捆绑在一起的包。其中一个样式应用到ListView控件(并通过DefaultStyleKey属性加以引用)，另一个样式应用到ListView控件中的项(并通过ItemContainerDefaultStyleKey属性加以引用)。
4、View属性优点：可重用的视图；多视图；更好的组织。
5、WPF目前只提供了视图对象GrigView(继承自ViewBase类)，多列列表。自定义视图。
6、使用GridView创建列，通过GridView.Columns集合添加GridViewColumn对象可定义这些列。
7、非常大的列，将文本封装起来。注意：用户可通过将标题拖拽到新的位置来改变列的顺序。
8、改变列的尺寸，完全禁止改变列的尺寸，唯一选择是为GridViewColumn的标题提供新模板。
9、单元格模板，使用CellTemplate属性，使用数据模板。只能应用于一列。允许文本换行。无法为多个列重用模板，所以必须剪切并粘贴模板，然后修改绑定。
10、注意：如果同时设置了DisplayMember和CellTempalte属性，GridViewColumn会使用DisplayMember属性为单元格设置内容并完全忽略模板。
11、列模板不能被不同的字段重用，所以内联定义方式通常最为清晰。
12、自定义列标题，方法：简单设置GridViewColumn.Header属性。可使用GridViewColumn.HeaderTemplate属性(用自己的内容填充列标题，但不希望为每列单独指定内容)。GridViewColumn.HeaderContainerStyle属性(重用格式化特定列的标题)。
13、创建自定义视图，视图通过重写受保护的属性进行工作：DefaultStyleKey和ItemContainerDefaultStyleKey。主要原因是希望列表能够动态地改变视图。
14、视图类，设计代表自定视图的类。继承ViewBase类。重写DefaultStyleKey和ItemContainerDefaultStyleKey属性。
15、ComponentResourceKey，从DLL程序集中检索共享程序集。它封装了两部分信息：拥有样式的类的类型，衱标识资源的描述性的ResourceId字符串。
16、视图样式，视图模型，通过改变ListView中的单个属性，就可通过两个样式应用到一组相关联的设置。
17、确保能够自动获得样式的技巧是创建名为generic.xaml的资源字典(必须放在项目文件下的Themes子文件夹中)。
18、使用ListView控件，使用自定义视图，只需将ListView.View属性设置为自定义视图对象的实例。
19、为视图传递信息，通过添加当使用视图时使用者可设置的属性，可增加视图类的灵活性。然后样式可以使用数据绑定检索这些数值，并使用它们配置Setter对象。需要替换ControlTemplate的Setter对象。
20、注意：这种向视图传递信息的技术仍然不能帮助用户实现真正的视图，因为无法根据这一信息修改数据模板。
21、TreeView控件，它是Windows最重要的控件之一。WPF完全支持数据绑定。本质上是驻留TreeViewItem对象的特殊ItemsControl控件。TreeViewItem不是内容控件，每个TreeViewItem对象都是单独的ItemsControl控件，可包含更多的TreeViewItem对象。可创建更深层次的数据显示。
22、TreeViewItem类继承自HeaderedItemsControl类(继承自ItemsControl类)，WPF另外两个HeaderedItemsControl类：MenuItem和ToolBar.
23、几乎可为TreeView控件添加任何元素，包括按钮、面板以及图像。如果显示非文本内容，最好使用TreeViewItem封装器，并通过TreeViewItem.Header属性提供内容。显示非UIElement对象，可使用具有HeaderTemplate或HeaderTemplateSelector属性的数据模板设置其格式。
24、创建数据绑定的TreeView控件，设置ItemsSource属性，只能填充TreeView控件的第一层。包含具有某种嵌套结构的层次化数据。
25、数据模板指示不同层次数据之间的关系。
26、技巧：创建通过属性提供另一个集合的集合---是使用WPF数据板顶导航父-子关系的秘密所在.
27、HierarchicalDataTemplate优点：能够封装第二个模板。
28、分解每个数据模板并通过数据类型(而不是通过为止)将之应用到数据对象的情况更加普遍。根据绑定对象的数据类型使用恰当的ItemTemplate数据模板。嵌套很深的结构更松散的树(很有用)。
29、将DataSet对象绑定到TreeView控件，
30、获取相关联的行。WPF数据绑定系统为此提供了内置支持。技巧：使用DataRelation对象名称作为第二层的ItemsSource。
31、即时创建节点(just-in-time node creation)，通过处理Explanded和Collapsed事件即时填充或丢失的节点或丢弃不再需要的节点。
32、TreeView控件经常用于包含大量数据。它的显示是能够折叠的。Explanded事件、Collapsed事件。
33、典型例子：目录浏览应用程序。首先填充部分折叠的视图，并允许用户进入特定目录。当打开每个节点时，相应的目录被添加到树中---这个过程几乎是瞬间完成的。
34、注意：占位符是一个很有用的工具，可用于确定用户是否已经展开了这个文件夹以查看内容。主要用途：确保在项的旁边显示展开图标。
35、处理TreeViewItem.Selected事件，当每次选中一个项时进行刷新。或当添加、刷新或重命名文件夹时，使用组件(System.IO.FileSystemWatcher)等操作系统通知(开销最大，唯一当发生变化时，确保立即更新目录树的方法)。
36、创建高级的TreeView控件，VS示例，使用网格统一管理一颗树。VS帮助中查找索引项"TreeListView sample[WPF]"。Josh Smith的布局实验，将TreeView控件转换为更紧密的更像组织图的元素(www.codeproject.com/KB/WPF/CustomTreeViewLayout.aspx)。
37、DataGrid控件，用来显示数据的控件，从对象集合获取信息并在具有行和单元格的网格中显示信息。基于列的模型提供了显著的格式化灵活性。选择模型允许选择一行、多行或一些单元格的组合。编辑支持非常强大，可使用DataGrid控件作为简单数据和复杂数据的同一数据编辑器。
38、对于自动生成，DataGrid控件使用反射查找绑定对象中的每个公有属性，并为每个属性创建一列。
39、定制DataGrid控件基本外观的属性，用户不能改变行的尺寸。
40、改变列的尺寸与重新安排列。需要提佛那个DataGridLength对象。
41、自动改变尺寸是单向的，所以当离开大的数据时不会收缩列。
42、通常，用户通过将列边缘拖动至任意位置来改变列的尺寸。允许用户定制列的外观。
43、定义列，使用合适的列对象填充DataGrid.Columns集合。支持类型：DataGridTextColumn；DataGridCheckBoxColumn；DataGridHyperlinkColumn；DataGridComboBox；DataGridTemplateColumn。
44、最重要的细节是为列提供恰当信息的绑定表达式，通过设置Binding属性(更灵活---允许使用字符串格式化和值转换器，而不必切换到功能完备的模板列)。
45、DataGridCheckBoxColumn，添加了Content属性(可在复选框旁边显示可选内容)。IsThreeState属性。
46、DataGridHyperlinkColumn，允许显示的文本值各包含单个URL。尽在可单击超链接来触发导航事件的容器(Frame或NavigationWindow)中放置DataGrid控件时，自动导航才能奏效。
47、DataGridComboBox，需要决定如何在编辑模式下填充组合框。从资源中提取数据集合；使用静态标记扩展；从ObjectProvider资源中提取数据集合，然后调用数据访问类；直接在代码中设置DataGridComboxBox.Column属性。
48、可在CategoryID绑定中使用数据转换器.
49、DataGridTemplateColumn，允许定义两个模板：一个用于数据显示(CellTemplate)；另一个用于数据边界(CellEditingTemplate).
50、设置列的格式和样式，ElementStyle属性，EditingElementStyle属性。RowStyle属性。
51、设置行的格式，LoadingRow事件是个非常强大的工具(每一行出现在屏幕上时，立即触发)，它不能放置耗时的代码。
52、想容器再循环，DataGrid控件为显示数据而重用相同的DataGridRow对象。
53、注意：只有加载了行之后，才会应用在LoadingRow事件处理程序中应用的格式。如果编辑行，不会触发LoadingRow代码。
54、显示行细节(row details)，一块可选的独立显示区域，在行的列值下面显示。添加了无法仅使用列实现的两个特征：能跨月DataGrid控件的整个宽度，并且不会切入到独立的列中，从而提供了更多的可供使用的空间；可配置行细节区域，从而置位选择的行显示该区域，当不需要时允许用户折叠额外的袭击。
55、冻结列，位于DataGrid控件的左边，FrozenColumnCount，设置大于0的数。
56、选择，SelectedItem属性。选择多行，SelectionMode(Extended),Shift或Ctrl键(SelectedItems集合)。ScrolltoView()方法，强制DataGrid控件向前或向后滚动，直到指定的项可见。
57、排序，DataGrid内置了排序功能，只要绑定了实现了IList接口的集合，可以自动获得排序功能。单击列题头，执行排序。按Shift键，可根据多列进行排序。可通过设置列的SortMemberPath属性从绑定的数据对象中选择不同属性。DataGridTemplateColumn列，需要使用SortMemberPath属性。CanUserSortColumns属性设置false禁用排序(或列的CanUserSort属性)。
58、编辑，双击DataGrid单元格时，会切换到编辑模式。限制编辑功能方式：DataGrid。IsReadOnly；DataGridColumn.IsReadOnly;只读属性(或不是简单的文本、数字、日期类型)；
59、DataGridTemplateColumn，它允许使用更专业的输入控件替换标准的编辑文本框。
60、为DataGridCell提供的默认ErrorTemplate模板在非法值的周围显示红色外边框。
61、其他方法为DataGrid控件实现验证。选择使用DataGrid控件的编辑事件，事件引发顺序，BeginningEdit、PreparingCellForEdit(用于模板列)、CellEditEnding、RowEditEnding。
62、DataGrid控件在同一位置查看并编辑各种各样的密集数据。


第 VI 部分 窗口、页面和富控件
第 23 章 窗口
1、传统桌面应用程序，窗口是基本的组成要素。窗口模型。
2、基于页面的应用程序。Web(最成功的)，它的一系列应用程序(如站点)运行在浏览器中。Microsoft公司正创建名为Metro的设计框架，使用简化的、便于触控的界面，根本不适用窗口。
3、对于复杂的应用程序、内容创建和业务工具而言，窗口依然是占据主导地位的用户界面。
4、Window类，继承ContentControl类。它只能包含的那个子元素(通常是一个布局控件，如Grid)。将WindowStyle属性设置为None，完全溢出窗口框架，从而创建一个可完全定制的窗口。
5、注意：客户区是创科技边界内部的表面，在其中可放置自定义内容。非客户区包括边框和窗口顶部的标题栏。非客户区由操作系统管理。
6、Window类的基本属性，AllowsTransparency、Icon、Top和Left、ResizeMode、RestoreBounds、ShowInTaskbar、SizeToContent、Title、Topmost(需要浮动在其他窗口之上的调色板)、WindowStartupLoaction、WindowState、WindowStyle。
7、图标具有不同的尺寸，.ico文件应当至少包含一副16x16像素个32x32像素图像。VS中双击Properies节点，选择Application选项卡进行设置。
8、显示窗口，创建Window类的实例，并使用Show()或ShowDialog()方法。
9、模态窗口，通过锁住所有鼠标和键盘输入来组织用户访问父窗口，直到模态窗口被关闭。计时器的事件处理程序仍将运行。
10、当使用非模态窗口时，有时需要同步代码，以确保在一个窗口中的改变能更新另一窗口的信息，防止用户使用无效的信息。
11、不管使用哪种方式隐藏窗口，对于代码来说窗口仍然是打开和可见的。通常，只隐藏非模态窗口是有意义的。
12、定位窗口，可限制窗口的尺寸以使其支持最小的显示器。在运行时决定窗口的最佳位置，需要使用System.Windows.SystemParameters类来检索有关屏幕实际的大小。
13、注意：窗口定位小缺陷，两次窗口移动。解决方法是在窗口创建之后，但尚未通过调用Show或ShowDialog方法显示之前定位窗口。
14、保存和还原窗口位置，可存储到特定于用户的配置文件或Windows注册表。双击Solution Explorer中的Properties节点，选择Settings选项卡，使用System.Windows.Rect数据类型添加用户范围的设置。
15、窗口交互，Application类提供了用于访问其他窗口的两个工具：MainWindow和Windows属性。通用规则：应当尽可能减少窗口之间交互的需要，无谓地增加代码的复杂性。在目标窗口中创建专有方法。并增加额外的间接层，更容易适应窗口接口的变化。
16、提示：可创建具有公共方法的接口来规范化它们之间的交互，并在自定义的窗口类中实现该接口。
17、动作窗口依靠一个更高层的应用程序方法，该方法调用所需的窗口更新方法(可能通过迭代窗口集合来实现)。可在更高层次上工作。动作窗口根本不需要了解接收窗口的任何内容。
18、在窗口之间进行交互时，Window.Activate()方法，可将所期望的窗口转换为活动窗口。可用Window.IsActive属性测试某个窗口是否是活动窗口，以及是否是唯一的活动窗口。
19、进一步降低窗口之间的耦合程度，仅仅触发一个事件，并允许窗口选择如何响应该事件。
20、注意：WPF通过对命令的支持，可帮助抽象应用程序逻辑。命令可按任何喜欢的方式触发的特定于应用程序的任务。
21、窗口所有权，Window类增加了两个属性。Owner属性是指向窗口的引用，OwnedWindows属性是当前窗口拥有的所有窗口的集合。
22、注意：WPF没有提供用于构建多文档用户界面(MDI)应用程序的系统。
23、对话框模型(dialog model)，是为了给用户一些选择。通过在对话框中创建一些公共属性，可跟容地使用这种设计模式。预先准备好的DialogResult属性，true、false、null值。ShowDialog()的返回值。
24、通过将按钮指定为接受按钮(通过将IsDefault属性设置为true)。IsCancel，取消按钮。
25、通用对话框，Windows操作系统提供了许多内置对话框，可通过Windows API访问这些对话框。WPF为其中的几个对话框提供了封装程序。
26、MessageBox、PrintDialog、OpenFileDialog、SaveFileDialog。
27、WPF没有提供颜色拾取器、字体拾取器、文件夹浏览器(可使用.NET 2.0中的System.Windows.Froms类获取)。
28、非矩形窗口，创建精致的、具有专业外观的窗口需要完成更多工作。
29、简单形状窗口，将Window.AllowsTransparency属性设置为true；将Window.WindowStyle属性设置为None(隐藏窗口的非客户区，蓝色边框)；将窗口背景设置为透明或设置为具有透明区域的图像。
30、使用支持透明格式的文件提供背景插图；使用WPF中的形状绘制功能创建具有矢量内容的背景；使用更简单的具有所需形状的WPF元素。
31、注意：WPF可在窗口背景和它下面的内容之间执行反锯齿处理，确保获得整洁流畅的窗口边缘。
32、具有形状内容的透明窗口，
33、移动形状窗口，限制之一：没有属于非客户区的标题栏部分，标题栏允许用户很容易地在桌面上拖动窗口。可通过Window.DragMove()方法启动窗口的拖动方式。为窗口(或窗口上的一个元素)处理MouseLeftButtonDown事件。
34、改变形状窗口的尺寸，大体上是矩形，最简单的方法是通过将Window.ResizeMode属性设置为CanResizeWithGrip。其他两种基本方法：可使用.NET平台调用特性(P/Invoke)发送改变窗口尺寸的Win32消息；当用户拖动一条侧边时，简单地跟踪鼠标位置，并通过设置窗口的Width属性来手动改变窗口的尺寸。
35、探测用户何时将鼠标移到窗口边缘，最简单方法：是在每个窗口的边上放置一个元素(不需要具有任何可视化外观)，使用5个单位宽的Rectangle元素是很完美的。
36、组合到一起：窗口的自定义控件模板。需要确保提供装饰层。
37、WPF控件可使用装饰层绘制应当在元素上重叠显示的内容。
38、代码隐藏方式是一种轻量级的方法。可扩展控件模板的功能，且可允许应用程序继续使用控件基类。
39、Windows7任务栏编程，WPF不但为跳转列表(当右击任务栏按钮时显示的列表)提供支持，还允许改变应用程序使用的任务栏预览图像和任务栏图标。
40、跳转列表(jump list)，为当前打开属于当应用程序的文档提供了一种快速方法。最近文件支持(将应用程序注册为处理特定的文件类型，两种方法：使用代码为Window注册表添加相关细节；可通过Windows资源管理器手动完成该工作)；
41、注册文件类型时，直到原则：当创建文件类型注册时，为Windows提供可执行程序的准确路径；不用担心会取代通用文件类型；为在VS中测试跳转列表，必须关闭运行关闭VS承载进程。
42、正在运行VS，Windows将为承载进程(YouApp.vshost.exe)检查文件类型注册，而不是为您的应用程序检查文件类型注册。
43、锁定(pinning)，允许用户将他们最重要的文档附加到跳转列表中并永远保留它们。
44、自定义跳转列表，在App.xaml文件中添加一些定义<JumpList.List>节点标记。Windows停止显示最近文档列表。需使用JumpList.ShowRecentCategory属性明确进行选择。为JumpList添加JumpPath或JumpTask对象。
45、使用代码创建跳转列表项，使用System.Windows.Shell名称空间中的JumpList、JumpPath、JumpTask类。
46、从跳转列表启动应用程序，需使用的但实力技术的变体。基本策略：当引发Application.Startup事件时，创建指向应用程序的JumpTask对象；使用单实例代码；当第一个实例接收到命令行参数时，执行适当的任务；当引发Application.Exit事件时，务必从跳转列表中删除任务。
47、改变任务栏图标和预览，TaskbarItemInfo类，每个窗口都有一个关联的TaskbarItemInfo对象。缩略图剪裁、
48、缩略图预览窗口显示客户区(除窗口边跨之外的所有内容)的缩小版。TumbnailClipMargin属性。
49、注意：不能将缩略图预览更改为显示选择的图形。唯一的选择是指显示整个窗口的一部分。
50、缩略图按钮，WPF支持缩略图按钮，ThumbButtonInfos集合添加一个或多个ThumbButtonInfo对象即可(一幅图像(ImageSource)和提示文本)。
51、注意：任务栏按钮不能再Windows Vista中显示。任务栏按钮应当只复制窗口中已有的功能，而非提供新功能。
52、进度通知，ProgressValue和ProgressState属性。
53、重叠图标，只需要很小的具有透明背景的.png或.ico文件。Overlay属性。


第 24 章 页面和导航
1、大多数传统的Windows应用程序都以包含工具栏和菜单的窗口为中心。
2、Web开发使用基于页面的导航模型。
3、基于页面的模型是最常用于简单轻量级应用程序。精简应用程序部署。WPF允许创建直接运行与Internet Explorer或Firefox浏览器中基于页面的应用程序。XBAP。
4、WebBrowser控件，可在WPF窗口中驻留HTML页面。显示网页，还可通过编程探索网页的结构和内容(Html DOM)，甚至可使用应用程序和JavaScript代码进行交互。
5、基于页面的导航，网站用户的大部分时间都花在从一个页面导航到另一个页面。用户从始至终都会以线性方式在这些页面之间穿梭。
6、HTML不支持桌面操作系统的高级窗口功能。最优秀的Web来发人员依赖于良好的设计以及直观清晰的界面。
7、Web模型简单流畅，更易用。Microsoft Money金融软件使用类似Web界面最早的一个例子，引导用户完成设置任务。
8、WPF提供了内置的包含导航的页面模型。用于创建各种基于页面的应用程序，可创建使用某些基于页面的特性的应用程序，可创建使用某些基于页面特性的应用程序(如向导系统或帮助系统)，或创建直接驻留浏览器中的应用程序。
9、基于页面的界面，Page作为用户界面的顶级容器。但当运行应用程序时，它们不是顶级容器。页面被驻留在另一个容器中。可使用容器：NavigationWindow；位于另一个窗口中的框架(Frame)、位于另一个页面中的框架(Frame)、直接驻留于Internet Explorer或Firefox中的框架(Frame).
10、注意：可为任何WPF项目添加页面。
11、创建一个具有导航窗口的基于页面的简单应用程序，WPF非常智能，会自动创建一个新的NavigationWindow对象作为容器，并在其中显示页面。
12、要尽量避免使用NavigationWindow，而应使用Page类的属性。
13、Page类，不是内容控件---它直接继承自FrameworkElement类，只能包含一个嵌套元素。更简单，更精简。以一种受限的方式与容器交互，以及使用导航功能。
14、Page类未提供与Window类中的Hide()及Show()方法等同的方法。希望显示另一个页面，需要使用导航。
15、超链接，允许从一个页面移到另一个页面的最简单方式。在WPF中，它不是独立元素，而是内联的六元素，必须将此类元素放到支持它们的另一个元素中。TextBlock元素是最实用的超链接容器。
16、注意：只有在页面上放置超链接时，NavigateUro属性才有效。如希望在基于窗口的应用中使用超链接，让用户执行任务、加载网页或打开新的窗口，需要处理RequestNavigate事件并自行编写代码。
17、NavigationWindow提供了非常显眼的前进按钮和后退按钮。
18、导航到网站，页面区域加载目标网页。务必将处理程序关联到Application.DispatcherUnhandledException或Application.NavigationFailed事件。如果计算机离线、站点不可访问或无法获得Web内容，将无法导航到网站。
19、显示来自外部网站中的页面时，有许多限制。不能阻止用户导航到特定的页面或站点。且不能使用HTML文档对象模型(Document Object Model, DOM)与网页进行交互(意味着不能浏览页面，查找链接或动态改变页面)。可使用WebBrowser控件完成这些任务。
20、分段导航(fragment navigation)，通过在NavigationUri属性的末尾添加数字符号(#),并在后面添加元素名称，可直接导航到页面中的特定控件。目标页面能够滚动。
21、在框架中驻留页面，在窗口中嵌入页面，只需要使用Frame类(可包含任何元素的内容控件，但当用作页面的容器时，它非常有意义)。Source属性，指向希望显示的XAML页面。
22、Frame.NavigationUIVisiblility属性(默认)被设置为Automatic。
23、在另一个页面中驻留页面，嵌套的页面是更复杂的导航情形。所有位于框架中的页面都被方到一个列表中。
24、JournalOwnership属性设置为OwnsJournal，告诉框架要保持自己不同的页面历史。
25、在Web浏览器中驻留页面，需要创建XAML浏览器应用程序(XBAP)，在VS中，XBAP是单独的项目模板，并且为了使用驻留与浏览器的功能，在创建项目时必须选择该模板。
26、获取窗口的正确尺寸。
27、两类基于页面的应用程序：独立的Windows应用程序，(如集成向导或开发简单的面向任务的应用程序)；浏览器应用程序(XBAP)，使用有限的权限运行，创建基于Web的轻量级部署模型。
28、页面历史，
29、深入分析WPF中的URI，WPF的应用程序资源寻址方式使该系统得以工作。URI仍被视为相对路径。
30、为得到正确的程序集引用、名称空间导入以及应用程序设置。应使用Custom Control Library(WPF)项目模板。
31、导航历史，后退列表和前进列表的行为是非常直观的，但它们的实现过程是非常复杂的。
32、注意：通过导航历史返回到页面和通过单击指向同一个页面的链接返回到页面，是有区别的。
33、WPF不能假定维护页面对象是一种安全策略。离开页面，WPF会保存所有控件的状态，然后销毁页面。
34、WPF检查页面的整个元素树，并且查看所有元素的依赖项属性。应当保存的属性具有少量额外的元数据。即日志标志(指示它们应当保存在名为journal的导航日志中)。
35、动态设置了许多属性，功能强大的方法是使用Page.KeepAlive属性，WPF就不会使用前面介绍过的串行化机制，反而将保持所有页面对象有效(增加内存负担)。另一方案，选择不同的可传递相关信息的设计。
36、当使用KeepAlive属性保持页面有效时，下次导航到该页面时不会引发Initialized事件。
37、维护自定义的属性，在页面类中创建依赖项属性(创建依赖项属性的定义，有普通属性过程来设置或获取依赖项属性的值)。
38、导航服务，通过编程进行导航，最灵活且功能最强大的方法是使用WPF导航服务。可通过驻留页面的容器(如Frame或NavigationWindow)访问导航服务，但该方法仅允许将页面用于相应类型的容器中。
39、访问导肮服务的最佳方法是通过静态的NavigationService.GetNavigationSewrvice()方法。注意：在页面构造函数中或当引发Page.Initialized事件时，不能获取NavigationService，应当改用Page.Loaded事件。
40、WPF导航是异步的。
41、导航事件，当导航完成时执行一些任务。WPF导航处理的过程：页面已经定位；已经检索页面信息；页面需要的所有相关资源已经定位并下载；页面已经解析，并已生成了对象树(Initialized事件和Loaded事件)；页面被呈现；如果URI包含分段导航，WPF会导航到那个元素。
42、处理导航的最简单的方法是在应用程序一级进行。
43、不能使用RoutedEventArgs.Handled属性抑制导航事件，导航事件是普通的.NET事件，不是路由事件。
44、管理日志，
45、WPF不允许用户更多地控制导航堆栈。NavigationService类只提供了两个方法：AddBackEntry()和RemoveBackEntry()。
46、向日志添加自定义项，
47、调用AddBackEntry()方法，不能给该方法传递JournalEntry对象。而是需要创建一个继承自抽象的System.Windows.Navigation.CustomContentState类的自定义类，并存储需要的所有信息。
48、注意：IProvideCustomContentState接口是一个容易被忽视的细节。GetContentState()方法，需要为页面保存状态。
49、使用页函数，PageFunction类(添加了返回结果的功能)。VS中PageFunction模板，与Page类似，区别根元素是<PageFunction>。泛型类，它接受一个类型参数(指定用于PageFunction返回值的数据类型)。TypeArguments特性。
50、在应用程序中使用全局变量，会使应用程序变得混乱，难以区分相互之间的依赖关系，会使重用页面以及维护应用程序变得困难。
51、PageFunction需要通过编程方式处理所有导航。提供了RemoveFromJournal属性。
52、通过为应用程序添加PageFunction对象，就具备了使用不同类型导航拓扑的功能。
53、XAML浏览器应用程序，XBAP是彻头彻尾的WPF应用程序。它们运行于浏览器窗口中；它们通常具有的权限是有限的；它们不需要安装。
54、XBAP应用程序看起来在浏览器的"内部"运行，只不过是因为在浏览器窗口中显示它们的所有内容。ActiveX控件被加载到浏览器进程中。
55、Web的立即更新模型。
56、XBAP应用程序优点：提供了一种不会受到提示干扰的体验。Chrome不支持XBAP。需要目标.NET版本。
57、创建XBAP应用程序，
58、XBAP应用程序几乎总是运行在Internet区域提供的有限权限下。
59、将XBAP应用程序改为基于页面的独立窗口应用程序最简单的方法是，创建所需类型的新项目，然后从旧项目中导入所有页面。
60、部署XBAP应用程序，只是将编译过的应用程序复制到网络上的某个共享位置或虚拟目录。将三个文件复制到同一文件夹中：ApplicationName.exe;ApplicationName.exe.manifest;ApplicationName.xbap。
61、注意：松散的XAML文件得到类似效果。显示文档、图形、动画。
62、数字签名使用以为项目选择的密钥。
63、双击.xbap文件，或在Web浏览器的地址栏中键入.xbap文件的路径。下载过程本质上是将.xbap应用程序复制到本地Internet缓存中的安装过程。
64、若想发布应用程序更新，需要使用相同的密钥进行标识以确保数字签名保持一致。
65、更新XBAP应用程序，可手动清除ClickOnce缓存(不便捷)。更新程序集版本不足以触发更新---需要更新发布版本。
66、注意：.xbap文件的下载和缓存功能是基于CkickOnce部署模型(使用发布版本决定应当更新的时机)构建的。
67、XBAP应用程序的安全性，在Internet区域权限下运行。使用代码访问安全模型来限制XBAP应用程序执行的操作。
68、测试代码并进行尝试(是否能够运行)。XBAP未处理的异常SecurityException。
69、完全信任的XBAP应用程序(不推荐)，Properties-->Security(This is a Full Trust Application)。注意：从本地运行应用程序；将正在使用的用于给程序集签名的证书(.pfx文件)添加到目标计算机的Trusted Publishers存储库中(certmgr.exe工具完成)；将部署.xbap文件的网站URL或网络计算机指定为完全信任的。
70、XBAP模型的真正目标是创建于创痛的HTML以及JavaScript网站(或Flash小程序)相同的WPF等价物。
71、组合使用XBAP/独立应用程序，测试IsBrowserHosted属性。
72、为不同的安全级别编写代码。关键：编写能够避免意外的SecurityException异常的灵活代码。CodeAccessPermission.Demand()方法。
、代码访问安全模型中的每个权限都由一个继承自CodeAccessPermission类表示。
73、使用隔离存储区(isolated storage)，提供了虚拟文件系统，允许在特定应用程序的特定于用户的一小块空间中写入数据。可使用的总空间通常是1MB(位置通常是：C:\Users\[UserName]\AppData\Local\IsolatedStorage\[GuidIdentifier])。其他非管理员用户不能访问。
74、注意：隔离存储区等价于普通网页中的.NET永久cookie---允许在专用位置存储少量信息。
75、每个应用程序都有一块单独的隔离存储区。DeflateStream或GZipSteam类压缩。
76、使用Popup控件模拟对话框，StaysOpen属性设置为true。添加合适的按钮(OK和Cancle)，将Placement属性设置为Center。将顶级容器的IsEnabled属性设置为false来禁用用户界面。
77、确保Popup控件不能被用于欺骗合法的系统对话框，Popup窗口被限制在浏览器窗口中。解决方法：使用ScrollViewer控件封装Popup控件的全部内容，并使用它的VerticalScrollBarVisiblity属性设置为Auto。另一种方法：在WPF页面中显示对象框的更奇怪选择(使用.NET2.0中的Windows窗体库)。
78、在网页中嵌入XBAP应用程序，创建HTML页面，并使用<iframe>标签指向.xbap文件。不常见的技术。
79、WebBrowser控件，不是完全使用托管代码写的，封装了shdocvw.dllCOM组件(是Internet Explorer的一部分)。图形限制(如不能在这些控件中显示的HTML内容的上面放置其他内容，不能使用变换对象扭曲或旋转HTML内容)。
80、Frame控件，WPF和HTML内容之间容器；WebBrowser控件，JavaScript和WPF之间的交互路径。
81、导航到页面，URI设置Source属性。指向目录，file:///c:\。异步的。事件：Navigating、Navigated、LoadCompleted。
82、构建DOM树，需要添加对Microsoft HTML Obejct Library(mshtml.tlb)的引用(COM库)。Add Reference-->COM选项卡。WebBrowser.Document属性(提供一个HTMLDocment对象)，只读的。一旦引发LiadCompleted事件，就可以访问Document属性了。
83、每个IHTMLElement对象具有的重要属性：tagName；id；children；innerHTML；innerText；outerHTML与outerText。
84、导航HTML页面的文档模型，遍历每个IHTMLElement的Children集合。查找特定元素，可使用HTMLDocument.all集合，使用元素的id特性检索页面上的任何元素。没有id特性，使用getElementbyTagName()方法。
85、使用.NET代码为网页添加脚本，创建一个用于接收来自JavaScript代码的消息类，必须为类的声明添加ComVisible特性(位于InteropServices名称空间)。然后为WenBrowser控件注册该类的一个实例(设置ObjectForScripting属性)。
86、在网页中，使用JavaScript代码触发该事件。使用windows.external对象。
87、警告：可与脚本交互的类应当只包含于Web相关的方法以确保安全。
88、HTML元素支持的常用事件：onFocus、OnBlur、OnClick、onChange、onMouseOver。
89、警告：除非HTML文档作为嵌入的资源被编译进程序集或从某些安全位置(如数据库)检索而来，否则HTML文档可能会被客户篡改。


第 25 章 菜单、工具栏和功能区
1、菜单，是最古老的用户界面控件之一。
2、WPF工具栏和状态栏支持溢出菜单，但没有提供浮动和停靠功能。
3、WPF4.5增加了自带的Office功能区，只适用于Office应用程序。
4、菜单，Menu和ContextMenu。WPF负责呈现。注意：如果在浏览器中驻留的应用程序使用Menu类，菜单就会显示在页面顶部。它们是完全相互独立的。
5、Menu类，通常使用DockPanel或Grid面板的顶行将菜单停靠在窗口的顶部，并将它拉伸到整个宽度。IsMainMenu，默认为true，Alt键或F10菜单就会获得焦点。ItemSource属性，创建使用数据绑定的菜单。还可应用分组。MenuItem类的默认控件模板中包含了大量样式化逻辑。
6、菜单项，由MenuItem(继承HeaderedItemsControl)对象和Separator对象(显示一条分隔菜单项的水平线)构成。
7、可使用下划线来指示Alt+快捷键组合。
8、WPF允许违反构造菜单的大多数常识性规则。允许包含非MenuItem对象，但是一种错误方式。如确实希望用户界面包含一些具有控件的下拉菜单(Expander控件)。只有当确实希望具有菜单行为时才使用菜单---一组能被单击的命令。
9、注意：如希望在用户单击其他位置之前始终显示打开的子菜单，将MenuItem.StaysOpenOnClick属性设置为true。
10、MenuItem.Click事件。Command、CommandParameter以及CommandTarget属性，将MenuItem连接到Command对象。
11、MenuItem对象实际还可显示其他细节：在菜单命令左边的页边距区域显示小图标(Icon)；在页边距区域显示复选标记(IsChecked)；在菜单文本的右边显示快捷键(InputGestureText)。
12、Icon属性接受任意对象，灵活地构造缩微矢量图像。无法关联一组选中的菜单项。
13、ContextMenu类，不能放置在窗口中，只能被用于设置其他元素的ContextMenu属性。
14、菜单分隔条，将菜单分成相互关联的命令组的标准元素。它是一块固定的内容，不影响键盘和鼠标的操作。
15、工具栏和状态栏，支持WPF内容模型。
16、ToolBar控件，完美解决方法是使用自己的Button类。覆盖某些子元素类型的默认样式。通常通过设置按钮内容得到需要的所有控制能力。Orientation，LayoutTransform。
17、溢出菜单，自动溢出菜单添加项，顺序是从最后一个项开始。应用OverflowMode附加属性。
18、ToolBarTray类，本质上包含ToolBar对象的集合(ToolBars属性)。使得工具栏共享一行或同一栏更加容易。增加了对工具栏拖放功能的支持。更好的控制，可使用数字索引设置Band属性，确定工具栏应当被放置到哪里栏中。
19、StatusBar控件，StatusBarItem对象，不支持拖动式的重新排列，也不支持溢出菜单，主要用于显示文本和图像指示器。通常使用水平StackPanel面板。使用ItemsPanelTemplate属性指示状态使用不同的面板来实现这种设计。比例改变尺寸或右对齐项的一种方法是为布局容器使用Grid面板。
20、功能区，Office2007中初次出现。WPF提供了一个功能区版本。免费且具有较为完备的功能：富工具提示、下拉按钮、对话框启动器、快速访问工具栏以及可配置的尺寸更改。
21、工具栏，正处于小王的趋势中。将被更灵巧的基于Tab的控件所取代。
22、需要下载，http://www.microsoft.com/download, 搜索"WPF ribbon"。RibbonControlLibrary.dll.
23、功能区的设计原则和最佳实践，http://tinyurl.com/4dsbef.
24、添加功能区，当使用RibbonWindow类，确保代码隐藏窗口类不是明确继承自Window类。
25、功能区包含三部分：快速访问工具栏(位于顶部)、应用程序菜单(最左边的按钮提供)、多选项卡的功能区扩建自身。
26、提示：功能区使用提供的纯色，并自动在开机表面添加精细的渐变效果。
27、应用程序菜单，基于两个简单的类：RibbonApplicationMenu(MenuBase)和RibbonApplicationMenuItem(MenuItem)。高级特性，如支持RibbonCommand，增强超出了普通菜单类的功能。
28、选项卡、组与按钮，选项卡包含一个或多个组；组是一块具有轮廓的、标题的、类似方框的区域。
29、富工具提示，显示更详细的弹出工具提示。可包括标题、说明信息以及图像(可能包括页脚)。删除标准的工具提示(ToolTip)。限制：不能将实际元素(如链接)放入工具提示中，只限于文本和图像内容。
30、带有快捷键提示的键盘访问，需要为选择项卡、组合命令指定适当的快捷键。KeyTip属性，只要为RibbonApplication指定了工具提示，其中的所有菜单项都可通过键盘来访问。
31、改变功能区的大小，通过减少或重新布置每组中的按钮来适应窗口的宽度。RibbonWrapPanel控件。GroupSizeReductionOrder，RibbonGroupSizeDefinition(指示组如何折叠自身，按顺序匹配控件)。
32、注意：最小化功能区，双击任意选项卡标题或右击功能区。
33、快速访问工具栏(QAT)，包含常用按钮的窄条。RibbonQuickAccessToolbar对象，包含一系列RibbonButton对象。真正目标是为用户提供自定义区域。最大限制：不能保存当前状态。下次启动应用程序时还原。


第 26 章 声音和视频
1、WPF提供了播放多种声音格式的能力。声音功能仍与DirectSound相距很远(是DirectX中的高级音频API，它可应用动态效果，在仿真的三维场景中放置声音)。
2、WPF缺少检索音幅数据的方式；通过检索音幅数据，可获取声音的高低，对于创建某些类型的合成效果以及声音驱动的动画是非常有用的。
3、WPF对视频的支持，MPEG文件和WMV文件。将它集成进WPF模型其他部分的方式是引人注目的。可使用视频同时填充几千个元素，并且可结合使用效果、动画、透明甚至3D对象。
4、WPF对语音合成和语音识别的支持。
5、播放普通WAV音频。
6、.NET中，使用SoundPlayer类，功能非常有限，只能播放WAV音频文件，不支持同时播放多个声音，且没有提供控制音频播放任何方面的能力(如音量和平衡等细节)。SoundPlayerAction类封装，可通过声明的触发器播放声音。
7、SoundPlayer类，步骤：创建SoundPlayer实例；通过设置SoundLocation或Steam属性来指定声音内容(不支持WPF的pack URI语法)；通过嗲偶偶那个Load或LoadAsync方法，通知SoundPlayer实例加载音频数据；当音频播放时，可调用PlaySync()方法以暂停代码，也可使用Play()方法在另一个线程中播放音频，确保应用程序的界面保持响应。
8、注意：SoundPlayer类不能很好低处理较大的音频数据，它需要一次性地将整个文件加载到内存中。
9、SoundPlayerAction类，继承TriggerAction类，总是异步地播放声音。
10、系统声音，Windows操作系统能将音频文件映射到特定的系统事件。SystemSounds类(构建在MessageBeep这个Win32 API函数的基础上)，访问其中最常见的声音。Asterisk、Beep、Exclamation、Hand、Question。
11、MediaPlayer类，压缩的MP3音频。依赖于Windows媒体播放器提供的技术关键。注意细节：在事件处理程序的外部创建MediaPlayer对象；通过URI提供文件位置。没有异常处理代码，确定是否正在播放音频，需要负责处理MediaOpened和MediaFailed事件。
12、WPF开发人员通常使用另一个非常类似的元素----MediaElement类。
13、MediaElement类，是WPF元素，封装了MediaPlayer类的全部功能。
14、使用代码播放音频，初始行为由LoadedBehavior属性决定(MediaState枚举值)。
15、注意：MediaElement元素没有支持MediaCommands类的默认命令绑定。
16、处理错误，不会跑出异常，需要处理MediaFailed事件。ExceptionRoutedEventArgs.ErrorException属性获取描述问题的异常对象。
17、使用触发器播放音频，以声明方式，使用XAML标记而不是使用代码控制音频。MediaTimeline类，控制播放音频或视频文件的时间，且和MediaElement元素协调其播放。
18、播放多个声音，
19、改变音量、平衡以及位置，技巧：SpeedRatio不能用于时钟驱动的音频，需要将LoadedBehavior属性设置为Manual。
20、注意：改变音频的播放速度会扭曲声音，并会导致声音失真，如回声效果。
21、将动画同步到音频，使用关键帧动画时，SlipBehavior属性设置为Slip。
22、播放视频，对视频的支持依赖于安装的解码器，但对WMV、MPEG及AVI文件支持。MediaElement类中与可视化布局相关的属性很重要。Stretch和StrechDirection。
23、根据本来的视频范围改变MediaElement元素的尺寸会更好。
24、视频效果，使用MediaElement元素作为内容控件的内容；同属使用多个MediaElement元素为数千个内容控件设置内容---尽管CPU可能不跟很好地承受这种压力；通过LayoutTransform或RenderTransform属性结合使用视频和变换，移动、拉伸或旋转视频窗口；设置MediaElement元素的Clipping属性，将视频窗口剪裁为特定的形状或路径，且只显示整个窗口的一部分；设置Opacity属性，使其它内容能够透过视频窗口显示；使用动画动态改变MediaElement元素或它的其中一个转换的属性；使用VisualBrush画刷(创建类似反射的特效效果)；在三维对象的表面放置视频窗口，且在播放时使用动画移动视频窗口。
25、在WPF中，视频是为数不多的会非常容易地使CPU任务过重的领域之一。
26、VideoDrawing类，继承Drawing类，可创建爱你DrawingBrush画刷，然后可填充元素的表面。效率可能更高。
27、语音，合成与识别，通过System.Speech.dll程序集提供。它是WPF的外围部分。
28、语音合成，根据提供的文本生成语音音频的功能。它是Windows可访问的功能。系统实用工具，如Narrator(Windows提供的一个轻量级的屏幕阅读器)，帮助盲人用户导航基本的对话框。用于创建音频辅导和语音指令，尽管实现录制好的音频质量更好。
29、注意：需要动态文本创建音频，很有意义。
30、所有现代版本的Windows都内置了语音合成功能，使用更自然的被命名为Anna的女性声音。
31、SpeechSynthesizer类，实例，并使用一个文本字符串调用其Speak()方法。更好的控制朗诵文本，需要使用PromptBuilder类构造语音定义。使用PromptEmphasis。PromptRate，PromptVolume。同时改变这些细节，需要使用PromptStyle对象(BeginStyle()方法)。
32、PromptBuilder类提供了AppendTextWithHint()方法，可处理电话号码、日志以及需要拼写的单词。可使用SaysAs枚举。
33、PromptBuilder类是SSML(Synthesis Markup Language,合成标记语言)标准的封装器。
24、语音识别，将用户朗读的音频转换为文本的功能。
25、注意：如果目前没有运行语音识别，当实例化SpeechRecognizer类，会显示语音识别工具栏。Windows会自动启动一个向导。
26、SpeechRecognizer类封装了一个COM对象。为避免不恰当的误操作，应将它声明为窗口类的成员变量。
27、注意：当检测到音频时，SpeechRecognizer类实际会触发一系列事件。SpeechDetected事件，尝试识别单词时，一次或多次引发SpeechHypothesized事件，最后，如果能成功地处理文本，SpeechRecognizer类将引发SpeechRecognized事件；如不成功，引发SpeechRecognionRejected事件。
28、WPF具有它自己的用户界面自动化特性，能够和语音识别引擎无缝地工作。
29、通过制定基于SRGS(Speech Recognition Grammar Specification，语音识别语法规范)的语法完成。
30、两种方式构造SRGS语法，从SRGS文档加载，基于XML的语法规则。需要使用System.Speech.Recogition.SrgsGrammar名称空间的SrgsDocument类。可使用GrammarBuilder类以声明方式构建语法。
31、Choice对象表示SRGS的一条规则，允许用户说出位于某个范围内的单词。
32、SRGS标准，http://wwww.w3.org/TR/speech-grammar.
33、最好的方法取决于具体需求。


第 27 章 3D绘图
1、WPF引入一个扩展3D模型，使用简单标记构建复杂的3D场景。辅助类提供了命中测试、基于鼠标的旋转以及其他基本构件。
2、缺少显卡支持时WPF退而使用软件渲染的能力。
3、从简单游戏中的精彩效果到商业应用程序中的图标和数据可视化。
4、WPF 3D模型还不能胜任的一种情况是高性能的实时游戏。如准备构建游戏，最好使用底层的DirectX。
5、创建3D界面仍较为困难。3D编程数学知识、3D设计工具、WPF中的3D库。
6、3D绘图4个要点：视口，用来驻留3D内容；3D对象；照亮部分或整个3D场景的光源；摄像机，提供在3D场景中进行观察的试点。
7、WPF 3D支持的优点：可创建一些效果(光照效果，如反射)；是和一组3D对象绘制的内容进行交互，极大地扩展了通过代码能够完成的工作。
8、视口，容器包含3D内容，Viewport3D类，位于System.Windows.Controls名称空间。继承自FrameworkElement类，可放到能够放置正常元素的任何地方。只应用于复杂的3D编程。只增加了两个属性---Camera(定义了3D场景的观察者)和Children(包含了希望放在场景中的所有3D对象)。照亮3D场景的光源本身也是视口的一个对象。
9、注意：ClipToBounds属性，true，超出视口边界的内容将被剪裁掉；false，内容会显示在相领元素的上面。性能。false，当渲染复杂的、频繁更新的3D场景。
10、3D对象，继承自Visual3D类(System.Windows.Media.Media3D)。Visual3D、Geometry3D(表示3D表面)、GeometryModel3D、Transform3D。
11、最佳设计决策之一，使用和2D绘图类相同的方式构造3D绘图类。
12、MeshGeometry3D类，在3D绘图中非常重要，将使用该类定义所有3D对象。
13、关系：Viewport3D包含Visual3D对象，需要定义Geometry3D对象来描述形状，并将其封装到GeometryModel3D对象。然后可使用GemetryModel3D对象作为Visual3D的内容。
14、两个步骤的过程：定义希望使用的抽象形状，然后使用可视化对象将形状融合在一起。
15、几何图形，只有一个类用于该目的：MeshGeometry3D类。MeshGeometry3D对象表示网格。计算机更喜欢通过三角形构建3D图画。
16、现代图形硬件和图形程序就构建在这个核心抽象的基础上。
17、网格就是三角形的这种组合。通过足够多的三角形，最终可创建出任何内容。
18、理解如何定义网格是3D编程的第一个关键点。
19、MeshGeometry3D类，增加的4个属性：Positions(定义网格的所有点的集合)、TraingleIndices(定义三角形)、Normals(为每个顶点(Positions集合中的每个点)提供一个向量)、TextureCoordinates。
20、使用法线和纹理映射进行着色。
21、如何构建基本的网格，可移动摄像机使其更远或更近，且可使用变换该百年单个3D对象的尺寸或位置。重要的是坐标系统。
22、3D编程有几个细微的、很容易违反的规则。定义形状时，必须以绕Z轴逆时针顺序列出点。
23、注意：3D形状的背面和前面之间的区别并不简单。可使用不同的画刷绘制两个面。
24、几何图形模型和表面，GeometryModel3D有是哪个属性：Geometry、Material以及BackMaterial。
25、表面很重要，表面定义了对象的颜色、材质如何响应 灯光。
26、WPF提供了4个材质类，继承自抽象的Material类。DiffuseMaterial(和现实世界中的表面最接近)、SpecularMaterial、EmissiveMaterial、MaterialGroup。
27、使用GeometryModel3D对象设置ModelVisual3D对象的Content属性。然后在视口中放置ModelVisual3D对象。但为了看到该对象，需要另外两个细节：光源和摄像机。
28、光源，为创建逼真的已经着色的3D对象，WPF需要使用光照模型。基本的概念是为3D场景添加一个或多个光源，然后根据选择的灯光类型、灯光位置、灯光方向以及强度照亮对象。
29、WPF光照模型和真实世界中的光照行为是不同的。构造WPF光照系统是为了模拟真实世界，但计算机真实的灯光反射是处理器密集型任务。WPF进行了许多简化：分别为每个对象计算灯光效果；为每个三角形的每个顶点进行灯光计算，然后在三角形的表面进行插值。
30、获得精确结果是3D场景设计艺术的一部分。
31、注意：如果没有提供光源，对象也依然可见，但如果没有光源，所看到的只是纯黑色的轮廓。
32、WPF提供了4个灯光类，继承自抽象的Light类。DirectionLight(沿着指定方向)、AmbientLight(使用三兽渡河的光线)、PointLight(点各个方向辐射)、SpotLight(点，锥形辐射)。
33、向量决定光线的路径。计算灯光方向时，重要的是向量角度。
34、以一定的角度照射三角形时，会着色三角形的表面，从而创建更美观的效果。
35、定向光充满了整个3D空间。注意：定向光在一定程度上类似于太阳光(来自遥远光源的光线几乎是平行的)。
36、所有灯光都间接地继承自GeometryModel3D类。
37、视口包含定义观察者在场景中为孩子的摄像机。
38、深入分析3D光照，
39、为创建完美的圆，需要为位于圆周上的每个像素提供三角形。
40、摄像机，在渲染3D场景前，需要在正确的位置放置摄像机，并使其朝正确的方向。通过Viewport3D.Camera属性。确定了如何将3D场景投影到Viewport对象的2D表面上。
41、WPF提供三个摄影机类：PerspectiveCamera(常用)、OrthographicCamera和MatrixCamera。
42、工艺绘图应用程序。
43、放置和配置摄像机有点复杂，设置Position属性，LookDirection属性(设置一个3D向量)。
44、注意：摄像机的位置决定了在视口中显示的场景范围。
45、轴线，这些直线是出色的测试工具，它们使得查看坐标轴被放在何处变得更加容易。需要渲染很长且非常窄的三角形。ScreenSpaceLines3D类，可免费下载的类库中(http://3dtools.codeplex.com)，绘制固定宽度的直线。构建3D设计工具或调试应用程序时，这些应用程序最有用。
46、FieldOfOview属性，控制同时能看到多少场景。摄像机透镜的效果。注意：只能应用于PerspectiveCamera类。
47、NearPlaneDistance(0.125)和FarPlaneDistance(Double.PositiveInfonity)属性，设置盲区。渲染伪影(rendering artifacts).
48、z-fighting问题(也称为拼接)，显卡怒呢个正确地确定对于摄像机而言哪个三角形是最近的，以及是否渲染，结果会在网格表面上造成伪影问题。通常是由于显卡上浮点数的舍入错误造成的。可增加NearPlaneDistance属性的值避免该问题，以剪裁那些离摄像机非常近的对象。
49、深入研究3D绘图，组合一系列三角形创建实心的、有侧面的形状。
50、如何将它分割为MeshGeometry对象能够识别的三角形。
51、为降低开销并提高性能，在3D程序中通常避免渲染看不到的形状。
52、着色和法线，WPF简化计算到达形状中每个顶点的光线数量(只关注三角形的拐角)。每个法线定义了顶点如何面向光源。大多数情况，希望法线垂直于三角形平面。
53、如果在两个不同的三角形之间共享点，最终还会共享法线。
54、注意：WPF总将3D场景渲染为一系列不同的三角形，而不考虑是否在Positions集合中共享了顶点。
55、选择正确的法线有些麻烦，两个原则：为计算垂直于表面的法线，需要计算构成三角形任意两条边的向量的叉积(保证点是逆时针方向，法线是朝外的)；如果希望混合整个包含多个三角形的表面，要确保所有三角形中的点共享相同的法线。
56、通过填充向量来手动设置Normals属性。记住：必须为每个位置添加一条法线。
57、技巧是为大的具有多个面的多边形应用混合，从而使其看起来像球、圆柱或其他曲面形状。
58、更复杂的形状，需要使用代码或专门的3D建模程序。工具：Blender，是一款用于3D建模的开源工具包；用于各种专业3D建模程序的导出插件，如Autodesk Maya、Newtek的LightWave。Electric Rain ZAM 3D，可定义在三维场景中的对象上执行的动画。
59、Model3DFroup集合，在单个Visual3D对象中放置几个网格。继承自Model3D类，被设计用于封装整个网格的组合。
60、通过创建尽可能少的网格，并将尽可能多的内容组合进每个网格，可极大地提高性能。
61、使用材质，看到的颜色是由画刷颜色和光照共同决定的。
62、WPF允许使3D对象部分透明，最简单的方法是设置材质使用的画刷的Opacity属性为1.
63、SpecularMaterial材质，更尖锐地反射光线。SpecularPower控制反射光线的尖锐程度。
64、纹理映射，TextureCoordinates集合。映射ImageBruh画刷。视频和VisualBrush画刷。
65、交互和动画，实现3D场景的动态化。
66、变换，方法：修改应用于Model3D对象的变换；修改应用于ModelVisual3D对象的变换；修改应用于灯管的变换；修改应用于摄像机的变换。使用Transform3DGroup对象。在XAML中使用x:Name特性命名变换对象。
67、ZAM 3D建模程序总为每个Model3DGroup对象添加包含4个变换封装器的集合。
68、旋转，RotateTransform3D对象，绕指定的轴旋转3D对象。
69、飞过，绕对象旋转摄像机。
70、3D应用程序的性能，WPF视图以每秒60次的帧率刷新改变的部分，根据场景的复杂程度，很容易耗光显卡内存的资源，从而会导致帧率下降并使动画出现跳动。
71、改变视口的策略(降低3D渲染的开销)：Viewport3D.ClipToBounds属性设置为false；Viewport3D.IsHitTestVisible属性设为false；将Viewport3D的RenderOptions.EdgeMode附加属性设置为Aliased；改变尺寸使其更小。
72、针对创建最高效的网格和模型的重要提示：创建单个复杂网格而不是几个更小的网格；只定义MeshGeometry对象一次(作为资源)；在单个Model3DGroup对象中封装一组GeometryModel3D对象，并将这组对象放到单个ModelVisual3D对象中；不要定义背面材质；尽可能使用纯色画刷、渐变画刷以及图像画刷。
73、跟踪球，通过移动摄像机工作的。
74、命中测试，需要拦截鼠标并确定单击区域。三种选择：处理视口的鼠标事件，然后调用VisualTreeHelper.HitTest()方法以确定击中了哪个对象;通过UIElement3D抽象类继承自定义类来创建自己的3D控件(麻烦)；可用ModelUIElement3D对象代替ModelVisualD对象。
75、ModelUIElement3D类，是一种Visual3D类型，继承自UIElement3D类。支持变换(Transform属性)，允许使用GeometryModel3D对象定义形状(Model属性)。
76、继承自Visual3D类的三个重要类：ModelVisual3D、UIElement3D、Viewport2DVisual3D(在3D场景中放置2D内容)。
77、UIElement3D类通过添加对鼠标、键盘和手写事件的支持，以及焦点跟踪支持。但它不支持任何类型的布局系统。
78、使用ModelUIElement3D类进行命中测试，比使用视口鼠标事件的命中测试方法更简单。
79、只希望响应在3D对象上的单击，并不需要执行涉及网格的计算，根本不必使用VisualTreeHelper类。
80、ContainerUIElement3D类，用于表示类似控件的对象。封装ModelUIElement3D对象，然后将ContainerUIELement3D对象添加到视口中。优点：支持所有继承自Visual3D的对象组合。
81、3D表面上的2D元素，可使用纹理映射在3D表面上放置2D画刷的内容，可使用这种技术在3D场景中放置图像或视频。使用VisualBrush画刷，甚至可获取WPF普通元素(如按钮)的可视化外观，并将其放到3D场景中。
82、Viewport2DVisual3D类，封装另一个元素并使用纹理映射将其映射到3D表面。放置到Viewport3D对象中，它的元素仍保持其交互性，且具有所有已经使用过的WPF特性，包括布局、样式、模板、鼠标事件和拖放等。
83、注意：当定义TextureCoordinates集合时，务必使用元素面向摄像机。
84、使用纹理映射将可视化对象的3D坐标变换为普通的、没有纹理映射的2D坐标。
85、3D编程是一个非常复杂的主题。3D理论，3D开发背后的数学基础知识，可阅读由Fletcher Dunn撰写的3D Math Primer for Graphics and Game Development一书。
86、上网浏览，并查找由WPF团队以及其他独立开发人员提供的资源和示例代码。链接：http://3dtools.codeplex.com(WPF3D工具库)；http://tinyurl.com/bumqt2y(WPF工具列表)；http://tinyurl.com/np2951(封装三个常用3D图元所需的网格类)；http://tinyurl.com/97kwul2(一个SandBox3D项目)。


第 VII 部分 文档和打印
第 28 章 文档
1、显示大量文本(如报刊新闻或在线帮助的详细介绍)。WPF提供了一套用于处理文档的高级特性。以更便于阅读的方式显示大量内容，而不管容器窗口的尺寸是多大。
2、使用流文档(flow document)显示内容，将学习如何让用户使用RichTextBox控件编辑流文档内容。流文档，快速浏览XPS(Microsoft公司用于创建准备打印的文档的新技术)。WPF的批注(annotation)特性(允许用户为文档添加注释和其他标记)，并可永久地保存它们。
3、理解文档，WPF将文档分两大类：固定文档(是指已经排好版、准备打印的文档，相当于Adobe公司的PDF文件，打印输出，表格、出版物)；流文档(是在计算机上查看而设计的文档，WPF能够希望查看的方式优化流文档，动态地布局内容)。
4、XPS，XML Paper Specification，XML页面规范标准。
5、WPF通过使用不同容器为这两种类型的文档提供了支持。DocumentViewer容器(股sing文档)，FlowDocumentReader、FlowDocumentPageViewer以及FlowDocumentScrollViewer容器(流文档)。所有这些容器都是只读的。WPF提供了API，用以编程方式创建固定文档，且通过RichTextBox控件允许用户编辑流内容。
6、流文档，内容会调整自身以适应容器。对于在屏幕上进行阅读，流内容非常理想。它避开了HTML的许多陷阱。
7、普通HTML内容使用流式布局填充浏览器窗口。许多Web站点通过使用某种固定布局强制内容在窄列中显示。在WPF中，可通过Grid容器，并设置ColumnDefinition.MaxWidth属性。防止不便阅读的问题(浪费屏幕空间)。
8、WPF中的流文档内容，通过包含更合理的分页、多列显示、高级连字符和文本流算法，以及用户能够调整的查看选择，并对目前的这些非法进行了改进。
9、流内容元素，使用流内容元素组合构建WPF流文档。继承自ContentElement和FrameworkContentElement类，形成了完全不同的分支。
10、内容元素更加简单，支持类似的基本事件集合，包括用于键盘和鼠标处理、拖放操作、显示工具提示以及初始化的事件。
11、内容元素与非内容元素之间的重要区别是内容元素不处理它们自身的呈现，需要能够呈现所包含的全部内容元素的容器。
12、延迟呈现使容器能提供各种优化。容器能够选择最佳方式在段文本中进行换行，尽管段落是单个元素。
13、注意：内容元素能接收焦点，但它们不接收焦点(Focusable属性默认false)。Hyperlink是一个将Focusable属性设置为true的内容元素例子。
14、流内容元素中两个重要分支：Block元素，用于分组其他内容元素；Inline元素，被嵌入到块级别元素对的内联级别元素。
15、Run元素封装了一些文本。
16、内容模型允许多层嵌套。
17、WPF遵循了许多相同的约定(如区分块级别元素和内联级别元素)。与HTML类似。HTML程序员，可使用http://tinyurl.com/mg9f6y 网址上提供的非常强大的支持从HTML到XAML进行转换的转换器(C#实现)，使用HTML页面作为流文档的开始点。
18、设置内容元素的格式，
19、如果没有设置外边距，流容器会在块级别元素和容器边缘添加大约18个单位的默认空间。
20、TextDecorations属性；Typography属性。
21、创建简单的流文档，VS匀速作为单独的文件创建新的流文档，也可通过使用支持流文档的容器在已有的窗口中定义流文档。将FlowDocumentScrollViewer用作容器，开始构建简单的流文档。
22、提示：目前，还没有用于创建流文档的所见即所得界面。可使用RichTextBox控件创建基本的文本编辑器，用来创建流文档内容。
23、顶级流文档必须使用块级别元素。
24、注意：FlowDocumentScrollViewer容器允许选择文本(像在Web浏览器中一样)。可复制到Windows剪贴板中，并将它们粘贴到其他应用程序中。将Is.SelectionEnabled属性设置为false。
25、块元素(5个)：Paragraph和Run元素、List元素、Table元素、Section元素、BlockUIContainer元素。
26、Paragraph和Run元素，段落需要包含内联级别的Run元素(包含实际文本)。Paragraph足够智能，当直接在它的内部放置文本时，它会隐式地创建Run元素。代码从段落中检索文本，需要获取嵌套的Run对象。可通过使用Span元素封装希望修改的文本来提高可读性。然后为Span元素指定名称并直接访问。TextIndent属性，设置第一行的缩进量(默认0)。
27、注意：WPF没有用于标题的块级别元素。可简单使用具有不同字体尺寸的段落作为标题。
28、List元素，表示项目符号或数字列表。通过设置MarkerStyle属性进行选择。可用MarkerOffset属性设置每个列表项之间的距离以及它们的记号。嵌套ListItem元素表示列表中的单个项(必须包含一个合适的块级别元素(如Paragraph元素))。
29、Table元素，为显示表格信息而设计的，它模仿了HTML语言的<table>元素。步骤：放置TableRowGroup元素；在TableRowGroup元素中为每一缸添加TableRow元素；在每个TableRow元素中添加TableCell元素，表示行中的每一列；在每个TableCell元素中放置块级别元素。
30、注意：Table元素中的单元格根据位置进行填充。必须为表格中的每个单元格提供TableCell元素，并必须按正确的显示顺序添加行和值。
31、为Table.Rows属性提供一组TableColumn对象，覆盖默认行为。设置单元格的ColumnSpan和RowSpan属性，CellSpacing属性。
32、注意：流内容元素只适用于流文档中。Grid面板是针对尽可能高效地在窗口中布局控件而设计的，而Table元素进行了优化，用于在文档中以尽可能便于阅读的方式表示文本。
33、Section元素，本身没有任何内置的格式化设置，用于在某个方便的包中封装其他级别元素。分组元素，可为文档的整个部分应用常用格式。通过Section.Style属性来设置节的格式。和HTML的<div>元素相似。
34、BlockUIContainer元素，在文档中放置块级别元素的地方，放置非内容元素。添加按钮、复选框，布局容器。唯一的规则是只能为BlockUIContainer元素添加一个子元素。
35、混合流内容元素和普通的非内容元素是合理的。
36、内联元素，Run、Span、Bold、HyperLink、LineBreak(块级别中添加换行符)、InlineUIContainer、Floater和Figure(嵌入一块用于强条重要信息的浮动内容、显示一幅图片或显示关联的内容)。
37、Span元素，它能够使查找和控制特定部分的文本更加容易。
38、保留空白字符，通常会压缩XML中的空白字符。XAML使用基于XML的语言，遵循相同的规则。
39、处理Tab键和换行符的方式与处理空格的方式相同。在内联级别元素之前有一个空格，WPF会保留该空格。
40、使用具有preseve值的xml:space特性(可在任何元素中使用)，这是XML约定(通知XML解析器在嵌套的内容中保留所有空格字符)。
41、Floater元素，可在主文档之外设置一些内容。将Floater元素插入到另一个块级别元素的某个位置。
42、通常，流文档会加宽Floater元素，使它所有的内容能够适应一行。
43、浮标显示一幅图片，没有流元素支持这个任务。需要通过结合BlockUIContaner或InlineUIContainer来使用Image元素。
44、在流文档中嵌入一幅位图时，唯一合理的解决方法是为浮标的方框设置固定尺寸。然后使用Image.Stretch属性选择图像如何在这个方框中该百年自身的尺寸。
45、注意：使用缩放特性时，使用固定尺寸的浮标还会得到最合理的结果。
46、Figure元素，与Floater元素类似，但它能够更多地控制位置。通常会使用浮标，并给与WPF一些更多的控制能力以安排内容。
47、警告：显示流文档的FlowDocumentScrollViewer容器不支持这些属性中的许多属性。需要使用更多更高级容器。如希望使用方盒子图形的相关属性，可使用FlowDocumentReader标签代替FlowDocumentScrollViewer标签。
48、通过代码与元素进行交互，导航浏览流文档的结构提供帮助：获取块级别元素，使用FlowDocument.Blocks集合；为从一个块级别元素移到下一个(或上一个)块级别元素，使用Block.NextBlock属性(Previous、SiblingBlocks集合)；许多块级别元素可能包含其他元素。
49、修该流文档内部的文本，最简便的方法是会用Span元素明确地隔离希望改变的内容。Span.Tag进行标识。
50、修该内容时，不能遍历段落中内联级别元素的集合。
51、文本对齐，TextAlignment属性。使用名为"最佳段落布局"的WPF特性，确保尽可能均匀地分配空白空间。FlowDocument.IsOptimalParagraphEnabled属性设置为true。
52、注意：基本的对齐算法每次只调整一行。WPF的最佳段落对齐特性使用全局的适应算法，会检查后续几行。然后选择能在整个段落中平衡单词空间的位置进行换行，从而为所有行付出最小的代价。
53、在比较窄的窗口中，可将FlowDocument.IsHyphenationEnabled属性设置为true。WPF会在需要的地方分割较长的单词。WPF使用断字字典(hyphenating dictionary)确保连字符位于合适的位置(在两个音节之间断开单词)。
54、只读流文档容器，WPF提供了3个：FlowDocumentScroolView、FlowDocumentPageView(开销大，将内容分配到页面中国，需要执行额外计算)、FlowDocumentReader(开销最大)。
55、TextBlock控件，显示少量流内容，如控件标签以及超链接。根本不适合显示块级别元素。
56、缩放，容器的Zoom属性，将内容的尺寸设置为百分比值。FlowDocumentScroolView提供了一个具有缩放华东的工具栏，用于设置缩放百分比。将IsToolbarVisible属性设置为true。
57、FlowDocumentPageView、FlowDocumentReader容器，总会显示缩放华东条。
58、创建页面和列，
59、注意：Floater元素倾向于使他们自身和一列同样宽。Figure元素很容易地跨越多列。
60、FlowDocument类提供的控制列的属性和文档中单个Paragraph元素提供的控制列的属性。
61、从文件加载文档，需要使用System.Windows.MarkUp名称空间中的XamlReader类，将内容动态加载到容器中。
62、打印，为容器调用Print()方法即可。显示Windows Print对话框。打印是通过命令工作的。
63、流文档还支持用于查找、缩放以及页面导航的命令。命令也具有键绑定。Ctrl+P组合键绑定。可取消。
64、编辑流文档，RichTextBox控件。它不再与过时的RTF标准捆绑在一起，在Word处理程序中可看到RTF标准。将其内容存储为FlowDocument对象。 
65、RichTextBox控件提供了丰富的编程模型，支持大量的扩展功能，可将它们嵌入到自己的逻辑中。缺点：体现在速度方面(有些缓慢)。
66、注意：RichTextBox控件不支持只读流文档容器支持的全部功能。对于缩放、分页、多列显示以及查找等功能，都不支持。
67、加载文件，
68、TextRange类，封装了文本块。它能将文本从一种格式转换为另一种格式，并应用格式。
69、注意：DataFormats.XamlPackage格式和DataFormats.Xaml格式在本质上是相同的。
70、XAML包格式不是真正的标准---只是WPF提供的一个功能，以使串行化文档变得更容易。
71、保存文件，需要提供两个TextPointer对象---一个用于指定内容的开始点，另一个用于指定结束点。
72、XAML包和RTF格式需要非托管代码权限。
73、设置所选文本的格式，
74、注意：不需要编写代码逻辑未选择的文本应用粗体、斜体以及下划线格式。RichTextBox控件支持来自EditingCommands类的ToggleBold、ToggleItalic以及ToggleUnderline命令。
75、RichTextBox.Selection属性，提供了用于封装当前所选文本的TextSelection对象。ApplyPropertyValue()方法改变选择文本对象的依赖项属性。
76、TextSelection。GetPropertyVlaue方法检查是否已经应用过粗体格式。
77、获取单个单词，RichTextBox控件缺少的一个功能是在文档中隔离特定的单词。获取最近单词的唯一方法是逐字符地进行移动，并检查空格。WPF编辑团队的Prajakta.Joshi曾在http://tinyurl.com/ylbla4v 给出了一个较完整的解决方案，用于检查单词断开的情形。
78、注意：RichTextBox控件拦截并挂起了MouseUp和MouseDown事件。处理PreviewMouseDown事件。
79、在RichTextBox控件中放置UIElement对象，将IsDocumentEnabled属性设置且true。但会造成各种奇怪的可用性问题。
80、固定文档，使用XPS标准的文档。它们用于准备打印的文档，能在任何输出设备上分发和打印，且相对于源文档完全保真。使用精确的固定布局，支持字体嵌入，且不能被任意地重新布局。
81、Windows提供了能够在任何应用程序中创建XPS文档的打印驱动程序，并提供了允许显示XPS文档的查看器。
82、注意：在后台，XPS文件实际上是包含压缩文件库的ZIP文件，包括字体、图像以及用于每一页的文本内容。为浏览XPS文件中的这些内部内容，可将扩展名改为.zip并打开它。XPS文件格式。
83、显示XPS文档，使用DocumentViewer容器，不仅提供了用于查找和缩放的控件，还提供了一组与流文档容器类似的属性、方法以及命令。
84、XpsDocument类，GetFixedDocumentSequence()、AddFixedDocument()、SignDigitally()和RemoveSignature()。
85、批注，为流文档和固定文档添加注释和提示。可用于建议修订、强调错误或标志重要的信息。
86、WPF提供两种类型的批注：突出显示(为文本应用半透明的颜色)、便签。
87、所有4个WPF文档容器都支持批注。使用批注两个步骤：使用一些初始化代码手动启用批注服务；需要添加控件(如工具栏按钮)，让用户能够添加希望支持的批注类型。
88、批注类，WPF批注系统依赖于System.Windows.Annotatons和System.Windows.Annotations.Storage名称空间中的类。AnnotationService类(管理批注功能)；AnnotationStore类(改立批注的存储，抽象类，且目前只有一个派生类XamlStreamStore(将批注串行化基于XML的格式))；AnnotationHelper类(提供了位数不多的用于处理批注的静态方法)。
89、提示：AnnotationStore和AnnotationHelper类(最适于实现由用户启动的批注更改)都提供了用于创建和删除批注的方法。前者对当前在文档容器中选择的文本进行操作，通过代码操作批注。
90、启用批注服务，当窗口第一次加载创建AnnotationService对象。创建批注服务非常简单---只需要为文档阅读器创建AnnotationService对象，并调用AnnotationService.Enable()方法(需要传递AnnotationStore对象)即可。
91、创建批注，操作批注有两种方式，AnnotationHelper类的方法创建批注(CreateTextStickyNoteForSelection和CreateInkStickyNoteForSelection)、删除批注(DeleteTextStickyNoteForSelection和DeleteInkStickyNoteForSelection)，应用突出显示(CreateHighlightsForSelection和ClearHighlightsForSelection)。另一种方式，使用AnnotationService提供的相应命令。
92、Toobar类非常智能，它能自动将CommandTarget属性设置为具有交点的元素。
93、使用System.Security.Principal.WindowsIdentity类获取当前用户的Windows用户账号名称。
94、注意：当使用ApplicationCommands.Print命令打印包含批注的文档时，会以批注显示时的样式打印批注。
95、检查批注，AnnotationStore对象使用GetAnnotations()方法，获取它所包含的所有批注。Annotation对象，只是为批注保存XML数据的简单封装器。很难从Anchors和Cargos属性中提取信息。Based64编码格式的字符串文本。
96、获取文本，使用XmamlReader进行反串行化。
97、检索与文档中的什么位置锚定批注相关的信息。使用AnnotationHelper类的GetAnchorInfo()方法。
98、WPF的批注功能并不强大。没有现成的方法用于修改批注，为了编辑批注，需要删除并重新创建批注。
99、响应批注更改，AnnotationStore类提供了4个事件---AnchorChanged、AuthorChanged、CargoChanged、StoreContentChanged。
100、注意：批注事件在更改发生后引发，无法插入扩展批注动作的自定义逻辑。
101、在固定文档中保存批注，直接将批注存储到XPS文档文件中。需要使用System.IO.Packaging名称空间提供的打包支持即可。
102、自定义便签的外观，StickyNoteControl类，编写IsActive属性的样式触发器。
103、XPS模型为WPF的打印功能提供了支持。


第 29 章 打印
1、WPF完全重新规划了打印模型，将所有编码围绕如下单一要素进行组织:System.Windows.Controls名称空间中的PrintDialog类。
2、基本打印，为使用PrintDialog类提交打印作业，需要使用以下两个方法之一：PrintVisual()方法，继承System.Windows.Media.Visual的类；PrintDocument()方法，用于打印所有DocumentPaginator对象。
3、打印元素，PrintVisual，缺少页边距控制只是使用这种方法进行打印所面临的局限性的开始。
4、打印机，600dpi和1200dpi是更常见的分辨率。
5、Print对话框存在的问题，封装了低级的名为Win32PrintDialog的内部.NET类(封装了由Win32 API提供的Print对话框)。使用PritDialog对话框让用户指定打印设置，然后使用XpsDocumentWriter类(提供了将内容异步发送到打印机的功能)实际打印内容。
6、变换打印输出，Transform，改变渲染它们的方式。可视化元素一次只能使用一种方式放置它们自身。
7、PrintVisual()方法只考虑制定元素机器子元素，而不考虑父元素的细节。
8、从PrintableAreaWidth和PrintableAreaHeight属性获取页尺寸。
9、打印不显示的元素，通过代码创建可视化元素。
10、打印文档，使用PrintDocument()方法打印文档中的内容。DocumentPaginator是特殊类，获取内容页，将内容分割到多页中，并当需要时提供每一页。每页由一个DocumentPage对象表示。
11、为FlowDocument获取DocumentPaginator对象，技巧是将FlowDocument对象转换成IDocumentPaginatorSource接口类型，然后使用DocumentPaginator属性。
12、打印批注，WPF提供两个继承自DocumentPaginator的类。FlowDocumentPaginator对象用于对流文档进行分页；FixedDocumentPaginator对象用于对XPS文档进行分页。
13、WPF只提供一个用于分页的共有具体类，即AnnotationDocumentPaginator类(用于打印具有关联批注的文档)。
14、在文档中打印输出中控制页面，基本技巧是拦截PrintDialog对页面的每个请求，然后在传输页面之前调整页面。GetPage()，基本策略是从页面中提取Visual对象，并将它放到一个新的ContainerVisual对象中。
15、题头不被视为主文档的一部分，且与文档内容分别进行单独定位。
16、自定义打印，打印元素的技术更灵活，且开销更低。
17、使用可视化层中的类进行打印，ContainerVisal类(简化的可视化元素)；DrawingVisual类(继承自ContainerVisual，并添加看RenderOpen和Drawing属性)。
18、DrawingContext类，
19、除了用于为所有内容计算最合适的位置所需的良好数学知识之外，这是创建相当美观的打印输出所需的全部要素。
20、自定义多页打印，可视化对象不能跨越多页。使用打印流文档时使用的类：DocumentPaginator类。
21、StoreDataSetPaginator类本身具有一定的灵活性。不能处理具有不同模式的数据。
22、打印设置和管理，将PrintDialog对象保存为窗口的成员变量。通过两个属性封装了打印机设置:PrintQueue和PrintTicket。
23、打印页面范围，使用PageRange分组框中的Pages文本框，让用户从大量打印输出中的一部分。PrintDialog.UserPageRangeEnabled属性。
24、管理打印队列，PrintServer对象。可传递指向网络上打印服务器的UNC路径。
25、注意：可暂停(或恢复)整个打印机或单个打印机作业。使用ControlPanel中的Printers图标执行两个任务。
26、通过XPS进行打印，WPF支持两种互补的文档类型。XPS文档被冻结在合适的位置，并精确地保持其原始形式。
27、为打印预览创建XPS文档，打印预览；异步打印。
28、XpsDocumentWriter类，主要是围绕项XPS文档写入内容的Write和WriteAsync方法。
29、写入内存的XPS文档，直接将XPS内容写入MemoryStram对象中。为XPS内容创建包。
30、通过XPS直接打印到打印机，
31、异步打印，
32、注意：在Windows中，所有打印作业都是异步进行。


第 VIII 部分 其他主题
第 30 章 与Windows窗体进行交互
1、访问互操作性，
2、评估下总目标是很重要的。
3、注意：数据访问、验证规则、文件访问等，应当已被抽象出来并放到单独的类。
4、混合窗口和窗体，
5、为WPF应用程序添加窗体，VS中，第一次添加窗体时，VS会为所有需要的Windows窗体程序集添加引用。
6、提示：更好地分离WPF和Windows窗体内容，可选择在单独的类库程序集中放置"外来的"内容。
7、为Windows窗体应用程序添加WPF窗口，VS不允许直接在Windows窗体应用程序中创建新的WPF窗口。可添加来自其他WPF项目的用于定义WPF窗口的已有文件。还需要为WPF核心程序集添加引用。如使用非模态地显示窗口，需要使用额外的待确保正确的键盘支持。
8、提示：添加所需的WPF引用时有一种快捷方法，可添加WPF用户控件，会使VS自动添加这些引用。
9、显示模态窗口和窗体，Form.ShowDialog()方法返回DialogResult枚举值，而Windows.ShowDialog()方法返回true、false或null。
10、显示非模态窗口和窗体，面临的挑战是键盘输入由根应用程序接收，且需要传递给合适的窗口。
11、Windows窗体应用程序内部非模态地显示WPF窗口，就必须使用静态的ElementHost.EnableModelessKeyboardInterop()方法。还需要引入WindowsFormsIntegration.dll程序集。
12、ElementHost类为Windows窗体应用程序添加了消息过滤器。
13、在WPF中显示非模态的Windows窗体，需要使用类似的WindowsFormsHost.EnableWindowsFormInterop()方法。
14、基于元素的互操作支持允许在同一窗口中集成不同类型的元素，但不允许嵌套多层。
15、启用Windows窗体控件的可视化风格，EnableVisualStyle()方法。是在System.Windows.Forms.Application类中定义的。该类构成了WPF应用程序的核心。
16、创建具有混合内容的窗口，
17、WPF和Windows窗体"空域"，为在同一个窗口集成WPF和Windows窗体内容，需要能隔离出窗口的一部分，用于"外来"内容。
18、空域规则(airspace rule)，该规则指示WPF和Windows窗体必须总是使用它们自己的不同窗口区域，即它们专门管理的区域。两个区域具有不同的窗口句柄或hwnd这一事实造成的。每个句柄单独地加以管理、渲染和刷新。
19、窗口句柄通过Windows操作系统进行管理。在经典的Windows应用程序中，每个控件都是独立窗口，意味着每个控件真正拥有不同部分的屏幕区域。
20、在WPF中，窗口模型是完全不同的-----只有单独的顶级窗口句柄，且WPF引擎组织整个窗口。
21、注意：有一些WPF元素使用单独的窗口句柄。包括菜单、工具提示以及组合框的下拉部分，所有这些严肃都需要具有能够扩展出窗口边界的能力。
22、在WPF中驻留Windows窗体控件，使用WindowsFormsHost类，可包含Windows窗体，通过其Child属性提供的。VS没有为该WindowsFormsHost控件提供设多少计时支持。
23、将Windows窗体控件的属性绑定到WPF元素，只需设置WPF元素的依赖属性，并根据需要调整BindingDirection。
24、使用熟悉的XAML语法为Windows窗体控件链接(hock)事件。不是路由事件。
25、WPF和Windows窗体互操作功能的最佳特征：不影响代码。
26、使用WPF和Windows窗体用户控件，WindowsFormsHost元素限制只能包含一个Windows窗体控件。使用窗体容器控件，但其不支持XAML内容模型，需要以编程的方式填充容器控件的内容。更好的方法是创建爱你Windows窗体用户控件。
27、Pro.NET 2.0 Windows Forms and Custom Controls in C#。本书作者。
28、ActiveX互操作，WPF没有为ActiveX互操作提供直接支持，Windows窗体提供RCW(Runtime Callable Wrapper)形式的扩展支持。WPF需要叠加两个层次的互操作层。
29、在Windows窗体中驻留WPF控件，只有当在WPF用户控件中放置WPF内容时才能得到设计时支持。ElementHost。
30、WPF用户控件只有在经过编译之后，才能在窗体中使用。
31、访问键、助记码和焦点，
32、注意：加速键的语法，WPF中使用一条下划线。Windows窗体使用&符号确定。必须使用"&amp;"进行转义，因为在XML中&是特殊符号。
33、属性映射，WPF通过属性转换器的特性提供了一些额外支持。WindowsFormsHost类和ElementHost类都提供了PropertyMap集合(负责将属性名和标识执行转换方法的委托关联起来)。
34、标准属性映射，
35、注意：属性映射动态地进行工作。
36、Win32互操作，使用Win32 API或在C++ MFC应用程序中放置WPF内容也是可以的。使用System.Windows.Interop.HwndHost在WPF中驻留Win32。
37、HwndHost是进入传统的C++和MFC应用程序世界的大门，也可用于继承托管的Direct
内容。
38、DirectX编程更复杂。http://msdn.microsoft.com/directx.
39、HwndSource类可将任何WPF可视化对象或元素封装到hwnd中，conger可将其插入到基于Win32的应用程序。将HwndHost.RootVisual属性设置为顶级元素，然后将HwndSource放置到窗口中。


第 31 章 多线程
1、编程约定(convention)
2、插件模型(add-in model),WPF应用程序可动态加载和使用单独编译过的具有一些有用功能的组件。
3、注意：多线程和插件模型都是高级主题。
4、了解多线程模型，多线程是指同时执行多块代码。
5、WPF支持单线程单元(Single-Thread Apartment)模型。核心规则：WPF元素具有线程关联性(thread affinity);具有线程关联性的WPF对象都在类层此次的某个位置继承自DispatcherObject类；线程运行整个应用程序并拥有所有WPF对象。
6、DispatcherObject类提供了少量成员，用于核实为了使用特定的对象，代码是否在正确的线程上执行，并且是否能切换位置。
7、Dispatcher类，DispatcherObject类。
8、调度程序(dispatcher)管理在WPF应用程序中发生的操作。调度程序拥有应用程序线程，并管理工作项队列。当应用程序运行时，调度程序接受新的工作请求，并且一次执行一个任务。
9、大多数应用程序保持简单方式，并坚持使用一个用户界面线程和一个调度程序。然后使用多线程管理数据操作和其他后台任务。
10、注意：调度程序是System.Windows.Threading.Dispather类的实例。所有与调度程序相关的对象都位于System.Windows.Threading名称空间(WPF新添加的一个名称空间)。
11、使用静态的Dispatcher.CurrentDispather属性检索当前线程的调度程序。
12、封送(marshal).
13、大多数情况下，不会直接与调度程序交互。但会花费大量时间使用DispatcherObject类的实例。每个WPF元素都继承自这个类。ispatcherObject实例是链接到调度程序的简单对象----是绑定到调度程序线程的对象。
14、DispatcherObject类的三个成员：Dispatcher、CheckAccess()、VerifyAccess()。
15、WPF对象为保护自身会频繁调用VerifyAccess()方法。捕获非法操作，并跑出InvalidOperationException异常。
16、通过WPF对象的调度程序的应用(这个调度程序也拥有应用程序中的窗口和所以其他WPF对象)。就可调用Dispatcher.Invoke()方法将一些代码封送到调度程序线程。本质上，BeginInvoke()方法会将代码安排为调度程序的任务。
17、Dispatcher.BeginInvoke()方法具有两个参数，第一个指示任务的优先级。第二个参数指向一个方法的委托。复杂的处理过程更新用户界面，最好将这些代码分解到单独的方法中。
18、注意：BeginInvoke()方法还有返回值。返回一个DispatcherOperationd对象(可跟踪封送操作的状态，并决定代码何时已实际执行完毕)。很少使用。
19、记住，如果在执行耗时的后台工作，就需要在单独的线程中执行这个操作，然后将操作结果封送到调度程序线程。在传递给Dispatcher()方法中执行耗时的代码是不合理的(控制在5毫秒内)。所有工作都在调度线程上进行，意味着以非线程应用程序采用方法连接到调度程序。
20、注意：调度程序还提供了Invoke方法，将制定的代码封送到调度程序线程。它会拖延线程直到调用程序执行您指定的代码。如需要暂停异步操作直到用户提供一些反馈信息，可使用Invoke()方法。
21、BackgroundWorker类，最简单且最安全的方法：System.ComponentModel。BackgroundWorker组件(.NET2.0版本提供)。在单独线程中运行耗时的任务提供了一种非常简单的方法。它在后台使用调度程序，并使用基于事件的模型对封送问题进行抽象。
22、执行异步操作的方法：手动创建爱你新的Sytem.Threading.Thread对象。
23、编写良好的多线程代码的技术---以及将要使用的.NET类。
24、BackgroundWorker组件支持另外两个功能：进度(progress)事件和取消消息。
25、注意：如果从开始到结束只有一个异步任务在后台运行，使用BackgroundWorker组件是非常完美的。其他，需要使用.NET的线程支持来设计自定义解决方案。
26、简单的异步操作，创建BackgroundWorker对象(DoWork事件、ProgressChanged事件、RunWorkerCompleted事件)，运行BackgroundWorker对象(RunWorkerAync)，
27、当BackgroundWorker对象开始执行，从CLR线程池提取一个自由线程，然后从这个线程引发DoWork事件。RunWorkerCompleted事件以通知应用程序，这个事件在调度程序线程引发，在该线程上您可访问共享数据和用户界面。
28、BackgroundWorker对象使用在.NET2.0版本引入的几个多线程类，包括AsyncOperationManager类、AsyncOperation类以及SynchronizationContext类。本质上，BackgroundWorker对象使用AsyncOperationManager类管理后台任务。
29、AsyncOperationManager类具有一些内置的只能行为---能获取当前线程的同步上下文。Windows中，WindowsFormsSynchronizationContext对象；WPF获取DispatcherSynchronizationContext对象。
30、跟踪进度，WorkerReportsProgress属性。提供和显示执行进度信息是两个步骤。DoWork事件需要调用BackgroundWorker.ReportProgress()方法。引发ProgressChanged事件(从用户界面线程引发的)。
31、支持取消，为长时间执行的任务添加取消支持同样也很容易。将WorkerSupportsCancellation属性。调用CancelAsync()方法。执行任务的代码需要显式地检查取消请求，执行所有清除操作。DoWork事件中还需显式地将DoWorkEventArgs.Cancel属性设置为true。
32、WPF的线程规则。从其他线程安全地更新控件。

第 32 章 插件模型
1、插件(add-in，也称plug-in)是应用程序能够动态发现、加载和使用的单独编译过的组件。
2、两个基本要素是接口(接口用于定义协定，应用程序通过协定和插件进行交互，并且插件也通过协定与应用程序进行交互)和反射(应用程序可动态地从单独程序集中发现和加载插件类型)。
3、需要设计一种方法来定位插件，并需要确保正确地管理插件。
4、.NET提供了预先构建好的插件模型(使用接口和反射)。它为许多繁琐的任务(如发现和驻留)提供了低级的处理。
5、在MAF和MEF两者间进行选择，.NET不是仅有一个插件框架，而是有两个插件框架。
6、.NET3.5引入托管插件框架(Managed Add-in Framework，MAF)。.NET4引入托管扩展性框架(Managed Extensibilty Framework,MEF).
7、MAF是这两个框架中较为可靠的框架。允许从应用程序中分离出插件，它们只依赖于您定义的接口。特别始于支持第三方插件。
8、MAF是复杂框架，设置插件管道很繁琐。严格的、接口驱动的插件模型。
9、MEF是轻量级选择，目的是使用实现可扩展性就像是将相关的程序集复制到同一个文件夹那样容易。是自由使用系统，允许根据部件集合构建应用程序。对于设计可组合的应用程序(composable applications)。显著危险是太松散。http://tinyurl.com/37s2jdx.
10、组合的应用程序，Microsoft的符合应用程序库(Composite Applicaion Library，CAL)，该库的原来的代码名称是Prism。
11、MEF是用于构建各种模块化.NET应用程序的通用解决方案。而CAL却只针对WPF应用程序。
12、了解插件管道，插件模型必须创建7个单独组件。插件模型的核心是插件管道(pipeline)，它是一系列组件，允许宿主应用程序与插件进行交互。在管道的一端是宿主应用程序，另一端是插件，中间是控制交互的5个组件。
13、管理的工作原理，协定(contract)是插件管道的基石，提供了一个或多个接口(定义了宿主应用程序如何与插件进行交互，以及插件如何与宿主应用程序进行交互)。协定程序集还可包含自定义的计划，用于在宿主应用程序和插件之间传递数据的可串行化类型。
14、插件管道的设计充分考虑了可扩展性和灵活性。宿主和插件不能直接使用协定。它们使用各自版本的协定，称为视图。宿主视图和插件视图。通常，视图包含与协定中的接口紧密匹配的抽象类。
15、协定和视图完全相互独立。适配器负责将这两部分链接在一起。适配器通过提供同时继承自视图类并实现了协定接口的类，执行这一链接。
16、宿主应用程序调用宿主视图中的方法。宿主视图是抽象类。在背后，应用程序实际上通过宿主视图调用宿主方适配器中的方法。然后，宿主方适配器调用协定接口中的相应方法，该方法是由插件方适配器实现的。最后，插件适配器调用视图中的方法(由插件实现的，负责执行实际工作)。
17、更高级的适配器，版本问题。只要在协定中继续使用相同的接口，就可独立地更新应用程序或其插件，而不需要改变它们的交互方式。提供新功能。使用插件模型，可用不同的方法实现向后兼容。不是提供多个接口，而是在协定中只提供一个接口，并使用适配器创建不同的视图。
18、一旦为插件设置完整管道，就可以添加更多插件而不必做很多工作。
19、插件文件夹结构，为使用插件管道，必须遵循严格的目录结构。目录结构和应用程序相分离。插件组件必须被安排到使用特定名称的字目录中。同一个文件夹既作为应用程序文件夹又作为插件的根目录(常见部署)。
20、为使用部署模型准备解决方案，VS没有为创建使用插件的应用程序提供模板。需自行创建这些文件夹，并设置VS项目使用这些文件夹。
21、引用，并不希望一同复制包含引用的程序集和被引用的程序集，而是依赖于插件模型的目录系统。防止复制引用的程序集。
22、提示：为正确配置插件项目，需要完成一定的工作。
23、创建使用插件模型的应用程序，通过插件模型支持不同的图片处理方式。
24、协定，为应用程序定义插件管道的开始点是创建协定程序集。两项内容：定义宿主将如何与插件进行交互，以及插件如何与宿主进行交互的接口；用于在宿主和插件之间交换信息的自定义类型(必须是可串行化的)。必须继承自IContract接口，并必须使用AddInContract特性。添加System.AddIn.Contract.dll程序集。配置生成目录，必须将协定程序集放到插件根目录的Contracts子目录。
25、字节和数组都是可串行化的。
26、插件视图，提供了镜像协定程序集的抽象类，并被用于插件一方。必须使用AddInBase特性修饰插件视图类。添加System.AddIn.dll程序集引用。必须将其放到插件根目录的AddInViews子目录。
27、插件，创建可供使用的插件，需要使用继承自抽象的视图类的具体类。创建抽象的视图类的派生类，并使用AddIn特性修饰该类。需要两个引用：System.AddIn.dll和对插件视图项目的引用。必须将插件视图引用的Copy Local属性设置为false(插件视图不能和插件部署在一起)。目录位于插件根目录的AddIns目录。
28、插件基础框架实际上复制了原始数组，并将副本传递到插件的应用程序域。
29、插件适配器，实现了协定接口。当调用协定接口中的方法时，插件适配器会调用插件视图中的相应方法。必须继承自ContractBase类(继承自MarshalByRefObject类)，能够跨越应用程序域边界调用适配器。必须使用AddInAdapter特性。必须提供接收恰当视图类的实例作为参数的构造函数。需要三个引用：System.Addin.dll程序集、System.AddIn.Contract.dll程序集、协定项目引用。放到插件根目录的AddInSideAdapters子目录。
30、宿主视图，是紧密镜像协定接口的抽象类。不需要任何特性，必须和宿主应用程序一起部署。两种方式，改变输出路径或将Copy Local属性设为true。宿主视图将自动复制到和宿主应用程序相同的文件夹中。
31、宿主适配器，继承自宿主视图。它接收一个实现了协定的对象，然后调用宿主方适配器的方法时使用该对象。使用两个成员字段，保存了当前协定对象的引用，以及System.AddIns.Pipeline.ContractHandle对象的引用。需要System.AddIn.dll、System.AddIn.Contract.dll、协定程序集和宿主视图程序集(Copy Local为false)。输出目录是插件根目录的HostSideAdayeers子目录。
32、ContractHandle对象管理插件的生命周期。
33、宿主，只需要指向宿主视图项目的引用。宿主视图是插件管道的入口点。只需查找可用的插件，激活希望使用的插件，然后调用由宿主视图提供的方法即可。
34、查找可用的插件---称为"发现"。通过System.AddIn.Hosting.AddInStore类的静态方法进行工作。加载插件，只需要提供插件的根路径，并调用AddInStore.Update()方法。插件系统会创建两个具有缓存信息的文件。
35、PipelineSegments.store(提供了与不同视图和适配器相关的信息)，将被放到插件根目录中。AddIns.Store(提供与所有可用插件相关的信息)，被放到AddIns子目录中。