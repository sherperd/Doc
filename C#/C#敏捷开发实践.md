序
1、拥抱敏捷，编写自适应代码，轻松应对恼人的需求变更。
2、表达意见的前提是首先要理解书中讲解的本意。
3、切记用个人主观情绪来表达对技术观点的不满。
4、明悉技术的概念和原理，了解其优缺点，且知道其适用场合。


前言
1、自适应代码(Adaptive Code)，无需大量返工，代码即可自动适应后续新的需求和无法预见的场景。
2、编写代码不能急于求成。
3、对于需求，不变的主题就是变化。
4、管理需求变更是软件项目成败的一个关键因素。两种方法论。
5、瀑布方法论，要求开发人员必须遵循严格的流程。不灵活。
6、敏捷方法论，主旨是拥抱变化。
7、只要在正确的方向上前进。
8、没有完备的单元测试，重构动作肯定会造成很多错误；没有重构，代码会变得臃肿、僵化且难以理解。
9、自适应工具，使用Git源代码控制从GitHub下载代码。VS
10、截图在高对比度主题下获取。
11、MSTest单元测试。NUnit。
12、http://aka.ms/AdaptiveCode_CodeSamples
13、微软出版社的免费电子书：http:aka. ms/mspressfree。


第 一 部分 敏捷基础
1、编写代码是软件开发的核心工作，而编写好用的代码有很多方式。
2、软件产品的质量是无法与代码的质量割裂开来的。
3、高质量的软件产品，开发人员必须努力确保编写的代码是可维护的、可读的，且经过测试的。具备一定的自适应变更的能力。
4、敏捷流程(Agile Process) 。快速得到反馈、响应并调整工作焦点。
5、敏捷实践(Agile Practice) 

第 1 章 Scrum介绍
1、Scrum是一个具体的项目管理方法论。核心概念：以迭代的方式为软件产品增加价值。是目前敏捷方法论中应用最广泛、最常见的一个流程实现。
2、迭代被称为冲刺(spint) 。
3、整个产品的工作项都会在产品积压工作(product backlog) 上按优先级排列。
4、冲刺积压工作(sprint backlog) 
5、Scrum中工作项的单位是故事(story) 。产品积压工作实际上就是一个排好序的候选故事队列。
6、流程

7、开发团队内部和外部相关角色人员会产生一些文档工件。
8、Scrum与瀑布，瀑布方法论以文档为核心。
9、在代码级别响应变更是最困难的，也是最重要的。
10、能工作的软件就是这个软件产品最重要的文档。
11、Scrum设置了一些度量标准，用于反映项目进度和整体健康状况。易用的在线文档(如Wiki) 常用工具。
12、Scrum通过迭代改进软件产品，改进开发流程。
13、一个声称自己可以优雅地处理变更但很难在代码层次实现的流程是没有意义的。
14、Scrum的不同形态，变体(variant)。来源于诸如极限编程(eXtreme Programming，XP) 。三个分支：增强的Scrum、弱化的、根本不是。
15、实践活动，测试先行及结对编程。
16、角色和职责，只有团队成员都遵循它才会起作用。
17、产品负责人(Product Owner，PO) ，要对最终产品负责。责任：决定要构建哪些特性；根据业务价值设定特性的优先级；接受或拒绝“已完成”工作。时刻准备着为团队服务，给他们清晰呈现项目的愿景。制定验收标准来检验一个故事是否已经完成及是否可以展示。
18、冲刺的不可破坏性保证开发团队能够在整个冲刺过程进行中心无旁骛地朝着既定目标努力。
19、Scrum主管(Scrum Master，SM) ，负责在冲刺进行过程中为团队隔离所有外部影响，且处理团队成员在每日站立会议上提到的各种影响开发的障碍。组织站立会议，确保开发团队成员都出席，并且记录会议纪要以防遗漏某些行动项。
20、产品负责人要对做出怎样的产品负责，Scrum主管则对如何完成产品的流程负责。
21、站立会议的真正意图是为了让所有与会者都能大概了解到自己的工作项进度和状况，而不是做工作汇报。
22、开发团队，全科专家(generalizing specialist) ，应能熟练使用多个领域的技术，且精通或特别擅长其中的某个领域。
23、团队开发人员的技能重合能够避免团队中出现筒仓现象。妨碍全体开发人员的参与度。不利于业务的开展，业务的某个领域会过度依赖单个“专家”开发人员的能力(压力大)。
24、软件测试人员负责保证所开发软件的质量。在一个故事开始前，规划自动化测试以保证故事符合各种预先定义的验收标准。
25、Scrum流程中的所有角色都可以划分为两类：“猪”和“鸡”。参与程度。
26、工件，创建、评审和分解细化很多文档、图表和度量标准。文档的重要性。
27、结构化系统分析和设计方法(Structured System Analysis and Design Metgodology，SSADM) 。大设计优先(Big Design Up Front，BDUF) 
28、Scrum面板，保留几面墙的空间，太小面板将没有空间展示重要的细节。必备的，即视感。
29、神奇白板，白纸。
30、卡片，展示软件产品进度的不同元素。
31、产品，发布
32、最小可行发布(Minimum Viable Release，MVR) 。满足用户基本需求的一组特性。核心目的：引导项目尽早做到自筹资金并继续发展。
33、特性，史诗(epic) 。
34、最小可售特性(Minimum Marketable Feature，MMF)，界定一个发布需要界定的集合。
35、 主题(theme) ，指一组有着共同目标的故事。
36、对每个发布，特性三类：必需的、可选的、想要的。
37、用户故事，模板：作为[某个用户角色]，我想要[做某种行为]，以便于[给这个用户角色带来某种价值]。是从用户的角度出发编写。
38、需求收集，制作用户界面模型。使用UML图标来从技术角度上详细表达如何改动现有代码以满足这些新需求。
39、用户故事，分解为小任务。
40、质量保证(quality assurance，QA) ，验收。
41、以一个用户故事为依据，开发人员在分析阶段收集需求，然后准备好设计方案，接着做具体实现，最后按照验收标准做测试。
42、为每个用户故事执行一遍小规模的但完整的软件开发生命周期。有助于防范无用功。
43、用户故事是Scrum过程中最主要的工作重心。Scrum流程是通过使用用户故事的故事点数来激励团队成员的。冲刺会议上，团队成员为每个故事估算故事点数。
44、任务，比用户故事小的工作项。分层分解任务。
45、竖切，
46、技术债务，描述在一个用户故事生命周期内在架构设计和实现上所做的折中和妥协。
47、缺陷，三类：灾难性缺陷(Apocalyptic defect)、行为错误(Behavioral error) 、外观上的问题(Cosmetic issue)。
48、缺乏计划或不勤勉并不是人会犯错误的根本原因。
49、界面的表现也是用户对软件的期望之一。
50、让卡片意图更明确，特性和用户故事可使用索引卡，任务、缺陷和技术债务可使用即时贴(sticky note) 。
51、泳道，积压工作、开发、验收、完成。
52、选择没有绝对的对错，只有分析具体情况才能判断引入技术债务是对还是错。
53、技术债务象限图，债务偿还。
54、数字Scrum面板，开放信息，流程透明，反馈。
55、害怕和焦虑是人本身对未知的自然反应。
56、最好的工具总是那些易接触和没有约束的工具。
57、完成的定义(Definition of Done，DoD) ，所有用户故事都必须符合清晰的完成的定义。
58、完成状态，单元测试，通过所有测试；无误地提交到持续集成系统中，且成功；通过验收；不在同一个用户故事下的开发者相互实施的代码评审；撰写了适量用于沟通的文档；拒绝了不计后果的技术债务。
59、图表和度量标准，体现和诊断整个项目中存在的问题。尽量避免评测团队中个人层面的任何事情。
60、观察者效应，
61、使用三角测量法来调整估算工作量和实际工作量的差距。
62、故事点数，激励开发团队为每个冲刺的发布增加商业价值。用来衡量实现用户故事定义行为所需的工作量(包括整个生命周期的所有阶段：需求分析、方案设计、含单元测试的代码实现、测试验收、部署实验)。
63、故事点数值只对得出该估算点数值得开发团队才有意义。注意：不能用来表达工作量的绝对时长。根据以往实际时长范围对工作量进行粗略的估算。
64、速度
65、冲刺燃尽图，笔直的对角线也称为最吻合线(line of best fit) 。用于从故事层面上追踪实际的进度。
66、特性燃尽图，用来追踪特性完成的进度。
67、努力让项目重回正轨的重构工作将会是非常值得的。
68、brownfield(进行中) ，greenfield(未启动)
69、积压工作，列表，需要处理的待定工作项。
70、产品积压工作， 待实现的特性。花时间评估特性工作量有助于对这些产品积压工作上的特性进行排序，保证产品积压工作上所有的特性总是排好序的。
71、投资回报率(Return On Investment，ROI) 
72、错误的决定源自不准确的信息。
73、冲刺积压工作，即将开始。
74、冲刺，一周或四周。周中启动冲刺。
75、发布计划会议，
76、特性工作量估算，T恤码号。特性优先级。
77、冲洗计划会议，输出：所有承诺要在冲刺中完成的用户故事的估算。
78、计划扑克，详细介绍产品积压工作上的每个用户故事，要求每个人用故事点数来给故事的大小投票。
79、帕金森定律，大多数情况下，人们会应付工作直至耗尽所有可用的时间。
80、亲和估算，故事数目很大时。按照相对大小故事。
81、每日站会会议，围绕Scrum面板站立，不超过15分钟。保持高效：昨天做了什么？今天计划做什么？遇到了什么障碍？
82、重点：给所有团队成员公开昨天的实际进度以及今天的预计进度。
83、表情日历(niko-niko calendar) ，好、一般、糟糕。
84、易陷入问题的讨论。Scrum主管先记录问题，会后再组织相关的人一起开展讨论。
85、冲刺演示会议，
86、所有项目都应该持有积极开放的态度。
87、解释每个故事的功能范围以及该故事为整个项目的业务所提供的价值。保存整个讨论始终聚焦在正在展示的用户故事上，演示后再深入讨论。收集改进建议和意见。
88、自律是一种始终能够拒绝眼前诱惑而选择长期利益的能力。
89、冲刺回顾会议，复盘来评估整个冲刺的成功程度。整理需要保持的好行为及应该避免的不好行为。输出文档，下一次总结对比。
90、做得好的标准是什么？做得差的标准是什么？需要开始做什么？需要停止做什么？需要继续做什么？是否遇到任何意料之外的事情？
91、对事不对人，所有有关问题的畅所欲言都没错。要以恰当的方式建设性地指出问题。
92、讨论问题的目标是为了改善流程和产品。
93、有些重复性的工作做好了也会有收益。
94、通常人们会很快忘掉好习惯，而坏习惯却很容易如影随行。
95、回忆意料之外的事情，不论好坏。
96、讨论下一个冲刺的候选工作项排列优先级。
97、故事点数三角测量法，
98、Scrum日历，站立会议的时间问题。
99、Scrum和敏捷的问题。
100、僵硬的代码，死板的代码表现：缺少抽象，职责不清。不易测试。
101、抽象能用更简洁的表达来隐藏细节信息。
102、具有足够抽象的代码会更容易组织、理解、与其他代码通信、维护，且错误更少。
103、必须要确保每个层次(方法、类型定义以及程序集) 的代码实现都要基于单个明确的职责定义上。
104、必须假设未测试的代码是有缺陷的。
105、天钩与塔吊，
106、静态方法、静态类型(包括单例) 、使用new的对象创建。
107、接口、依赖注入、控制反转、工厂。
108、度量标准，源代码行数(source lines of code，SLOC) 。
109、单元测试覆盖率(units test coverage)，80%以上。
110、圈复杂度(cyclomatic complexity) 衡量代码中路径分支的数目。
111、定位问题很重要，但是理清问题发生的根源更困难。
112、确保代码是自下而上自适应的，让变更响应更容易，且能让开发工作完全聚焦在为每个冲刺增加业务价值的行动上。


第  2 章 依赖和分层
1、所有软件都有依赖。依赖项抽象了你编写的客户端代码要使用的功能。
2、应确保正确管理所有的依赖。高效管理。
3、没编写的代码就是最正确的代码。不存在的依赖就是管理得最好的依赖。
4、对软件的所有层次，从架构层子系统间的依赖到实现层每个方法之间的依赖。
5、要想轻松管理依赖，需要有清晰的认识并按照指导原则行动。
6、分层是一种常见的架构模式。
7、依赖(dependency)的定义，是指两个不同实体间的一种联系。
8、代码是服务端代码还是客户端取决于你看待代码的角度。
9、用于导入命名空间的using语句只是一个语法糖，它的目的只是为了减少你编写代码的工作量。
10、第一方(first-party)依赖。第三方依赖。
11、对象/关系映射器(Object/Relational Mapper，ORM) 。Entity Framework，NHibernate。
12、组织第三方依赖，最简单：在项目解决方案下创建一个名为Dependencies的文件夹。Nuget依赖管理工具，自动管理项目的第三方依赖，可下载依赖安装包，引用程序集，及依赖库升级到最新版。
13、使用有向图对依赖建模
14、依赖管理，
15、模式和反模式。
16、实现与接口，
17、接口的所有客户端都不应该知道接口要使用的具体实现。
18、new代码味道(code smell)，可能存在问题。
19、接口描述能做什么，接口的实现类则描述如何做。
20、代码重构无疑是一个无法立即产生可见效益的开发任务，因为所有修复问题的重构工作都不会附加有相应的业务价值。
21、问题：无法增强实现，依赖关系链，缺乏可测试性，更多的狎昵关系。
22、NHibernate使用会话来表示指向持久关系型存储(SQL Server，Oracle，MySQL)的连接。
23、可测试性非常重要，需要代码以一定的模式构建。
24、对象构造函数的替代方法，针对接口编码，使用依赖注入。
25、将两个具体类完全解耦，需要引入依赖注入(Dependency Injection，DI) 。
26、随从反模式。两个问题，第一个和开发人员的自律有关；第二个，不断膨胀的代码库会变得更加脆弱，很难适应后期的新需求。接口和接口的依赖项肯定不应该布置在同一个程序集内。
27、依赖关系链也会导致客户端之间的隐式依赖。
28、规则：把接口的实现与接口本身拆开，分别布置在不同的程序集中。可使用阶梯模式来拆分接口和相应的实现类。
29、阶梯模式，正确组织类和接口的方法。接口没有任何依赖，调用接口的客户端代码也不会有任何隐形依赖，接口的实现也同样只依赖其他仅包含接口的程序集。
30、客户端代码只需引用接口所在的程序集。
31、第三方库。可引用用于记录日志、域持久化和文档存储的自定义接口。简单接口把第三方的依赖隐藏在对第一方程序集的依赖后面。更换对第三方的依赖，只需为更换后的新接口编写一个新的适配器就可以。
32、相比单个巨型第三方库的更好选择应该是框架，后者比前者的规模大的多。
33、依赖解析，有时程序集在运行时并不可用。程序集，解析流程，

34、清楚程序集依赖以及修复方案理论和实践都会很有用。
35、公共语言运行时使用即时(JIT) 模型来解析程序集。每个程序集都有一个标识符。先搜索全局程序集缓存。app. config文件中的codeBase元素指定目标文件夹。应用程序的安装目录。
36、Fusion日志，用来调试公共语言运行时加载程序集失败的问题。打开Fusion日志开关然后查看记录到的日志结果。编辑Windows注册表，HKLM/Software/Microsoft/Fusion/Forcelog 1
KLM/Software/Microsoft/Fusion/LogPath C:/FusionLogs。用户界面程序。
37、不是所有的依赖都需要直接引用程序集，一种方式就是将服务代码部署为宿主服务。
38、服务，已知端点，两种创建代理的方式：添加服务引用或使用ChannelFactory类编码。
39、Web服务定义语言(Web Service Definition Language,WSDL) 文件(定义了服务的元数据描述、数据类型和可用的行为)的具体位置。
40、服务发现，两种方式：托管的和自组网的。
41、单一故障点(single point of failure，SPOF) 
42、IIS或Windows进程激活服务(Windows Process Activation Service，WAS)托管可发现的服务时，一定确保使用Microsoft AppFabric AutoStart功能。 
43、WS-Discovery标准。
44、REST化服务，非常适合开发需要跨平台的功能强大的服务。REST API。
45、创建REST(Representational State Transfer,表述性状态转译) 化服务的最大好处是客户端几乎没有任何依赖，只需一个所有语言的框架和库都提供的HTTP client实例。
46、ASP. NET Web API用来创建基于. NET Framework的REST服务。允许创建能直接映射为网络请求的方法。它提供了一个名为ApiController的基础控制器类。通过继承这个类并实现一些使用HTTP动作(GET、POST、PUT、DELETE、HEAD、OPTIONS、PATCH) 
47、使用Nuget管理依赖，将依赖称为包，程序集、配置、脚本、图像等任何需要的数据。
48、CorrugatedIron，它是一个用于存储Riak非Sql键值对的. NET Framework客户驱动程序。
49、制作包，发布官方商店。每个包都会有一个XML文件。
50、强大的Windows PowerShell。
51、通过分层将整个解决方案分为多个部分。
52、工具Chocolately，包是一些应用程序和工具。有点像Debian和Ubuntu系统上的包管理器apt-get。好处：简易安装、依赖管理及轻松使用。
53、分层(layering)，逻辑程序集组，组中的这些程序集在功能上是相关的。是一种架构模式。鼓励开发人员将软件组件看作是水平功能层。多个水平功能层。每层只能依赖它的直接下层。
54、常见的模式，
55、需要的分层数目与方案的复杂度有关，而方案的复杂度又与问题的复杂度相关。
56、总是追求很完美的方案是没有意义的。尽量从最简单的方案开始，后面有需要时才将它重构为更复杂的方案。
57、多层架构要比简单的两层划分方案耗费更多的开发时间，也无法及时获取重要的用户反馈。
58、逻辑层和物理层。
59、跨进程交互，跨越网络边界交互代价更大。
60、两层划分，两组逻辑相关的程序集：一组与用户界面直接相关，另一组与数据访问相关。
61、用户界面职责：为用户提供与应用程序交互的方式；向用户展示数据和信息；接收用户的查询或命令请求；验证用户的输入。
62、用服务API层代替了用户界面层。
63、每个层次都是由上层所需功能的抽象以及该抽象的实现的组合而成。
64、抽象漏洞(leaky abstraction) ，一个层次引用直接下层的部分实现。
65、数据访问层，职责：响应数据查询请求；序列化对象模型到关系模型，反序列化关系模型到对象模型。
66、持久话存储器，关系型：SQL Server、Oracle、MySQL、PostgreSQL；文档型：MongoDB、RavenDB、Riak等；辅助程序集，通过调用存储过程来执行查询/插入/删除命令，或通过EF、NHibernate将数据映射到关系型数据库。
67、两层架构，优点：应用程序只有一些琐碎的数据验证且没有多少业务逻辑；主要执行数据的创建、读取、更新和删除(CRUD) 操作；时间太仓促。缺点：预期或已确定有复杂的业务逻辑；已明确在一两个冲刺后会需要多于两层的架构。
68、三层划分，业务逻辑层(封装更复杂的处理逻辑)，职责：处理来自用户界面层的命令；为业务域的流程、规则和工作流建模(增加ORM组件，通过域驱动设计(domain-driver design，DDD))。通常部署在两个物理层上。
69、域模型应该没有任何依赖。独立程序集，包含如何指导对象/关系映射库映射到域模型的具体实现。
70、逻辑复杂或变更频繁，应引入逻辑层来封装这部分逻辑。
71、纵切关注点，审核、安全以及缓存等功能在每个逻辑层都有可能存在。使用日志手动追踪每个方法在调用和返回点处的代码行为来辅助调试。
72、与方法主题无关的代码，导致有效代码率降低。面向切面编程(Aspect-Oriented Programming，AOP) 是一种很常见的增加功能的优雅方式。PostSharp库，定义扩展属性追踪代码行为。
73、非对称分层，命令/查询职责分离(Command/Query Responsibility Segregation，CQRS) 。
74、命令/查询分离(CQS) ，命令--改变系统状态。查询--返回值，不改变状态。
75、命令/查询职责分离，是方法层次上的命令/查询分离原则在架构层上的应用。命令和查询可能需要以不同的路径通过不同的逻辑层达到最优处理的效果。
76、ACID标准(atomic，consistant，isolated，durable，原子、一致、可隔离、持久) 


第 3 章 接口和设计模式
1、接口，一个非常强大的构件，interface代表了一个非常强大的范式。接口定义的扩展点会让你的代码具有非常好的适应变更的能力。
2、接口和类协同发挥最优作用：能够防止实现的变更影响客户端代码，还可充分利用多态的能力。
3、只有以正确的方式，谨慎且适量地使用接口才能为项目带来好处。
4、接口是什么，定义了类的行为，但并不定义如何实现行为。它需要一个类实现所定义的行为。
5、特性是指接口要表达和启用的概念。
6、语法，接口可包含属性、方法和事件。任何元素不需要设定访问权限，默认都是公开的。实现接口的类必须以public方式实现接口中的所有元素。
7、多重继承会引起钻石继承问题。当一个类继承于两个或更多包含相同方法的基类时，派生类应该使用哪个方法呢？
8、显式实现，客户端代码引用的必须是一个接口的实例，而不能是接口实现类的实例。
9、模型-视图-表示器(MVP) 模式。
10、多态(polymorphism)，一个类型的对象可以隐式表现为另一种不同类型的能力。在编程开发中是一个极为有用的能力。
11、多态是设计模式和接口特性的基础，它能让每个实现既定接口的类都变得有用，无论这些类已经写好或仍在构思中。
12、接口把行为传递给所有实现它的类以形成多态的能力。
13、自适应设计模式，
14、四人组，《设计模式：可复用面向对象软件的基础》，二十年，对软件开发界，相当于四个冰河时代。
15、好的设计模式是接口和类之间可重用设计的精华。
16、设计模式很容易被忽视或滥用。应在正确的场合使用正确的模式。
17、代码结构设计。
18、空对象模式，避免引发意外的NullReferenceException异常，也无需到处检查对象是否为null。应让产生问题的源头来完成检查工作。
19、所有空对象实现都应该递归返回空对象的实现。减少需要的单元测试数目。
20、IsNull属性反模式。
21、避免把自己的逻辑扩散到它的客户端代码中。
22、Groovy是一种基于Java的动态编程语言。
23、级联空值，运算符?. 成为一种安全解析引用任何对象的方式。
24、更倾向于使用组合而不是继承。继承是一种白盒重用，子类会依赖基类的实现而不是接口。组合是一种黑盒重用，依赖局限在接口上。
25、对象适配器模式。
26、策略模式，能够在不需要编译的情况下(甚至在运行期间也可以) 改变类的行为。用于需要根据某个对象状态展示可变行为的类。
27、鸭子类型(duck-typing)，动态类型语言的一个特性。鸭子测试建议：只要对象展示了某个特性接口的行为，就应该看成该接口的实例。
28、C#是一个静态类型语言。
29、利用新版本公共语言运行时中引入的动态类型特性，或使用一个名为Impromptu Interface的第三方库。
30、使用动态语言运行时，dynamic，DLR。
31、所有方法全都采用dynamic参数，不如直接选择诸如IronPython等支出. NET Framework的动态类型语言。
32、使用Impromptu Interface库，ActLike<T>() 方法。在运行时会使用Reflection Emit创建一个新的类型。实际上是在运行时应用对象适配器模式。是应用对象适配模式的一种自动方式。
33、公共语言运行时对鸭子类型的支持，实现可枚举的对象。
34、混合类型，使用扩展方法实现。诸如Re-motion Re-Mix第三方库。
35、扩展方法可以增强现有接口。
36、静态类很难被模拟和替换。静态类的扩展方法无法使用目标类实例的任何状态。
37、真正的混合类型是一个聚合适配器，它应该能够同时实现多个不同接口。
38、类探测不值得提倡，但要混合类型就必须要使用它。
39、流接口(fluent interface) ，会有一个或多个方法返回自身实例。支持链的调用方式。避免重复引用接口实例，用来实现配置或有限状态机。
40、接口具有的多态能力支持在实现类中隐藏变化，这是设计模式的基础。
41、切记，没有相应的实现，接口本身毫无用处。
42、良好组织和部署的接口就像一道防火墙，能把整洁有序的客户端代码和复杂烦乱的服务代码完整地隔离开来。


第 4 章 单元测试和重构
1、单元测试是指编写代码来专门测试其他代码。单元测试本身的代码是可以编译和执行的。
2、重构(refactoring) 是一种逐渐改进现有代码设计的过程。从最简单的部分开始，然后逐步改进，最终实现一个比较好的方案。
3、单元测试能让随时随地重构成为可能。
4、编写代码边重构改进设计的方式是一个螺旋上升的过程，这个过程能够在逐步实现新特性的同时改善代码质量。
5、单元测试，应是每个编程人员日常的必做功课之一。
6、目标是要务实而不是成为纯粹主义者。
7、关注如何布置和命名单元测试，特别是如何保证代码的可测试性。
8、由单元测试建立起来的安全网。
9、每个单元测试的三个部分：布置测试的前置条件；执行要测试的动作；断言所期望的行为。Arrange，Act，Assert，AAA模式。
10、Given，When，Then，GWT模式。
11、布置测试前置条件，搭建测试场景的上下文。构造测试目标系统(System Under Test，SUT) 的实例。
12、VS内置MSTest，
13、每个测试的动作阶段只应该测试目标系统交互一次，比如只调用一个方法，或只使用一次属性的存或取。好处：测试的执行路径足够简单清晰，编写和理解它也会很容易。
14、断言所期望行为，根据目标系统的状态值进行断言是基于状态测试的一种常见形式，它会要求实际值和期望值完全相同。
15、期望值，你定义的一个常量，必须提前知道期望值，这是编写测试的关键点之一。
16、使用一个单元测试运行器来运行它们。包含单元测试过程的输出是无法直接执行的程序集。
17、其他类型的单元测试，需要为VS安装测试运行器插件。
18、编写单元测试的优势：即使运行成千上万的单元测试也不会耗费多少时间，手动测试则会耗费大量的时间。
19、测试驱动开(Test-Driven Development，TDD)，推荐在编写单元测试前不要有可以工作的测试目标系统。产品代码中的每个类的每个方法都要经过一次失败的测试。
20、失败、成功、重构(red，green，refactor)。
21、每个新的测试都带有自己期望的行为，每个新的期望都要求在已有测试目标系统的内部实现上做出平衡。
22、优先编写最简单的实现(而不是直接实现明显正确的方案) 的关键点是根据你的直觉设计断言。
23、对于要给测试目标系统新添加的测试而言重构这一步非常关键。
24、更复杂的测试，
25、规格说明，设计测试。首先要想清楚对这个方法的期望。
26、断言就是调用某个对象的某个特定方法并把某个具体的值传入，但又如何断言呢？此时需要模拟了。
27、使用临时实现测试，需要自己编写一个只用于测试该接口的临时实现类。
28、使用模拟测试，需要外部框架的支持。Moq也称Moh-kyoo或Mok。神奇之处：它能动态创建任何你想模拟的接口的代理。
29、Mock<T>() 对象，能够让你在要模拟的接口上设置各种期望和行为。
30、公共语言运行时并不允许从泛型参数继承。被模拟者和所创建的代理实例之间是组合关系。
31、在给测试目标系统提供模拟对象前，需要定义该模拟对象的行为。Moq默认定义的是宽松模拟，意味着模拟对象的所有返回都是default。
32、严格模拟，对这种模拟对象上你没有预先定义的属性和方法的访问都会引发异常。
33、Mock实例的Setup方法，接受lambda表达式，表达式中的上下文参数就是被模拟类的实例。通过调用被模拟类的方法并传入实际的参数来高效定义调用该方法时你所期望的行为。
34、Moq在一个方法调用内设置以下期望值，调用lambda表达式；返回一个指定的值；引发一个指定类型的异常；确保该方法被调用。
35、链式调用可以改善可读性并且避免测试的布置代码过于庞大。
36、为达到让单元测试先失败然后只有用正确的测试目标系统的实现才能让其通过再次验证的目标。这种编辑方式在单元测试流程中非常重要，它能规避出假正确的现象。
37、模拟和过度测试，过度规定的测试是针对测试目标系统的实现编写的，而不是针对测试目标系统所期望的行为编写的。
38、切记单元测试规定的是所期望的行为，而不是实现细节。
39、过度规定的测试会阻碍对产品代码的重构。
40、两种方式避免在使用模拟测试时出现过度规定的现象。一，只针对行为测试，基于状态的测试就是一种很好的只测试期望行为的方式。二，不常用，需要把单元测试和测试目标方法看作是一个整体：两者必须同时改动。
41、SOLID代码中会经常包含很多从不会修改的更直接的小规模类。
42、更进一步的测试，
43、没当增加一个新的测试时，要么在测试失败时无法确保覆盖实现的所有缺陷，要么在测试成功时相信自己的实现对正常代码执行路径和错误路径都是正确的。
44、在产品代码中实现前置条件检测。
45、为避免分层间的依赖泄露，一个好的实践方式是在当前层用一个新的异常来封装从底层引发的异常。
46、期望异常属性会判断引发的异常是否是指定的异常类型。
47、为修复缺陷编写测试。
48、缺陷报告，编写一个要失败的单元测试来捕获两件事：确保缺陷发生的必需的具体步骤以及单元测试遗漏的期望行为。
49、手动断言要引发的异常。
50、所有软件缺陷都可以看作对应单元测试的缺失：期望行为的规范不够完整。
51、测试初始化，MSTest允许你在测试类型内为所有测试方法编写公共的初始化方法。
52、每个测试方法都会单独调用构造函数这些模拟对象和测试目标系统的初始化方法，就可以通过移除对象构造代码来简化某些单元测试。
53、约定，变量名mock前缀代表了该变量是模拟对象的实例。sut则代表要测试目标系统的实例。
55、重构，改善现有代码设计的过程。
56、更改已有的代码，每一步的改动都是有着既定的目标。
57、重构只改变代码的布局而不是输出。单元测试，快速得到失败的提示。
58、用常量代替魔法数。自描述变量名。精确表达意图的变量名，且不要怕名称太长。
59、要抓住每个变量、类和方法命名的机会来让代码变得具有自描述的能力。
60、用多形性替代条件表达式。
61、每次不要做太多也很重要，因为只有这样才能确保自己的每个小改动是成功的。
62、给抽象类名添加后缀base。该类无法实例化且有关联的子类。
63、用工厂方法替代构造函数。客户端创建想要的子类对象。工厂方法能返回同一个继承层次结构下的很多种不同类型的对象。
64、工厂方法能够减轻客户端代码的负担的两个关键点：它是静态方法，客户端可直接通过类调用它；返回类是基类，对客户端隐藏具体的子类账户。
65、类声明为internal，客户端无法直接构造子类的实例对象消除了潜在的new代码味道。
66、new运算符被静态的工厂方法替代，用适应能力更高的代码替代了非常具体的代码。
67、用工厂类替代构造函数，给用户提供一个接口。实例方法。
68、通过组合使用多个合适粒度的接口为用户界面层提供更大的目标。
69、采用灵活的字符串值来代替枚举值。
70、代码味道：拒绝继承。用委托替代继承。
71、单元测试用一组对象来验证对真实世界期望的行为，就像这些对象封装了真实世界的概念一样。


Part 2 编写SOLID代码
1、一组最佳编码实践的首字母缩写。
2、S-单一职责原则；O-开放与封闭原则；L-Liskov替换原则；I-接口分离原则；D-依赖注入原则。
3、如何选择在正确的时机和场合中应用模式或实践本身就是软件开发艺术的一部分。
4、审慎地决定模式、实践或SOLID原则的应用时机和场合是非常重要的。保证代码在将来一直都是被完全理解的。

第 5 章 单一职责原则
1、Single Responsibility Principle，SPR，要求开发人员所编写的代码有且只有一个变更的理由。
2、多职责类应该被分解为多个单职责类。
3、通过委托和抽象，包含多个变更理由的类应该把一个或多个职责委托给其他的单职责类。
4、抽象，它是自适应代码的支撑。
5、从文件读取，传Stream流。读文件—>处理—>写数据库。单一方法拥有太多职责的示例。
6、TradeProcessor的职责：读取流数据，解析字符串，验证数据，记录日志，向数据库插入数据。
7、重构清晰度，不是自适应能力。第一步，拆分为更小的方法，每个方法专注完成一个职责。
8、返回IEnumerable<T>是只读的。
9、数据校验和映射。将每个职责划分到不同的类中，并把它们隐藏在相应的接口后面。
10、重构抽象，它的能力能够作为自适应开发校验标准的原因。第一步，设计一个或一组接口来执行三个最高级别的任务：读取数据，处理数据，存储数据。
11、再小的程序，只要有一些人开始使用，新的特性需求就会蜂拥而至。
12、原型(prototype)和概念验证(proof of concept)会用于描述这种小的应用程序，而从原型到产品的应用程序的转变几乎是无缝的。
13、不做抽象重构，大量的只带有模糊职责和抽象定义的需求就会发展成为一个“大泥球”：一个包含一个或一组的程序集。最终得到的应用程序没有相应的单元测试，很难维护和增强，而它还可能是业务链上一个很重要的节点。
14、不应该让一个类直接依赖其他类，而应该通过接口。
15、不包括任何处理流程的细节实现，取而代之的是整个流程的蓝图。只对交易数据格式转换的流程建模。流程本身发生变化，才是该类变更的唯一原因。
16、命名约定，用实现所需的具体上下文信息替代接口名称的前缀I。
17、Dapper映射库替代ADO.NET。
18、创建接口并做抽象重构时，不要保留那些会代码自适应能力有副作用的依赖关系。
19、通过使用构造函数，可建立需要的任何依赖关系，且不会影响接口。
20、将职责抽象为接口(以及相应的实现)的过程是递归的。提取职责的抽象直到该类只具备的那个职责。
21、创建一个适配器来调用流行的日志库Log4NET。通过它们把第三方引用转换为第一方引用。需要引用Log4NET程序集的地方只包括应用程序的入口，以及新创建的Service.Log4NET程序集。
22、需求—>解决方案。
23、单一职责原则和修饰器模式，修饰器模式(Decorator Pattern，DP)能够很好地确保每个类只有单个职责。
24、修饰器模式的前置条件：每个修饰器类实现一个接口且能同时接受一个或多个同一个接口实例作为构造函数的输入参数。好处：给已经实现的某个特定接口的类添加功能，且修饰器同时也是所需接口的一个实现，且对用户不可见。
25、复合模式(Composite Pattern )是修饰器模式的有个特例，也是应用最广泛的修饰器模式。目的：让你能把某个接口的一组实例看作该接口的一个实例。
26、借助多态的强大能力，能把所有该接口的实现类的实例只看作接口的实例。
27、对象图。
28、谓词修饰器(Predicate Decorator)，能够很好地消除客户端代码中的条件执行语句。通过定义专门的谓词接口来更加通用地处理这种具有条件分支的场景。
29、注意：.NET Framework从2.0开始提供一个Predicate<T>委托。它对谓词进行了建模，可接受单个泛型参数作为谓词的上下文。Func<bool>委托表示一个无需上下文的谓词。委托并不像接口那样通用。
30、设计IPredicate接口，在后期用同样的方式来修饰它。接口提供了一个可不断扩展修饰的切入点。
31、分支修饰器，接受两个组件和一个谓词。
32、延迟修饰器，允许客户端提供某个接口的引用，但直到第一次使用它时才进行实例化。Lazy<T>参数。
33、日志记录修饰器，提取出日志语句，让方法功能的实现看起来更简洁。局限性。应用日志记录方面来代替日志记录修饰器(面向切面编程(AOP))。
34、日志代码在应用程序中无处不在，严重地拉低了有效代码率。
35、性能修饰器，
36、基于.NET Framework平台，最大优势，支持快速应用开发(Rapid Application Development，RAD)。自动内存管理，丰富可用的库。C#被认为有助于提高开发效率，但开发出的应用程序运行速度相对却比较慢。C++运行速度快。
37、性能的好坏是相对的。
38、异步修饰器，即发即弃(fire-and-forget)的方法，没有返回值。局限性，请求—响应(request
-response)方法，显式编写回调以便在该异步方法完成时得到通知；不适合使用异步修饰器。
39、使用静态依赖的代码很难进行单元测试，因此你最好选个塔吊替代这个天钩。
40、修饰属性和事件，显式定义它们而不是使用自动属性和自动事件。
41、用策略模式替代switch语句，任何使用switch语句的场合，都可以通过策略模式将复杂性委托给所依赖的接口以简化客户端代码。使用字Dictionary存储类型和类对象。
42、单一职责能带来有序和清晰的良好效果。
43、单一职责主要通过接口抽象以及在运行时将无关功能的责任委托给相应接口完成来达成目标。


第 6 章 开放与封闭原则
1、自相矛盾的本质引起很多困惑。要求代码既是宽容开放的，同时又是严格有限制的。
2、清楚该原则的本质有助于你编写出具有更强自适应能力的代码。
3、Meyer在《面向对象软件构造》中首次定义开放与封闭原则(Open/Close Principle,OCP)。软件实体应该允许扩展，但禁止修改。
4、Martin，《敏捷软件开发：原则、模式与实践》。对于扩展是开放的，对于修改是封闭的。
5、修复缺陷所做的改动以及客户端无法感知到的改动。
6、缺陷修复，针对缺陷编写单元测试和/或集成测试。前提条件是要有稳定的让代码失败的问题复现步骤。修改后的源代码才可以通过单元测试。
7、缺陷是不可能完全消除的。需要修复问题代码。
8、能先布置好测试目标系统以便让它处于能够缺陷的状态，然后执行指定的包含缺陷的动作，最后对期望的行为进行断言。
9、所有问题实际上是由缺乏测试引起的。持续集成系统。
10、客户端感知，着重强调软件模块在所有粒度级别上如何耦合相关。
11、扩展点，类应该通过定义扩展点来对扩展保持开放。虚方法，抽象方法，接口继承。
12、客户端总是与服务的接口紧密耦合的，任何接口让的改动都会引起客户端代码的改动。
13、任何带有一个虚方法成员的类都对扩展开放的。这种扩展是通过实现继承做到的。
14、虚方法并没有中间状态。子类只能访问基类的受保护和公共成员。
15、模板方法模式(Template Method pattern)。该模式只对算法框架建模，而算法的每个具体步骤还可以自定义，它们都是委托抽象方法来完成具体动作的。基类委托子类来处理每个具体的步骤。
16、客户端委托接口取代了客户端对类的依赖。
17、接口继承要比实现继承好很多。接口要比类灵活的多。
18、基于实现继承，所有子类(现有的和将来的)都是基类的客户端。这会影响后续的修改，子类也都依赖基类实现的，因此，对实现的改动都会是客户端可能察觉到的改动。相对于继承，通常建议优先选择组合。如必须要使用继承，尽量使用只有少量分层的浅继承层次结构。
19、为继承设计或禁止继承，《Effective Java中文版(第二版)》，为继承设计和撰写文档，或禁止使用继承。
20、切记，任何没有标记sealed关键字的类都提供了继承能力。
21、防止变异(protected variation)，识别可预见的变化(predicted variation)点并围绕它们创建一个稳定的接口。
22、可预见的变化，一个稳定的接口，足够的自适应能力。
23、单个类的需求应该直接与客户端的一个业务需求关联起来。
24、接口拜年话的可能性要比实现小的多。
25、”宜居带”，只在合适的位置上包含恰当数目的扩展点的代码。
26、大多数编程新手通常会以过程化方式编码。习惯将类看作是方法的聚集地，不管这些方法在职责上是否应该在一起。几乎不做架构就直接编码，代码中没有扩展点。
27、要有丰富的经验积累才能做到适度。要经历只之甚少的”新手”和无所不知的”老手”阶段后，才能逐渐精通防止变异的精髓，并进阶到真正的高手的层次。
28、防止变异的概念建议你先识别出很可能发生变更的需求或者实现起来特别麻烦的代码部分，然后将它们隐藏在扩展点后面。
29、代码可以很死板，几乎无法扩展和细化；代码也可以很流畅，带有足够的准备应对新需求的大量扩展点。两种选择并没有对错，只是要根据具体的场景和上下文进行应用。


第 7 章 Liskov替换原则
1、Liskov Substitution Principle，LSP。是一组用于创建继承层次结构的知道原则。它也辅助增强了开放与封闭原则和单一职责原则的应用效果。
2、Barbara Lisdkov，定义：如果S是T的子类型，那么所有T类型的对象都可以在不破坏程序的情况下被S类型的对象替换。
3、三个代码要素：基类型；子类型；上下文，客户端和子类型交互的方式。
4、如果客户端不和子类型交互，就谈不上是否违背或遵守了Liskov替换原则。
5、规则分两类：契约规则(与类的期望有关)和变体规则(与代码中能被替换的类型有关)。
6、契约规则，子类型不能加强前置条件；子类型不能削弱后置条件；子类型必须保持超类型中的数据不变式(不变式是一个必须保持为真的条件)。
7、变体规则，与方法的参数及返回类型相关。子类型的方法参数类型必须是支持逆变的；子类型的返回类型必须是支持协变得；子类型不能引发不属于已有异常层次结构中的新异常。
8、支持.NET Framework的公共语言语言运行时的语言的类型变体的概念只限于泛型和委托。
9、契约，
10、除了表面上的方法签名，接口所表达的只是一个不够严谨的契约概念。
11、Money值类型，http://moneytype.codeplex.com。
12、特别用心地确保方法名称能反映出它的真实目的，同时参数名称要尽可能是描述性的。动名词组的形式。构成了方法文档化的开端。
13、有关好的变量和方法命名，以及其他实践，Code Complete一书(Steve McConnell)。
14、方法签名并没有包含方法的契约信息。方法应当强制要求重量值必须大于零。方法必须实现一个前置条件。
15、前置条件(precondition)，是一个能保障方法稳定无错运行的先决条件。
16、引发异常是一种强制履行契约的高效方式。使用一个更具描述性的异常，能提供给调用者更多的上下文信息。防卫子句。
17、私有状态不应该是前置条件检查的目标，只有方法参数和类的公共属性才应该有前置条件。
18、后置条件(postcondition)，会在方法退出时检测一个对象是否处于一个无效的状态。必须布置在所有状态编辑动作之后的方法尾部。
19、通过预先定义的有效范围检查状态值，能强制方法符合一个后置条件。必须通过客户端履行方法的契约来保证返回值必须大于零。
20、数据不变式(data invariant)，是在一个对象声明周期内始终都保持为真的一个谓词。它都是与期望的对象内部状态有关。
21、给构造函数添加前置条件保证相应的数据不变式；公共可设置的属性，必须把防卫的子句布置到属性设置器内。
22、封装与契约，封装一个专有类型(包括前置条件)。应该为比例税率创建一个专有类型，该类型包含一个确保数值必须大于零的数据不变式。
23、Liskov契约规则，设置了一组类型必须继承契约的规则。
24、前置条件不能被加强，
25、客户端代码绝不应该假设类的具体行为。
26、后置条件不能被削弱，
27、数据不变式必须被保持，子类有很多机会来改变基类中的私有变量。
28、代码契约，可以替代临界子句的代码契约是非常值得探讨的，它是一种更好的契约实现方式。
29、.NET Framework4.0前，.NET的代码契约特性被组织在一个独立的库中。直到4.0才被集成到了主库mscorlib.dll中。更易读写和理解，代码契约还提供了静态验证以及自动生成参考文档的特性。
30、通过静态契约验证，代码契约能够在不运行应用程序的情况下检查契约的履行情况。有助于公开空引用和数组越界等隐式契约以及各种显示编码契约。
31、前置条件，Contracts命名空间，提供了实现契约所需的主要功能。Requires方法
32、代码契约是一种普遍应用的代码基础结构。注意：最好在开始就做好决定，要么全面应用，要么根本不用。异常为ContractException。谓词更接近于单元测试中的断言。
33、VS项目属性页，代码契约的标签页，配置项目代码契约相关的设置。需要下载插件：http://visualstudiogallery.msdn.microsoft.com/1ec7db3-3363-46c9-851f-1ce455f66970.
34、后置条件，Ensures方法。Result方法
35、数据不变式，针对类整体的契约。代码契约允许在类内创建一个私有变量来声明和定义针对整体的所有数据不变式。Invariant方法。
36、接口契约，能够解决可读性下降等问题并提供另外一个很有用的特性。要先有应用契约的目标接口。
37、为关联接口和契约类的实现，需要通过一个属性完成一次双向引用。
38、协变和逆变，
39、变体(variance)这个属于主要应用于复杂类层次结构中以定义子类型的期望行为。
40、多态(polymorphism)，是一种子类型被看作超类型实例的能力。
41、引入一个通过泛型参数使用Supertype和/或Subtype的类型时，需要讨论变体相关的主题。
42、协变(convariance)，
43、存储库模式。
44、不使用泛型，C#中的所有继承都是非变体。
45、泛型化的基类可以利用协变能力，从而允许子类重写返回类型。
46、协变(out)只是与方法返回类型的处理相关，而逆变(in)是与方法参数类型的处理相关。
47、类型不身具有不变性。指不会生成变体。无法在该类型上形成类型层次结果。
48、C#语言的方法参数类型和返回类型都是不可变的。只有在涉及泛型时才能将类型定义为可协变的或可逆变的。
49、Liskov类型系统规则。方法参数支持逆变且返回类型支持协变。
50、不允许引发新异常，
51、异常机制的主旨就是将错误的汇报和处理环节分隔开。异常对象表示通过该异常类型发生的错误以及相应的数据。
52、最好能在代码确定能做一些有意义的处理时采取捕获异常。
53、无法处理和恢复的情况。很多无法恢复的异常都是从System.Exception类派生的。
54、每个接口都应该有一个统一的基础异常类型，它可以将必要的错误信息从异常汇报器传给异常处理器。
55、任何对Liskov替换原则定义的规则的违背都应该被看作技术债务。


第 8 章 接口分离原则
1、接口所表达的是客户端代码需求和需求具体实现之间的边界。
2、主张接口应该足够小。
3、接口的每个成员(属性、事件和方法)都需要按照接口的整体目标来实现。
4、要牢记单一职责和可以轻易使用的修饰器模式。
5、一个简单的CRUD接口，代表创建、读取、更新和删除(create、read、update、delete)。
6、泛型接口，可接受不同的实体类型。
7、日志和事务处理等修饰器实现。有些修饰器作用于所有方法。
8、用于记录日志和管理事务的修饰器都属于横切关注点(cross-cutting concern)。使用面向方面编程来修饰接口的所有实现。
9、直托(pass-through)代表对该方法不做任何实际的修饰：不修饰接口方法，就好像直接调用被修饰的接口方法一样。
10、只在相关的接口上应用确认修饰器。
11、代码量变少也意味着相应的测试工作量也变少了。
12、针对接口添加新的审计修饰器。审计动作对于用户来说是不可察觉的，同时也不会影响到实体数据保存的实现。
13、多重接口修饰，每个修饰器都要首先实现它要修饰的接口。配合应用适配器和修饰器这两个模式来构造多重修饰器。
14、发布和订阅事件通知的机制。
15、只有在多个修饰器共享上下文信息时，在单个类中包含多个修饰器的实现才是有意义的。
16、最好把不同功能的实现和相应依赖链分别封装在它们各自的程序集中。
17、客户端构建，使用接口，就必须先以某种方式获得接口实例。手动构造接口实现的实例，并把它们通过构造函数参数传递给客户端。另一种提供接口实例的方式是依赖倒置。
18、为客户端提供接口实例的方式一定程度上取决于接口实现的数目。
19、多实现、多实例，单实现、单实例(不通用，通常用于接口的叶子实现类(既不是修饰器也不是适配器的实现类))。
20、接口就像是实现类上的小窗口，对客户端屏蔽了他们不该看到的部分。
21、接口分离原则产生的常见副作用。
22、叶子实现类中的所有实现的上下文是一致的。
23、超级接口反模式，破坏接口分离带来的好处。
24、接口分离，原因：客户端和架构需要。
25、客户端需要，
26、编写任何代码(特别是充分测试的代码)都需要时间，在代码基础上编写扩展的文档，既冗长有费时。尽早采用防御方式进行编程，防止其他开发人员无意中使用接口作出一些不该做的事情。
27、切记，客户端只需要他们需要的东西。
28、接口意图很模糊，焦点不明确。所有的类应该只是单个清晰的职责。
29、ConfigurationManger类读写配置文件中的AppSettings数据段。
30、真正防止和消除错用接口的可能性，可将读写分离到各自专有的接口中。
31、C#不能很友好地支持属性继承。
32、授权，应用程序在某个特定状态下只能提供一组特定的操作。
33、架构需要，高层设计产生的决定对底层代码的组织有着非常大的影响。非对称架构。
34、NHibernate(配合域模型使用的对象关系映射器)用于执行命令，MongoDB(用于快速查询的文档存储库)用于执行查询。
35、单方法接口。接口规模越小，就变得越通用。通过修饰、适配和组合大量不同种类的这种单方法接口，可以完成很多复杂的事情。
36、.NET Framework，很多类似的委托，如Action、Func和Predicate
37、应该在创建任何接口时记得接口分离这个技术原则。


第 9 章 依赖注入原则
1、Dependency Injection，DI。是一个非常简单的概念，实现起来也很简单。
2、没有依赖注入，SOLID技术及前面与敏捷基础相关的章节都不可能实际应用。
3、正确实现的依赖注入对于项目的绝大数代码而言是不可见的。它们被局限在一个很小的代码范围，通常是在一个独立的程序集内。
4、最好一开始就应用依赖注入，因为在已经建立的项目中引入依赖注入会既困难又耗时。
5、简单的开始，
6、Model-View-ViewModel,MVVM模式确保各个层之间的依赖。
7、AutoMapper。
8、仅依赖接口，接口实例总是可以被替换的。
9、注意：只有能为用户提供替换实现(也称为代理，proxy)的类才称为是可代理的。可代理的类必须把所有方法声明为虚方法。接口总是可代理的。
10、依赖的黑盒子，无法从外部知道该类到底需要什么才可以正常工作。
11、客户端代码可以通过VS的智能感知特性看到构造函数的签名。
12、依赖关系网一旦形成，就很难再整理清楚。
13、接口允许应用各种强大的模式来为自己提供多种实现或增强现有的实现。
14、包级别和类级别组织，对象图的构建，
15、接口实例要注入到构造函数中。还必须要提供一个接口的实现。注入方式：穷人的依赖注入和控制器反转容器。
16、穷人的依赖注入(Poor Man’s Dependency Injection)，不需要任何其他外部依赖就可以实现注入。需要提前位控制器创建必需的对象图。比较繁琐但却很灵活。手动创建任何需要的实例，然后把它们传递给聚合它们功能的类，重复这个动作，直到成功实例化应用程序的解析根。它允许随意定制要构建的对象图。
17、应用程序的入口代码，始终是一个放置依赖注入的好地方。
18、解析根。
19、方法注入，缺点：用户调用方法前必须要先准备好依赖的实例。
20、从构造函数注入依赖表明类中的多数行为需要该依赖项。使用场景不同。
21、属性注入，好处：在运行时改变属性实例值。
22、从构造函数注入的依赖实例在类的整个生命周期内都可以使用，而从属性注入的依赖实例还能从类生命周期的某个中间点开始起作用。
23、控制反转，Inversion of Control，IoC，允许将构建对象图的动作推迟到运行时。
24、开发中的类委托某些抽象完成动作，而这些被委托的抽象又被其他的类实现，这些类又会去委托其他一些抽象完成某些动作。在依赖链终结的地方，都是一些小且直接的类，它们已经不需要任何依赖了。
25、构造的实例对象图依然是静态的，编译时就已经确定了。
26、控制反转的概念通常都是在控制反转容器的上下文中出现。控制反转容器组成的系统能够将应用程序使用的接口和它的实现类关联起来，并能在获取实例的同时解析所有相关的依赖。
27、Unity控制反转容器，初始化一个UnityContainer实例。
28、通过控制反转容器来建立类和接口的映射关系。
29、接口和对应实现类的关系注册后，需要获得一个应用程序的解析根。
30、注册、解析、释放模式，
31、所有的控制反转容器都符合一个只有三个方法的简单接口。
32、MVP，WinForm
33、网络应用场景中，资源只对单次请求(per-request)有效。
34、Dispose，会清除容器内部的字典，它不再带有映射关系的注册信息，所以也就无法解析任何依赖了。
35、对容器的调用都被封装在一个类内。把冗长的注册代码从应用程序的后置代码中隔离开。
36、在诸如ASP.NET等其他应用程序类型中，通常会有很多解析根，每个控制器都一个。MVC和其他模式应用程序的组合根。
37、命令式与声明式注册，
38、命令式优点：易读、比较简洁，编译时检查问题代价非常小。劣势：注册过程的实现在编译时就已经固定了。
39、建立接口和相应实现之间的映射关系。
40、声明式，将映射动作推迟到配置时，劣势：太繁琐；大多数控制反转容器都提供了很丰富的注册方式。如lambda工厂。
41、对象生命周期，
42、如果一个类通过构造函数得到一个依赖项，它就不应该手动释放该依赖项的资源。
43、使用依赖注入时管理对象生命周期问题的方式和原始服务实现的方式很接近。
44、连接工厂
45、负责人模式，确保正确地释放对象占有的资源。try/finally替换using块。内层对象，外层对象。
46、工厂隔离模式，能够明确地释放整个复杂的对象图。只有在接口没有实现IDisposable时才需要应用该模式。好处：工厂方法返回实例的生命周期会显式地由lambda方法决定。
47、注意，如果把lambda方法范围内的实例对象赋给一个有更长生命周期的变量，工厂隔离模式就会失败。
48、比较复杂的注入，反模式。
49、服务定位器反模式，
50、识别组合根以便在正确的地方集成你的注册代码。
51、环境容器(ambient container)。
52、依赖注入的”好莱坞准则”：不要调我们，我们会调你。
53、Unity中提供了一个服务定位器的适配器。
54、注入容器，
55、非法注入，默认构造函数。在引用它时不应该直接引用具体的实现。
56、组合根，和应用程序的入口越近越好。
57、解析根，它是要解析的目标对象图中根节点的对象类型。唯一应该解析获取的对象类型。
58、ASP.NET MVC，MVC模式的过程已经很好地通过控制反转容器应用了依赖注入。
59、MVC应用程序的解析根就是控制器。请求，MVC框架会将URL映射为某个控制器名称，然后找到名称对应的类并实例化它，最后再在该实例上触发动作。
60、Windows Forms，WPF，二者的解析根都是视图，视图的构造函数需要传入的是表示器或控制器参数，并由视图开始处理整个对象图。
61、约定优于配置，约定是一组指令，用于告诉容器如何自动完成接口到相应实现类的映射。
62、约定(convention)，如何确保正确地注册类和接口的映射关系。RegisterTypes，WithMapping，WithName
63、约定注册方式的关键点就是用于查找类，建立类和接口之间的映射关系，以及映射关系命名的约定。
64、点分的命名方式。
65、优缺点，代码量少了，更难直接理解了。约定在开始阶段的设置也更复杂。
66、只有一个实现的接口的情况本身是一个代码味道。
67、价值和复杂度。价值用于衡量选项的作用和意义。复杂度用于衡量选项的难度。
68、使用容器手动注册类型是弱类型化的。
69、Mark Seemann的博客：blog.ploeh.dk


Part 3 自适应实例
1、软件产品开发的几个初始阶段。团队和项目角度，所有团队成员形成的约定以及如何按照约定作出必要的决定。
2、如何选择模式和实践。GitHub。

第 10 章 自适应实例简介
1、如何构造出一个清晰的全景图。
2、学习配套的代码。
3、虚拟公司：Trey Research公司。
4、团队，产品负责人直到如何获取想要的应用特性，那些特性优先级最高，哪些特性能为业务带来最大的收益。Scrum主管负责团队使用的流程。开发人员，负责设计测试用例以及验证故事是否达到交付标准的测试分析人员。
5、产品负责人，资深的业务分析师。擅长发现用户真正想要的东西，杀手锏。需要的东西及需要它们的理由。计算各种不同特性对于客户的价值，帮助开发团队更好地对工作项进行排序。
6、Scrum主管，资深开发人员。诚信透明地和任何指定产品负责人或客户写作而自豪。从不更改范围或随意承诺交付目标。设计会议。
7、开发人员，自学编程实践和技术。如饥似渴地学习最前沿的开发技术。实践能力。中间层。
8、技术成熟度曲线，Gartner的IT研究和咨询公司开发的。评估新技能和技术的工具。
9、模式、SOLID原则、单元测算以及重构。
10、测试分析人员，负责测试自动化工作。擅长发现软件产品的缺陷以及通过逐步增加健壮性来改善应用的整体用户体验。将特性看作黑盒，并不关心实现细节，只关心软件产品是否能够按照规格说明工作。不停地返工已经做过的测试。自动化测试。
11、产品，一点一点地增加功能以便能决定应用程序的开发方向。增量开发。
12、参与项目讨论，尽力形成一个最初的用户故事积压工作。
13、最初的产品积压工作，团队会议目标，将描述转换成一个或多个用户故事。
14、从描述中挖掘故事，
15、故事点估算，
16、会议，团队先对客户提供的需求描述进行分解，并得到若干个用户故事。逐个对故事点数进行估算，并创一个排好序的积压工作。


第 11 章 自适应实例冲刺1
1、计划会议，讨论过程，关键的决定。选择技术、平台、语言。UML时序图。
2、HTTP是一个离线的无状态协议，必须为消息引入服务。
3、界面现代感。
4、在早起阶段，任何试图对用户界面做额外美化的努力都可能是白费功夫。
5、自动化环境搭建。单元测试。
6、我想创建多个房间以对会话进行分类。
7、讨论代码，识别实现的优缺点。代码评审。
8、同行评审能给开发人员一个机会来识别是否有些实现没有达标或缺乏适应变更的能力。
9、代码提交到源代码控制系统前，评审是最后一次变更方案实现的机会。
10、控制器，MVC，委托接口来实现交互。单元测试，使用TestCase属性。
11、PRG模式(Post-Redirect-Get)。
12、房间存储库，
13、工厂隔离模式只适合在工厂生成对象不确定实现IDisposable接口时使用。using块。
14、控制器不应该知道RoomRecord类的存在，也不应该知道类的映射过程。
15、CQRS即命令查询责任分离。应用程序中的命令和查询是非对称的。
16、结对编程(pair programming)，一人编写，一人在旁边阅读并提出建议。
17、极限编程(Extreme Programming，XP)的一个很常见的实践活动。
18、ASP.NET MVC模式通过控制器名称和方法名称来构造请求的URL。
19、用户界面会通过一个AJAX请求发送消息数据。全页完全回发。
20、AJAX(Asynchronous JavaScript and XML)指异步的JavaScript和XML。AJAJ，JSON(JavaCsript Object Notation)指JavaScript对象标记法。
21、404指错误请求的响应。
22、演示会议，为客户展示目前的开发进度。逐个展示每个故事的功能。能让团队确定开发工作始终是满足客户当前需求的。能激励团队成员总是提供最好的产出，必须足够自信地向客户展示当前产品的开发状态。客户定期看到产品上实实在在的进展，提出建议和意见。输出改变和重新排序后的用户故事挤压工作。
23、投影仪，分辨率问题。
24、内容过滤器。
25、回顾会议，逐个回答问题。
26、冲刺会议的目标是生成一个可执行的、排好序的工作项列表，然后在会后实施。
27、什么做的比较好，协作开发。交付持续可测的功能。
28、管理用户的期望值。
29、缺乏足够的准备时间。需要更早更频繁地在所有可能的环境中集成测试。
30、总犯同一个错误就不可以接受了。
31、为改进流程、工作环境或其他实践而制定可执行的工作计划是改进团队工作的一个很好的办法。
32、内部演示。功能展示的预演，以确定一切都准备就绪。
33、敏捷流程的关键：总是为建设性的批判采取纠正措施。


第 12 章 自适应实例冲刺2
1、计划会议，讨论用户故事。
2、根据受限词汇库来判断文字信息是否可以发送。
3、由数据驱动的内容过滤器，把方案简化为使用固定的词汇列表。
4、解析标记。评估第三方库。试一试MarkDownDeep(NuGet)。创建一个自己的库对MarkDownDeep进行适配。
5、异常最好只用于真正意外的情况。
6、MVC框架中的验证机制。
7、水平扩展是指应用程序应该能通过额外的服务器以支持更多用户的并发访问。受限点：关系型数据库管理系统(Relational Database Management System，RDMS)的架构。分布式存储方案，文档存储候选项。MongoDB。
8、垂直扩展是指应用程序在通过单个机器的能力以支持更多的并发访问。
9、标记语言是一种日益流行、友好随意的文本格式化方式。
10、必须要朝着能够长期保持这种水平而努力。


附录 自适应工具
1、使用Git进行源代码控制。管理本地和远程存储库。技能可应用在任何存放在Git上的存储库。
2、开源项目在使用Git。管理自有的代码资产。
3、持续集成(Continuous Integration，CI)系统都是一个能让不同参与者之间的代码始终保持同步的重要工具。
4、Mercurial和Git分布式源代码控制系统。
5、使用任何源代码控制系统总是比不使用好。首选Git。
6、源代码控制系统是为了追踪代码随着时间推移时所发生的变更，通过它能够很容易地按照时间线前后遍历代码的变更，且它同时也能提供一份只读的源代码备份。
7、使用Git，每个开发人员都有自有的、包含所有源代码的存储库。
8、为编辑源代码，开发人员应该为提交连续的变更创建本地分支。每个分支都有一个清楚描述的目的：修复某个缺陷，实现某个新特性，或改进某些体验。这些变更都只在本地的存储库中发生，直到开发人员决定把代码推送到其他的远程分支中。
9、一种Git分支策略：主分支、开发分支、特性分支1、特性分支2。
10、所有修改都不会直接发生在主分支上，而是发生在为此创建的开发分支上。每个开发分支扩展出的分支代表着一个新特性或一个修复缺陷。当特性分支的变更通过评审后，特性分支会被合并到开发分支。当要发布代码时，开发分支会被合并到主分支中。
11、中央存储库，选择某个存储库作为正式的源代码存放位置。
12、拉请求(pull request)。且经常用在有助于保证代码质量的源代码同行评审活动中。
13、每个获得批准的拉请求都会被合并到一个主开发分支中。
14、分布式源代码控制是一种点对点系统，但实际应用时通常会设置一个中央代码库。
15、Git课程，安装Git。GitHub是一个Git存储库社区的中心存储库。
16、如何浏览Git存储库上的代码。
17、Git参考手册，http://gitref.org。
18、界面Git，http://git-scm.com/downloads/guis。用户使用最多的是Atlassian的SourceTree。
19、克隆存储库，获取Git存储库的代码的第一步是克隆指定的存储库。
20、所有Git动作的命令都是Git命令行应用程序的参数。clone命令需要提供克隆的目标存储库的位置信息。
21、Git是一个分布式源代码控制系统，所以会有很多的存储库。对远程库你只有读取权限，但对克隆得到的本地存储库有改写权限。
22、默认选择的是master分支。本书的每个示例都安排在不同的分支上，需要知道如何切换分支。
23、切换分支，使用改变目录命令来改变本地存储库的目录。git branch查看本地可用的分支清单。
24、起初，只将master分支克隆到了本地，其余分支都没有从远程存储库克隆到本地。
25、git branch -remote列出远程的分支。注意：所有的分支都以origin/前缀开头，用来表示这些分支所在的远程位置。
26、每个存储库可同时有多个远程位置，使用诸如origin的名称可以将指定的远程存储库克隆到本地。
27、checkout 可创建远程分支的本地副本并切换到它上面去。如果切回master分支，这个文件夹会被删除，因为它与当前选择的分支已经无关了。
28、更新本地分支，某个分支的远程版本有了变更，fetch可下载远程分支的所有变更。
29、git fectch origin master；git checkout branchName；git merge origin/git checkout branchName;
30、使用fetch命令下载分支变更后，可以使用checkout命令切换目标分支。
31、持续集成，导致无法构建可工作版本的任何请求都会立刻拒绝。代码编译，运行所有单元测试以判断是否影响到其他已有的用例被破坏；检查代码的单元测试覆盖率是否满足要求的标准。系统尝试从构建的输出中生成可供部署的安装包。
32、持续集成系统对每个推送的分支都执行这个过程能极大地减轻开发人员的负担。开发人员本地编译代码变更涉及的工程并运行针对这些变更编写的单元测试。































