前言
1、Orange Can项目，三部分：文章阅读、电影资讯以及设置。
2、内容型应用。
3、服务器PHP代码，用户登录、校验、解析加密数据、模板消息、微信支付等。
4、小程序不提供入口，不提供推荐，分享也不能分享到朋友圈。
5、适合场景化、服务型的产品。解决完我的需求在之后它消失。
6、线下的活动场景和机会。只不过没有被充分挖掘。体验和产品闭环，都远远不及小程序。
7、和技术无关，只和场景有关。
8、小程序是一个体系，但缺点是没有H5开放和自由，H5依然是粘合剂，很适合嵌入到各个种类的产品与应用中。
9、应把好产品放在第一位。回归产品本质，解决用户的问题也许才是每个开发者应该斟酌和思量的事情。
10、平台是多变的，但技术思维是相通的。
11、原型Axure。非常适合开发者践行自己的想法。快速编写一个MVP产品，然后迅速投入市场去试错，再逐步迭代、完善。最终考虑是否退出自己的原生APP。
12、代入感。
13、Coder有时需要这种直面未知的勇气：先解决、再学习。
14、有时记住怎么去做，比为什么这么做更加重要。
15、有选择的学习原理，把更多精力放在解决问题上。
16、不考虑服务器，JS和CSS。Vue、AngularJS，强人所难。
17、Vue、AngularJS等经典MVVM框架确实先于小程序出现。若只是为了开发小程序前端，没必要学习NodeJS。
18、小程序应该成为开发者学习前端首选开发平台(以学习与实践为目的)。
19、小程序中没有DOM，请放弃“首先获取DOM，再操作DOM”的思维；替代DOM操作的方法是"数据绑定"。
20、可补充ES6和LESS的知识，将代码写的更加优美和简洁。
21、前端最难的是有太多Web前端框架、类库需要学习。
22、小程序运行在JSCore中，它本身不支持Web中的window及DOM对象。
23、严格测试、尽量减少bug的数量，并在发现bug后第一时间做出修正。


第 1 章 微信小程序简介
1、小程序“用完即走”的理念。技术借用了React Native的一些概念。定义了一套自有的组件并根据运行环境的不同将这些组件编译/转化为对应平台的可运行组件。以提高运行的性能。
2、只有你不敢做，没有你不能做。
3、商业模式。
4、除了游戏和直播，微信官方并没有明确限制你不能做什么类型的小程序。
5、简单、低频、对性能要求不高的应用。特别适合做线下的场景化应用。官方的一切措施就是为了将小程序导向线下。
6、APP主流开发方式有三种：Web App、Native App和Hybrid App。
7、Web App，性能极差，不能使用照相机、系统通知、本地缓存等。
8、Native App不能跨平台。
9、微信JS-SDK，提供一些如拍照、录音、扫一扫等接口，但实在有限。
10、无数开发者、创业者看中的是微信天然的关系链与获客能力。
11、WebView，新闻类型的应用，将文章是数据静态化成HTML存储在服务器或者CDN中，然后利用WebView直接加载这个HTML显示。小程序不支持。
12、Web App很难去监管，性能体验也不够好。
13、组件的业务逻辑不能写在组件的模块中，只能写在“调用”组件的业务代码中。无法很好复用组件的业务代码。
14、Web前端，React。NodeJS服务器，移动端。一个非常有挑战和想象力的工作。精通jQuery、熟悉AngularJS、Vue、Grunt。
15、JS，Brendan Erich用10天设计出来的脚本语言。
16、MINA，据说MINA is Not App。框架，提供小程序运行所需的接口、模型和机制。
17、微信小程序，与iOS生态极为相似，它们都非常封闭，且审核非常严格。


第 2 章 小程序环境搭建与开发工具介绍
1、微信Web开发者工具IDE。开发小程序，调试运行在微信上的网页以及微信JS-SDK。
2、工具不支持Windows XP。
3、第一次打开或长时间未打开，工具都会弹出一个二维码。登录，微信号。
4、无APPID模式的运行环境非常宽松。如无须配置可信任访问域名、不会校验TLS版本等。
5、建议使用英文。注意：选择一个没有任何文件的空白文件夹，最好能新建一个文件夹。
6、样式、标签相关问题，需要依靠Wxml Panel来调试。
7、快速打开官方API文档，devtools-->about。推案件第一时间查看更新内容。
8、微信小程序开发者工具将自动更新。以管理员身份运行。
9、常用快捷键，Ctl+[/]，代码缩进；Ctl+shift+[/],折叠代码块；shift+Alt+F，代码格式化；shift+Alt+Up/Down，向上/下复制一行；shift+Alt+Enter，在当前行上方插入一行。Ctrl+shift+F，全局搜索。(格式调整)
10、工具的使用需要用具体的案例来推动。


第 3 章 从一个简单的“Welcome”页面开会小程序之旅
1、页面的js文件不可以完全空白。Page({})。json文件也不可以为空，{}
2、图片，被MINA框架设置成宽度300px、高度225px。默认。
3、绝对路径，以"/"开头(代表根目录)。
4、为需要样式的组件加入样式名称class name。
5、真实项目中，图片资源尽量不要存在小程序的目录中，小程序的大小不能超过1MB。超过则无法真机运行和发布项目。应将图片放在服务器上，让小程序通过网络来加载图片资源。
6、小程序支持6中农CSS选择器：.class、#id、element、Element，element、::after、::before(组件前)。
7、注意：本地资源在wxss中无法使用。可使用网络图片来替代本地图片。
8、Flex布局，是W3C在2009年提出的布局方案。让页面布局更加简单，且可以很友好地支持响应式布局。本身是CSS语法的一部分。
9、传统position和float属性。
10、Flex，也称“弹性布局”。主要作用在容器上。
11、讲道理不如直接看效果。根据设计图的样式，选择主轴。
12、注意：align-items定义的是“交叉轴”方向上子元素的对齐方式。
13、学习Flex布局，浏览整个Flex的知识树，知道Flex解决了什么问题，什么特点，大概有几类属性。
14、自适应单位rpx，建议以iphone 6的宽度750个物理像素作为标准，来做设计图。
15、物理分辨率px，逻辑分辨率pt。
16、选择rpx还是px，取决于需要元素随着移动设备尺寸的变化而变化，还是让元素始终保持不变。
17、rpx是自适应单位，通常适合用来控制图片的宽高和元素之间的间距。
18、在PS里做设计图，它的像素可以简单理解为物理像素。
19、1物理像素不等于1px。
20、书籍绝大多数是用来引导入门和分享思想的，它不应该替代官方的API文档(一般用于查询，是工具而非教程)。
21、学习API的方法，就是“试”。


第 4 章 文章列表页面
1、banner轮播图。
2、图片的像素大小要大于或者等于750(宽)和600(高)，过小的图片会出现“留白”的情况。
3、swiper组件，滑动视图容器。注意：swiper组件的直接子元素只可以是swiper-item，如放置其他组件则会自动删除。
4、indicator-dots，面板指示点。
5、Boolean值的陷阱，
6、image组件的4种缩放模式与9种裁剪模式，
7、有所舍弃，或放弃等比例，或裁剪掉脱线的一部分。图片保持比例，允许裁剪。
8、scaleToFill是默认模式，
9、生命周期函数的触发时机。加载(onLoad)、显示(onShow)、渲染(onReady)。
10、onLoad与onReady在一次生命周期中只会执行一次。onHide与onShow在一次生命周期内可能会执行多次，Render多次；数据更新会造成页面的重新渲染。
11、注意：小程序仅在第一次First Render完成后，提供了监听函数OnReady(它仅用来监听"第一次渲染"完成)。
12、通过大量的编码，可以让经验弥补一些知识上的缺陷。孰能生巧。
13、数据绑定，真实项目中，业务数据通常都放置在自己的服务器中，然后通过HTTP请求来访问服务器提供的RESTFUL API，从而获取数据。
14、“硬编码”。内容直接编码在wxml里的数据。
15、传统网页，获取到HTML文档的DOM，对DOM标签进行赋值，从而实现数据的显示。
16、流行的MVC或MVVM框架中，如AngularJS(内置jQLite支持DOM)、Vue.js中，都有数据绑定的概念。
17、数据绑定的机制来做数据的初始化和更新。
18、小程序运行在JSCore，没有DOM环境。完全抛弃了DOM结构。只能使用数据绑定来做数据的相关操作。单向绑定，即只支持从逻辑层传递到渲染层的数据绑定。
19、AngularJS双向绑定。
20、Page方法参数里的data变量作为数据绑定的桥梁。
21、数据绑定有两种，初始化数据的数据绑定；使用setData方法来做数据绑定(数据更新，引起页面的Render(重新渲染))。
22、使用Mustache语法双大括号{{}}在wxml组件里进行数据绑定。
23、数据绑定是作用在组件的属性中，一定要在{{}}外边加上双引号。内容型数据绑定，则不需要加双引号。
24、setData方法位于Page对象的原型链上：Page.prototype.setData.它会改变this.data变量里相同key的值；执行后会通知逻辑层执行Rerender，并立刻重新渲染视图。
25、注意：关于数据绑定的错误，小程序目前不会给出任何的错误提醒。
26、列表渲染，<block>标签没有实质意义，它并不是组件，仅仅是一个包装，不会在页面内被渲染。在block标签中被包裹的元素将被重复渲染。
27、view组件通常被用来当做容器或者区域分隔。
28、配置单个页面导航栏背景色，
29、页面的json文件只能够配置和window相关的属性。直接编写window下的配置项即可。
30、事件是视图层(wxml)到逻辑层(js)的通信方式。可让我们在js里处理一些用户在界面上的一些操作并对这些操作做出反馈。
31、在js里调用MIMA框架的API。在组件上注册事件(小程序监听哪个组件的什么事件)。在js中编写事件处理函数响应事件。
32、redirectTo，将关闭当前页面并将页面卸载；navigateTo，仅仅隐藏当前页面，还可再次返回到被隐藏的页面。
33、页面是否被卸载是非常重要的行为，不卸载的页面将使全局性的一些行为，如音乐播放的处理，变得非常复杂。
34、switchtab，只能跳转到带有tabBar选项卡的页面。
35、小程序最多只能有5层页面，尽量避免多层级的交互方式。建议最多不要超过3层。redirectTo不存在这个问题(跳转后，卸载上一个页面)。
36、常见的冒泡事件：touchstart、touchmove、touchcancel、touchend、tap(手指触摸后马上离开)、longtap(手指触摸后，超过350ms再离开)。
37、非冒泡事件大多不通用事件，而是某些组件特有的时间。form的submit，input的input事件，scroll-view的croll事件等。


第 5 章 模块、模板与缓存
1、进阶内容，模板是小程序的重点和难点，它将大幅度地提高代码的复用性与可维护性。
2、将数据分离到一个单独的js文件。module.exports向外部暴露一个接口。require(path)将模块引入到js中。
3、注意：被引用的文件一定要带有扩展名js；path路径不可以使用绝对路径；在js文件中声明的变量和函数只在该文件中有效。
4、require只是模块化的一种方式，还可使用ES6的Module来编写模块。开发工具默认使用babel将开发者的ES6代码转化成ES5代码。
5、编程世界里遇到的绝大数问题都可以用封装的思想来解决。
6、在小程序里，只能将wxml封装，无法将模板的业务逻辑(js)也封装起来。
7、注意：向模板里传入数据，要使用{{}}的数据绑定语法。
8、消除template模板对外部变量名的依赖。可使用扩展运算符"..."展开传入对象变量来消除这个问题。
9、{{...item}}可将item这个对象展开。展开之后再传入到template里，就可保证template不再依赖item这个变量名。
10、include与import区别：import需要先引入template，然后再使用template；但include不需要预先引入，直接在需要的地方引入模板即可；include模式非常简单，就是简单的代码替换，不存在作用域，也不能像import一样使用data传递变量。
11、include无法引入包含有template标签的代码。
12、import有作用域的概念。即只会import目标文件中定义的template，而不会import目标文件import的template。
13、include只是一个占位符，仅做简单的替换。
14、建议：如果模板仅仅是静态wxml，不涉及数据的传递，可使用include。
15、样式应该作为模板的一部分被“打包”起来。
16、引入wxss文件，@import “src”
17、小程序只实现了模板化而并没有实现组件化。
18、自定义组件将大大提高代码的复用性，且使业务代码变得更简洁。目前不支持。
19、使用缓存在本地模拟服务器数据库，
20、app.js文件中使用App(object)来注册小程序。onLaunch、onShow、onHide、onError。
21、最好的初始化数据库的实际是在应用程序启动时，使用Storage缓存初始化本地数据库。
22、缓存让小程序具备了本地存储数据的能力，特点：只要用户不主动清除缓存，则缓存一直存在；缓存以key:value键值对的形式存在(类似于服务器流行的memcache或redis缓存型数据库)；一些列API用来操作缓存(存储、读取、移除、清除全部和获取缓存信息)；注意移除和清除的区别；注意小程序的缓存永久存在，主动调用清除缓存的API；本地缓存容量有限，最大不允许查过10MB。
23、实际项目中，本地缓存是非常重要的功能，可极大地改善用户体验。
24、同步方法没有success、fail、complete等回调函数。
25、注意：选取异步方法会大大增加代码风险率和调试难度。如没有必要(性能和体验)，建议优先考虑同步方法。
26、缓存不主动清除，它是一只存在的。完全没必要么每次启动小程序时都执行一次初始化数据库。仅当缓存不存在时，执行一次上代码即可。
27、注意:微信自带的缓存清理并不是用来清除小程序缓存的。
28、建议：在开发过程中，临时在页面里添加一个按钮，点击按钮执行wx.clearStorageSync，强制清理缓存。另一种思路，在开发阶段，不做是否有缓存的判断，每次应用程序重启都强制更新一次初始化数据，从而保证数据一致是最新状态。
29、编写缓存数据库操作类，
30、JS用原型链的方式来实现对象的继承机制。
31、ES6的出现让JS重新焕发的新生。module、lambda、class等特性。
32、尝试用prototype和ES6的class分别来构建缓存数据库的操作类。
33、ES6的class优化了JS的对象构造方式。ES6大多数特性只是一种语法糖，本质上JS的运行和解析机制并没有被改变。
34、如果更新了初始化数据，又不清除缓存，那缓存是不会被更新的。


第 6 章 跳转到文章详情页面
1、不要在template上注册事件。template标签只是个占位符，在编译后会被template的模板内容替换。
2、页面间传递参数的3种方式，使用全局变量；使用缓存；通过页面导航url的query参数传递。
3、事件信号参数，一个页面emit发送信号，一个页面on监听信号，在AngularJS里很常见。小程序不支持。
4、组件的自定义属性，通过dataset获取组件自定义属性。dataset包含当前组件中所有属性名以data-开头的自定义属性值。
5、组件自定义属性名规则：必须以data-开头，多个单词由连字符“-”链接；单词中最好不要有大写字母；在JS中获取自定义属性值时，多个单词将被转化为驼峰命名。
6、编译时设置初始化页面及参数，自定义编译。
7、通过“&”连接多个页面参数。
8、垂直居中问题，将组件用一个容器包裹起来，使用flex盒子模型。建议多使用flex进行元素布局。
9、动态设置导航栏标题，两种方法，使用配置文件配置导航栏标题，使用wx.setNavigationBarTitle(OBJECT)设置导航条。
10、页面的导航栏标题必须在页面生命周期的onReady之后来设置，否则无效。新版本，放到哪里都可成功，建议，在onReady函数里进行界面设置操作。


第 7 章 收藏、评论、点赞与计数功能
1、学习交互反馈组件、缓存的应用、图片选择和预览、屏蔽关键字、录音、拍照以及播放录音等功能。
2、wxml组件也像js代码一样有if else就可以解决动态显示收藏图片的问题。
3、交互式反馈，wx:showToast,
4、mask指定是否显式透明的蒙层，以防止触摸穿透，默认值为false。主要防止用户连续点击收藏按钮。
5、数据绑定的写法确实非常简化、方便。只需在js中改变各类变量的状态和值，前端组件就会响应操作，动态地做出改变。
6、本地缓存的重要性，极大地改善客户端的体验与服务器的性能。
7、在一个高性能的产品中，缓存的重要性是不言而喻的。视为本地的key&value,并封装一些类和公共方法，提供给项目中各个调用方。
8、最好不要让getStorage、setStorage等方法充斥在项目的每一个角落。
9、实现对缓存的良好的管理，并向调用方提供一系列可读性非常强的API。
10、评论支持文本、图片和录音3种类型。
11、一条评论，规则：图片类型评论最多只能包含3张图片；音频类型评论只能包含一条音频；一条评论可同时包含文字和图片；音频类型不能包含文字和图片。
12、样式使用position:absolute，为了编写新增评论的功能而准备的。
13、图片预览，wx.previewImage(object)，有两个重要的属性：current，urls。类似于相册，可左右滑动查看多张图片。
14、注意：目前130400版本，本地文件既无法在模拟器中预览，也无法在真机中预览；临时文件无法在模拟器中预览，却可在真机中预览。
15、wx:if的切换和渲染机制较为复杂。MINA框架有一个局部渲染的过程，它会确保条件块在切换时销毁或重新渲染。
16、hidden简单的多，组件始终会被渲染，只是简单地控制显示与隐藏。
17、wx:if有更高的切换消耗，而hidden有更高的初始渲染消耗。需要频繁切换的情况下用hidden更好。在运行时条件不大可能改变时用wx:if较好。
18、input，maxlength，默认140。4个事件，bindinput(非常适合做即时搜索)、bindfocus、bindblur、bindconfirm。属非冒泡事件。
19、屏蔽关键字，
20、小程序中，只有一种方式可以操作数据，即数据绑定。重新做数据绑定。实际开发中会有大量插入元素的需求。
21、在模拟器中实现回车发送评论消息功能，可用bindchange、bindblur、bindconfirm。
22、为代码可读性，建议开发者将变量明确地在data属性中标识出来。
23、在小程序中使用CSS3动画，适度使用动画将大大提升客户端的体验。注意：在一些性能不好的手机上，动画将大大消耗手机性能。建议能不用动画尽量不用。
24、注意：一定要处理用户拒绝授权的场景，否则程序有可能发生非常严重的错误。


第 8 章 背景音乐播放
1、音乐播放不受页面关闭的影响。同时只能有一个后台音乐在播放。若不主动关闭，只有在退出小程序后音乐播放才停止。
2、歌曲只能是网络流媒体，不能播放本地音乐文件。
3、理解子页面被卸载特性。
4、监听音乐播放，
5、全局音乐的播放，
6、音乐总控开关，使用监控API。


第 9 章 丰富文章页面
1、分享功能以及animation动画。
2、微信小程序只能分享给好友和群聊，不能分享到朋友圈。
3、注意：分享按钮时页面的行为，不是应用程序的行为。
4、设置页面分享的API，onShareAPPMessage。
5、不可以自定义分享按钮，只能使用小程序页面右上角的按钮进行分享。
6、注意：分享图片是不能自动义的，MIMA框架会将当前页面从顶部开始、高度为80%屏幕宽度的图像作为分享图片。
7、无论如何，右上角的按钮是无法隐藏或者取消的。
8、很多小程序的推广都是依靠微信群聊在传播。
9、在冒泡事件中，target指的是事件最开始触发的元素，而currentTarget指的是捕获事件的元素。
10、使用动画实现点赞特效，
11、MIMA提供一组动画API，wx.createAnimation，概念：动画实例，动画组，动画方法，动画队列。
12、一个动画实例，可对这个实例设置多个动画组，而每个动画组中会有若干个动画方法。组与组之间使用step方法分隔，多个组形成一个链式的调用队列(动画队列)。
13、牢记：同一组中的动画方法会同时执行，但动画组必须是先后执行。
14、常见动画方法，动画属于实践非常强的知识点。


第 10 章 电影
1、豆瓣开放API，使用wx.request获取真实的网络数据，并将数据“填充”到小程序中。
2、多层嵌套模板的使用技巧。优势
3、tabBar至少两个，至多5个tab选项。tab顺序由数组中object的顺序决定。pagePath，必须预先在app.json的pages中定义。iconPath，图片大小限制为最大40KB，建议尺寸为81px*81px。
4、建议不要在pagePath、iconPath和selectIconPath前使用“/”开头。
5、嵌套模板的使用可以避免写重复的代码，大量的wxml代码将被复用。
6、开放API，是指某些公司、企业将自己公司所持有的数据、用户数据选择性地开放给开发者调用，让开发者可以使用数据并围绕这些数据构建自己的应用，从而帮助公司、企业完善其平台和生态。
7、目前，绝大数的开放API都属于RESTFul风格的API。API权限：公开、高级、商务。
8、公开API无须申请即可调用，具有40次/分钟的访问限制。高级权限和商务权限需要邮件申请。
9、注意：在header中不能设置referer，在小程序中referer是一个固定格式的值。
10、注意：method的值必须大写。
11、wx.request，url中不能有端口；默认超时时间和最大值超时时间都是60s；最大并发数是5。
12、设置wx.request的超时时间，networkTimeout配置项。
13、wx.request是一个异步方法，且小程序只提供了异步发送http/https请求的方法。没有同步版本。只能在异步方法提供的回调函数中进行返回结果的处理。
14、Postman或Fiddler来调用豆瓣API查看返回的数据格式。
15、动态设置数据绑定key的方法。考察开发者对JS动态属性的理解。
16、http和https在小程序中的使用说明。
17、为保证数据的安全性，小程序强制要求使用https，且所访问的https地址在小程序的后台账号中被入到可信域名中。
18、模板是不具备运行，只能将模板的业务逻辑编写在其他页面的js文件中，再将处理好的业务数据传递到模板中。用好模板将大大简化代码，提高代码的可阅读性与可维护性。
19、获取数据->处理数据->绑定数据的流程几乎是小程序js文件编写的通用思路与步骤。
20、默认将一次加载20条电影数据。
21、下拉刷新是APP上经典的一个动作。三部曲：配置enablePullDownRefresh选项，打开下拉刷新开关；编写onPullDownRefresh函数，完成自己的下拉刷新逻辑；主动调用wx.stopPullDownRefresh函数停止当前页面的下拉刷新。
22、在模拟器中可执行下拉刷新但在真机中无法执行下拉刷新。